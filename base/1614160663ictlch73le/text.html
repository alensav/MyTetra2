<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN" "http://www.w3.org/TR/REC-html40/strict.dtd">
<html><head><meta name="qrichtext" content="1" /><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><style type="text/css">
p, li { white-space: pre-wrap; }
</style></head><body style=" font-family:'DejaVu Sans'; font-size:11pt; font-weight:400; font-style:normal;">
<p style=" margin-top:18px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><a name="fded"></a><span style=" font-family:'Ubuntu'; font-size:xx-large; font-weight:600;">Н</span><span style=" font-family:'Ubuntu'; font-size:xx-large; font-weight:600;">астройка и применение. Часть 2</span></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><img src="image642818430.png" /></p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><a href="https://medium.com/@p1t1ch?source=post_page-----8e4939bb1492--------------------------------"><span style=" font-family:'Ubuntu'; text-decoration: underline; color:#0000ff;">p1t1ch</span></a></p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><a href="https://medium.com/@p1t1ch/visual-studio-code-настройка-и-применение-часть-2-8e4939bb1492?source=post_page-----8e4939bb1492--------------------------------"><span style=" font-family:'Ubuntu'; text-decoration: underline; color:#0000ff;">Nov 27, 2018·21 min read</span></a></p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><a name="2ca8"></a><span style=" font-family:'Ubuntu'; font-style:italic;">В</span><span style=" font-family:'Ubuntu'; font-style:italic;">торая часть глубоко субъективного гайда по VSCode.</span></p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><a name="dade"></a><span style=" font-family:'Ubuntu'; font-style:italic;">Э</span><span style=" font-family:'Ubuntu'; font-style:italic;">то вторая часть статьи по VSCode. Перейти к 1-ой части можно по </span><a href="https://medium.com/p/7f1a26806522"><span style=" font-family:'Ubuntu'; font-style:italic; text-decoration: underline; color:#0000ff;">этой ссылке</span></a><span style=" font-family:'Ubuntu'; font-style:italic;">.</span></p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><a name="da23"></a><span style=" font-family:'Ubuntu';">В</span><span style=" font-family:'Ubuntu';"> рамках второй части этой статьи будут рассмотрены аспекты работы с редактором, которые не были затронуты в первой части, а именно:</span></p>
<ol style="margin-top: 0px; margin-bottom: 0px; margin-left: 0px; margin-right: 0px; -qt-list-indent: 1;"><li style=" font-family:'Ubuntu';" style=" margin-top:12px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><a name="deaf"></a><a href="https://medium.com/@p1t1ch/visual-studio-code-%D0%BD%D0%B0%D1%81%D1%82%D1%80%D0%BE%D0%B9%D0%BA%D0%B0-%D0%B8-%D0%BF%D1%80%D0%B8%D0%BC%D0%B5%D0%BD%D0%B5%D0%BD%D0%B8%D0%B5-%D1%87%D0%B0%D1%81%D1%82%D1%8C-2-8e4939bb1492#c5f3"><span style=" font-weight:600; text-decoration: underline; color:#0000ff;">О</span></a><span style=" font-weight:600; text-decoration: underline; color:#0000ff;">тладка.</span><span style=" font-weight:600;"> </span>Настраиваем отладку клиентского кода на уровне редактора.</li>
<li style=" font-family:'Ubuntu';" style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><a name="b431"></a><a href="https://medium.com/@p1t1ch/visual-studio-code-%D0%BD%D0%B0%D1%81%D1%82%D1%80%D0%BE%D0%B9%D0%BA%D0%B0-%D0%B8-%D0%BF%D1%80%D0%B8%D0%BC%D0%B5%D0%BD%D0%B5%D0%BD%D0%B8%D0%B5-%D1%87%D0%B0%D1%81%D1%82%D1%8C-2-8e4939bb1492#7ddd"><span style=" font-weight:600; text-decoration: underline; color:#0000ff;">З</span></a><span style=" font-weight:600; text-decoration: underline; color:#0000ff;">апуск тасков.</span><span style=" font-weight:600;"> </span>Альтернативный подход к запуску npm-скриптов, который предоставляет VSCode вместо обычного ввода команд в терминал.</li>
<li style=" font-family:'Ubuntu';" style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><a name="ea0b"></a><a href="https://medium.com/@p1t1ch/visual-studio-code-%D0%BD%D0%B0%D1%81%D1%82%D1%80%D0%BE%D0%B9%D0%BA%D0%B0-%D0%B8-%D0%BF%D1%80%D0%B8%D0%BC%D0%B5%D0%BD%D0%B5%D0%BD%D0%B8%D0%B5-%D1%87%D0%B0%D1%81%D1%82%D1%8C-2-8e4939bb1492#40c3"><span style=" font-weight:600; text-decoration: underline; color:#0000ff;">С</span></a><span style=" font-weight:600; text-decoration: underline; color:#0000ff;">ниппеты.</span><span style=" font-weight:600;"> </span>Общая информация по сниппетам и описание процесса работы с ними в VSCode.</li>
<li style=" font-family:'Ubuntu';" style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><a name="e455"></a><a href="https://medium.com/@p1t1ch/visual-studio-code-%D0%BD%D0%B0%D1%81%D1%82%D1%80%D0%BE%D0%B9%D0%BA%D0%B0-%D0%B8-%D0%BF%D1%80%D0%B8%D0%BC%D0%B5%D0%BD%D0%B5%D0%BD%D0%B8%D0%B5-%D1%87%D0%B0%D1%81%D1%82%D1%8C-2-8e4939bb1492#cf34"><span style=" font-weight:600; text-decoration: underline; color:#0000ff;">I</span></a><span style=" font-weight:600; text-decoration: underline; color:#0000ff;">ntellisense.</span><span style=" font-weight:600;"> </span>Встроенные возможности автосаджеста и способы увеличения отдачи редактора по написанному вами коду.</li>
<li style=" font-family:'Ubuntu';" style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><a name="85c6"></a><a href="https://medium.com/@p1t1ch/visual-studio-code-%D0%BD%D0%B0%D1%81%D1%82%D1%80%D0%BE%D0%B9%D0%BA%D0%B0-%D0%B8-%D0%BF%D1%80%D0%B8%D0%BC%D0%B5%D0%BD%D0%B5%D0%BD%D0%B8%D0%B5-%D1%87%D0%B0%D1%81%D1%82%D1%8C-2-8e4939bb1492#635b"><span style=" font-weight:600; text-decoration: underline; color:#0000ff;">Л</span></a><span style=" font-weight:600; text-decoration: underline; color:#0000ff;">интинг и форматирование.</span><span style=" font-weight:600;"> </span>Добавление поддержки линтеров на уровне редактора и форматирование кода.</li>
<li style=" font-family:'Ubuntu';" style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><a name="ac55"></a><a href="https://medium.com/@p1t1ch/visual-studio-code-%D0%BD%D0%B0%D1%81%D1%82%D1%80%D0%BE%D0%B9%D0%BA%D0%B0-%D0%B8-%D0%BF%D1%80%D0%B8%D0%BC%D0%B5%D0%BD%D0%B5%D0%BD%D0%B8%D0%B5-%D1%87%D0%B0%D1%81%D1%82%D1%8C-2-8e4939bb1492#c36a"><span style=" font-weight:600; text-decoration: underline; color:#0000ff;">L</span></a><span style=" font-weight:600; text-decoration: underline; color:#0000ff;">ive Share.</span><span style=" font-weight:600;"> </span>Использование новомодной технологии от Microsoft для шаринга кода.</li>
<li style=" font-family:'Ubuntu';" style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><a name="da8f"></a><a href="https://medium.com/@p1t1ch/visual-studio-code-%D0%BD%D0%B0%D1%81%D1%82%D1%80%D0%BE%D0%B9%D0%BA%D0%B0-%D0%B8-%D0%BF%D1%80%D0%B8%D0%BC%D0%B5%D0%BD%D0%B5%D0%BD%D0%B8%D0%B5-%D1%87%D0%B0%D1%81%D1%82%D1%8C-2-8e4939bb1492#467e"><span style=" font-weight:600; text-decoration: underline; color:#0000ff;">В</span></a><span style=" font-weight:600; text-decoration: underline; color:#0000ff;">нешние зависимости.</span><span style=" font-weight:600;"> </span>Использование возможностей VSCode для упрощения управления версиями подключаемых библиотек.</li>
<li style=" font-family:'Ubuntu';" style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><a name="cf29"></a><a href="https://medium.com/@p1t1ch/visual-studio-code-%D0%BD%D0%B0%D1%81%D1%82%D1%80%D0%BE%D0%B9%D0%BA%D0%B0-%D0%B8-%D0%BF%D1%80%D0%B8%D0%BC%D0%B5%D0%BD%D0%B5%D0%BD%D0%B8%D0%B5-%D1%87%D0%B0%D1%81%D1%82%D1%8C-2-8e4939bb1492#3f7f"><span style=" font-weight:600; text-decoration: underline; color:#0000ff;">В</span></a><span style=" font-weight:600; text-decoration: underline; color:#0000ff;">изуальный стиль.</span><span style=" font-weight:600;"> </span>Улучшение внешнего стиля редактора через применение кастомных цветовых / иконочных тем и шрифта.</li>
<li style=" font-family:'Ubuntu';" style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><a name="530e"></a><a href="https://medium.com/@p1t1ch/visual-studio-code-%D0%BD%D0%B0%D1%81%D1%82%D1%80%D0%BE%D0%B9%D0%BA%D0%B0-%D0%B8-%D0%BF%D1%80%D0%B8%D0%BC%D0%B5%D0%BD%D0%B5%D0%BD%D0%B8%D0%B5-%D1%87%D0%B0%D1%81%D1%82%D1%8C-2-8e4939bb1492#3b1e"><span style=" font-weight:600; text-decoration: underline; color:#0000ff;">А</span></a><span style=" font-weight:600; text-decoration: underline; color:#0000ff;">ссоциация типов файлов.</span><span style=" font-weight:600;"> </span>Правим распознавание редактором файлов экзотических расширений.</li>
<li style=" font-family:'Ubuntu';" style=" margin-top:0px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><a name="1ddf"></a><a href="https://medium.com/@p1t1ch/visual-studio-code-%D0%BD%D0%B0%D1%81%D1%82%D1%80%D0%BE%D0%B9%D0%BA%D0%B0-%D0%B8-%D0%BF%D1%80%D0%B8%D0%BC%D0%B5%D0%BD%D0%B5%D0%BD%D0%B8%D0%B5-%D1%87%D0%B0%D1%81%D1%82%D1%8C-2-8e4939bb1492#f95a"><span style=" font-weight:600; text-decoration: underline; color:#0000ff;">П</span></a><span style=" font-weight:600; text-decoration: underline; color:#0000ff;">рочие расширения.</span><span style=" font-weight:600;"> </span>Несколько полезных плагинов, не попавших под остальные категории.</li></ol>
<p style=" margin-top:18px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><a name="c5f3"></a><span style=" font-family:'Ubuntu'; font-size:xx-large; font-weight:600;">О</span><span style=" font-family:'Ubuntu'; font-size:xx-large; font-weight:600;">тладка</span></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><img src="image1666018984.png" /><img src="image394722064.png" /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Ubuntu';">Процесс отладки клиентской части с расширением Debugger for Chrome</span></p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><a name="ef7c"></a><span style=" font-family:'Ubuntu';">И</span><span style=" font-family:'Ubuntu';">з коробки VSCode позволяет отлаживать Node.js. Как фронтенд-разработчика, меня всё же интересует отладка клиентских скриптов. Обычно это делается указанием точек останова через debugger и обращение к инструментам разработчика в Chrome. Однако VSCode позволяет управлять процессом отладки клиентского кода прямо из редактора по аналогии с отладкой Ноды. Реализуется это через расширение, которое мы сейчас рассмотрим.</span></p>
<p style=" margin-top:16px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><a name="e31f"></a><a href="https://marketplace.visualstudio.com/items?itemName=msjsdiag.debugger-for-chrome"><span style=" font-family:'Ubuntu'; font-size:x-large; font-weight:600; text-decoration: underline; color:#0000ff;">D</span></a><span style=" font-family:'Ubuntu'; font-size:x-large; font-weight:600; text-decoration: underline; color:#0000ff;">ebugger for Chrome</span></p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><a name="7a6e"></a><span style=" font-family:'Ubuntu';">П</span><span style=" font-family:'Ubuntu';">одх</span><a name="rmm"></a><span style=" font-family:'Ubuntu';">о</span><span style=" font-family:'Ubuntu';">д к отладке через данное расширение сводит к минимуму переключение контекста, что способствует общему повышению производительности. Более того подобный подход стимулирует людей, привыкших к отладке через вывод логов в консоль, наконец начать использовать полноценные средства отладки. Для тех же, кто ставит debugger внутри кода или брейкпоинты в Chrome Devtools, предоставляет более комфортные условия для работы. Раньше в простых случаях хотелось просто написать console.log(), теперь же такого желания нет, т.к. щёлкнуть по полю и нажать F5 будет даже быстрее.</span></p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><a name="0149"></a><span style=" font-family:'Ubuntu';">Ч</span><span style=" font-family:'Ubuntu';">тобы отладка работала, на проекте должны быть определены </span><span style=" font-family:'Ubuntu'; font-weight:600;">sourcemaps </span><span style=" font-family:'Ubuntu';">и корректно работать, т.к. отладчик использует их для навигации по исходному коду. На старых рабочих проектах с gulp-file-include, например, заставить работать отладку мне не удалось. На новом проекте Webpack с ES-модулями и прописанными соурсмапами, всё работает идеально. Если это условие соблюдено, то единственное, что нужно здесь сделать — это прописать корректный конфиг отладки. Сделав это один раз под проект, к нему уже не придётся возвращаться.</span></p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><a name="2e90"></a><span style=" font-family:'Ubuntu';">К</span><span style=" font-family:'Ubuntu';">онфигурации запуска бывают 2-х видов: </span><span style=" font-family:'Ubuntu'; font-weight:600;">launch </span><span style=" font-family:'Ubuntu';">и </span><span style=" font-family:'Ubuntu'; font-weight:600;">attach</span><span style=" font-family:'Ubuntu';">. Разница в том, что launch запускает Chrome, а attach привязывается к уже запущенному процессу. В целом, при работе с Webpack attach звучит лучше, однако для этого нужно изначально открывать браузер с флагом </span><span style=" font-family:'Ubuntu'; font-weight:600;">--remote-debugging-port</span><span style=" font-family:'Ubuntu';">, что возможно только через консоль, но это максимально неудобно. Так что я остановился на варианте с launch — при запуске дебага открывается отдельное окно для отладки — небольшой tradeoff, т.к. хотелось бы всё делать в одном окне, но всё же удобнее, чем запускать Chrome из консоли.</span></p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><a name="6798"></a><span style=" font-family:'Ubuntu';">К</span><span style=" font-family:'Ubuntu';">онфигурации можно задавать как на уровне проектов (.vscode &gt; launch.json), так и глобально в настройках. Практика показывает, что удобнее задавать их на уровне отдельных проектов, т.к. в каждом проекте могут быть свои особенности. Допустим, где-то удобнее поменять корневую директорию, где-то прописать специфические файлы в blacklist и т.д. Хотя ничто не мешает иметь нейтральный глобальный конфиг, который будет переопределяться по необходимости.</span></p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><a name="4543"></a><span style=" font-family:'Ubuntu';">Д</span><span style=" font-family:'Ubuntu';">ля отладки предоставлена отдельная вкладка Debug панели управления. Из неё же можно перейти к файлу конфигурации при необходимости. При первом запуске отладки (F5) этот конфиг создастся сам и откроется на редактирование — нужно только выбрать Chrome в появившемся меню (этот вариант как раз и добавляет плагин). Конфигурация очень простая: в поле </span><span style=" font-family:'Ubuntu'; font-weight:600;">url </span><span style=" font-family:'Ubuntu';">нужно указать порт, на котором у вас запускается проект, а в поле </span><span style=" font-family:'Ubuntu'; font-weight:600;">webRoot </span><span style=" font-family:'Ubuntu';">адрес рабочей директории. В моём случае:</span></p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><a name="cf66"></a><span style=" font-family:'Courier New,courier';">“</span><span style=" font-family:'Courier New,courier';">url”: “http://localhost:3000&quot;,<br />“webRoot”: “${workspaceFolder}/html”,</span></p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><a name="2e18"></a><span style=" font-family:'Ubuntu'; font-style:italic;">П</span><span style=" font-family:'Ubuntu'; font-style:italic;">еременная </span><span style=" font-family:'Ubuntu'; font-weight:600; font-style:italic;">workspaceFolder </span><span style=" font-family:'Ubuntu'; font-style:italic;">— это абсолютный путь до корневой директории вашего проекта (та, где лежит папка .vscode).</span></p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><a name="1f51"></a><span style=" font-family:'Ubuntu';">Т</span><span style=" font-family:'Ubuntu';">акже расширение поддерживает </span><span style=" font-family:'Ubuntu'; font-weight:600;">blackboxing</span><span style=" font-family:'Ubuntu';">, как и оригинальные Chrome Devtools, т.е. исключение ненужных файлов/директорий, чтобы при отладке перемещаться только по своему коду, а не проваливаться постоянно в скрипты внешних библиотек. Делается это через указание массива </span><span style=" font-family:'Ubuntu'; font-weight:600;">skipFiles </span><span style=" font-family:'Ubuntu';">в настройках. Здесь нужно поиграться, т.к. путь до файлов зависит от того, как на вашем проекте настроены соурсмапы.</span></p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><a name="42bf"></a><span style=" font-family:'Ubuntu';">Н</span><span style=" font-family:'Ubuntu';">у и всё. Теперь мы можем ставить брейкпоинты кликом на полях, ходить по коду внутри приятного глазу редактора, видеть встроенный консольный лог, иметь доступ к переменным, отслеживать нужные нам через watch и с пониманием дела любоваться изменением call stack.</span></p>
<p style=" margin-top:18px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><a name="7ddd"></a><span style=" font-family:'Ubuntu'; font-size:xx-large; font-weight:600;">З</span><span style=" font-family:'Ubuntu'; font-size:xx-large; font-weight:600;">апуск тасков</span></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><img src="image1220609739.png" /><img src="image1449165513.png" /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Ubuntu';">Список определённых на уровне package.json yarn скриптов и их автоматическое определение на уровне VSCode</span></p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><a name="bf28"></a><span style=" font-family:'Ubuntu';">V</span><span style=" font-family:'Ubuntu';">SCode поддерживает исполнение тасков через палитру команд. В качестве тасков могут идти, например, npm скрипты или gulp таски. VSCode автоматически определяет такие команды и предоставляет их список при выполнении команды </span><span style=" font-family:'Ubuntu'; font-weight:600;">Tasks: Run Task</span><span style=" font-family:'Ubuntu';">. После выбора таска из списка в первый раз информация по нему пропишется в </span><span style=" font-family:'Ubuntu'; font-weight:600;">tasks.json</span><span style=" font-family:'Ubuntu';"> в вашей директории .vscode, в следующий раз же будет запускаться сразу. Запущенному таску выделяется отдельный терминал, который открывается после запуска, а список запущенных тасков отображается в нижнем баре. По нажатию на кнопку выведется список тасков, выбор таска перекинет на соответствующий терминал. Здесь можно прекратить выполнение нажатием Ctrl + C.</span></p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><a name="5b36"></a><span style=" font-family:'Ubuntu';">Л</span><span style=" font-family:'Ubuntu';">ично я пользуюсь yarn скриптами, что по сути те же npm скрипты — VSCode их так и определяет. В </span><span style=" font-family:'Ubuntu'; font-weight:600;">package.json</span><span style=" font-family:'Ubuntu';"> в поле </span><span style=" font-family:'Ubuntu'; font-weight:600;">script </span><span style=" font-family:'Ubuntu';">у меня прописан набор тасков, после чего в консоли я просто пишу, например, </span><span style=" font-family:'Ubuntu'; font-weight:600;">yarn dev</span><span style=" font-family:'Ubuntu';"> и выполняется development сборка (через npm писалось бы </span><span style=" font-family:'Ubuntu'; font-weight:600;">npm run dev</span><span style=" font-family:'Ubuntu';">).</span></p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><a name="d769"></a><span style=" font-family:'Ubuntu';">И</span><span style=" font-family:'Ubuntu';">спользуя механизм тасков из VSCode я могу сделать то же самое через палитру команд. По сути это просто модная альтернатива: открыть палитру команд, далее </span><span style=" font-family:'Ubuntu'; font-weight:600;">Run Task</span><span style=" font-family:'Ubuntu';"> и выбрать </span><span style=" font-family:'Ubuntu'; font-weight:600;">npm:dev</span><span style=" font-family:'Ubuntu';"> не быстрее, чем открыть консоль и прописать </span><span style=" font-family:'Ubuntu'; font-weight:600;">yarn dev</span><span style=" font-family:'Ubuntu';">. К тому же терминал всё равно открывается после выполнения команды через механизм тасков, так что места мы здесь не выигрываем. Другое дело, если бы терминал не открывался, а команда исполнялась в фоне — тогда бы экономилась одна консоль под watch, и не нужно было бы делить терминал надвое.</span></p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><a name="8fe3"></a><span style=" font-family:'Ubuntu';">О</span><span style=" font-family:'Ubuntu';">днако таски имеют одно преимущество над обычным запуском (помимо пафосности) — их можно привязывать к горячим клавишам. Так можно определить основной </span><span style=" font-family:'Ubuntu'; font-weight:600;">build</span><span style=" font-family:'Ubuntu';"> и </span><span style=" font-family:'Ubuntu'; font-weight:600;">test </span><span style=" font-family:'Ubuntu';">таски через соответствующие команды и запускать build-таск через </span><span style=" font-family:'Ubuntu'; font-weight:600;">Ctrl + Shift + B</span><span style=" font-family:'Ubuntu';">, а для теста придётся привязать свою комбинацию, по умолчанию её нет. Но что если у меня не только build и test? Как видно из списка скриптов на скриншоте, я, как минимум, широко использую команду для development-сборки, команду для production-сборки, запуск статического сервера для тестирования production-сборки и запуск анализатора. Не проблема, т.к. VSCode позволяет привязать к каждому таску свою комбинацию.</span></p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><a name="505b"></a><span style=" font-family:'Ubuntu';">Ч</span><span style=" font-family:'Ubuntu';">тобы этого добиться, нужно в tasks.json дать имена таскам, которым мы собираемся присвоить шорткаты. Делается это через поле </span><span style=" font-family:'Ubuntu'; font-weight:600;">label</span><span style=" font-family:'Ubuntu';">. Например, таск yarn dev в tasks.json будет выглядеть следующим образом (</span><span style=" font-family:'Ubuntu'; font-weight:600;">group </span><span style=" font-family:'Ubuntu';">здесь добавлен, т.к. этот таск сделан основным build таском):</span></p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><a name="4418"></a><span style=" font-family:'Courier New,courier';">{</span><span style=" font-family:'Courier New,courier';"><br />    “label”: “Development build”,<br />    “type”: “npm”,<br />    “script”: “dev”,<br />    “path”: “html/”,<br />    “group”: {<br />        “kind”: “build”,<br />        “isDefault”: true<br />    }<br />}</span></p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><a name="cab9"></a><span style=" font-family:'Ubuntu';">Д</span><span style=" font-family:'Ubuntu';">алее переходим в </span><span style=" font-family:'Ubuntu'; font-weight:600;">keybindings.json</span><span style=" font-family:'Ubuntu';"> (Preferences: Open Keyboard Shortcuts File) и добавляем в список пользовательских команд новую по типу:</span></p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><a name="2b8c"></a><span style=" font-family:'Courier New,courier';">{</span><span style=" font-family:'Courier New,courier';"><br />    “key”: “ctrl+k f1”,<br />    “command”: “workbench.action.tasks.runTask”,<br />    “args”: “Development build”<br />}</span></p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><a name="f2e3"></a><span style=" font-family:'Ubuntu';">З</span><span style=" font-family:'Ubuntu';">десь значение </span><span style=" font-family:'Ubuntu'; font-weight:600;">args </span><span style=" font-family:'Ubuntu';">совпадает со значением </span><span style=" font-family:'Ubuntu'; font-weight:600;">label </span><span style=" font-family:'Ubuntu';">вашего таска. В качестве комбинаций я решил выбрать Ctrl + K с последующей F-клавишей. Так эти 4 основных таска распределены у меня по клавишам F1-F4. Только нужно проследить за тем, что клавиша после Ctrl + K сама по себе не является шорткатом. По этой причине пришлось отвязать F1.</span></p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><a name="a1e9"></a><span style=" font-family:'Ubuntu';">П</span><span style=" font-family:'Ubuntu';">осле такой настройки исполнение тасков действительно происходит быстрее и можно оставить себе единственный рабочий терминал. Если вы тоже у себя в работе используете что-то подобное, то рекомендую, как минимум, попробовать такой подход.</span></p>
<p style=" margin-top:18px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><a name="40c3"></a><span style=" font-family:'Ubuntu'; font-size:xx-large; font-weight:600;">С</span><span style=" font-family:'Ubuntu'; font-size:xx-large; font-weight:600;">ниппеты</span></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><img src="image989672855.png" /><img src="image2051323832.png" /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Ubuntu';">Список встроенных сниппетов для js</span></p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><a name="7a8d"></a><span style=" font-family:'Ubuntu';">Н</span><span style=" font-family:'Ubuntu';">емного о сниппетах, о том, как с ними работать в VSCode. Для тех, кто никогда не пользовался сниппетами, пару слов пояснения. Сниппеты — это фрагменты кода, спрятанные за кодовым словом. При вводе этого слова и нажатии Tab или Enter ассоциированный с ним код раскрывается, и кроме того предоставляется набор позиций для курсора, по которым мы можем пройти по Tab, пока не окажемся на конечной позиции — так называемые </span><span style=" font-family:'Ubuntu'; font-weight:600;">табстопы </span><span style=" font-family:'Ubuntu';">(tab stops). Система сниппетов есть в любом уважающем себя редакторе, есть она и в VSCode, так что остаётся понять как ей здесь пользоваться.</span></p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><a name="f686"></a><span style=" font-family:'Ubuntu';">П</span><span style=" font-family:'Ubuntu';">ри написании кода сниппеты будут предлагаться в автосаджесте. Как пример, for: начинаем вводить “for” — видим сниппет в списке, нажимаем Tab или Enter, после чего код разворачивается и располагает курсоры на всех вхождениях индексов, чтобы мы задали им имя (при этом там уже есть предустановленное значение — плейсхолдер). Tab и мы на вхождениях имени массива, Tab и мы на имени переменной элемента внутри цикла, Tab и мы внутри цикла продолжаем писать код. Ни одного переключения на мышь за весь процесс, никаких повторений засчёт множественного выделения, никаких повторений статичных частей конструкций из раза в раз.</span></p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><a name="bcab"></a><span style=" font-family:'Ubuntu';">С</span><span style=" font-family:'Ubuntu';">ниппеты делятся на глобальные и локальные для отдельных типов файлов. Из коробки VSCode предоставляет небольшой перечень сниппетов для js, покрывающий основные типовые команды. Чтобы наглядно посмотреть список доступных сниппетов, введите в палитре команд </span><span style=" font-family:'Ubuntu'; font-weight:600;">Insert Snippet</span><span style=" font-family:'Ubuntu';">. Также если вы собираетесь активно ими пользоваться, будет полезно поставить эту команду на горячую клавишу. Обращаю внимание, что это локальные сниппеты только для js, так что вы не увидите их при написании разметки или стилей.</span></p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><a name="fab4"></a><span style=" font-family:'Ubuntu';">И</span><span style=" font-family:'Ubuntu';">з встроенного набора могут быть особенно полезны log для вывода лога, сниппеты для циклов (for, foreach, forin), switch, settimeout. Не сказать, что я пользуюсь forin, но обращаю на него здесь внимание, из-за интересного момента, что он сразу идёт с обёрткой в hasOwnProperty. switch я использую редко, поэтому раньше всегда проверял как он пишется — теперь никуда лезть не нужно.</span></p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><a name="39f4"></a><span style=" font-family:'Ubuntu';">П</span><span style=" font-family:'Ubuntu';">о умолчанию в списке автосаджеста сниппеты идут по алфавиту вместе с остальными конструкциями. Мне кажется более разумным выносить их отдельно в самый верх списка — так о них не будешь забывать, да и визуально список они не будут засорять:</span></p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><a name="bf9f"></a><span style=" font-family:'Courier New,courier';">“</span><span style=" font-family:'Courier New,courier';">editor.snippetSuggestions”: “top”,</span></p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><a name="286a"></a><span style=" font-family:'Ubuntu'; font-style:italic;">Х</span><span style=" font-family:'Ubuntu'; font-style:italic;">отя это дискуссионный вопрос. Как другой подход, вообще убрать их из автосаджеста, смотрите сами.</span></p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><a name="e2b6"></a><span style=" font-family:'Ubuntu';">Н</span><span style=" font-family:'Ubuntu';">абор сниппетов можно расширять добавлением готовых пакетов сниппетов на маркетплейсе и прописыванием своих. На данный момент я не пользуюсь готовыми решениями, но может вы найдёте для себя подходящие. Для ES6 например очень популярен </span><a href="https://marketplace.visualstudio.com/items?itemName=xabikos.JavaScriptSnippets"><span style=" font-family:'Ubuntu'; text-decoration: underline; color:#0000ff;">этот пакет</span></a><span style=" font-family:'Ubuntu';">. Также популярны паки для основных фреймворков. Когда наконец переберусь на React, опробую их в деле 👍</span></p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><a name="9a4a"></a><span style=" font-family:'Ubuntu';">Н</span><span style=" font-family:'Ubuntu';">аписать свой сниппет несложно и делается это вызовом команды </span><span style=" font-family:'Ubuntu'; font-weight:600;">Preferences: Configure User Snippets</span><span style=" font-family:'Ubuntu';">, которая также доступна через кнопку настроек в нижнем левом углу редактора (иконка шестерёнки). После вызова выбираете язык, для которого предназначается этот сниппет — откроется JSON-файл, куда вы прописываете свои сниппеты. Каждый сниппет — это объект с 3 свойствами: prefix, body и description. </span><span style=" font-family:'Ubuntu'; font-weight:600;">prefix </span><span style=" font-family:'Ubuntu';">— команда, триггерящая ваш сниппет, </span><span style=" font-family:'Ubuntu'; font-weight:600;">body </span><span style=" font-family:'Ubuntu';">— непосредственно код сниппета и </span><span style=" font-family:'Ubuntu'; font-weight:600;">description </span><span style=" font-family:'Ubuntu';">— описание в автосаджесте. Внутри body для табстопов используются символы с долларами вроде </span><span style=" font-family:'Ubuntu'; font-weight:600;">$1</span><span style=" font-family:'Ubuntu';">, для последнего используется </span><span style=" font-family:'Ubuntu'; font-weight:600;">$0</span><span style=" font-family:'Ubuntu';">. Плейсхолдер указывается следующим образом: </span><span style=" font-family:'Ubuntu'; font-weight:600;">${1:label}</span><span style=" font-family:'Ubuntu';">. В общем-то это всё, что вам нужно. Например так выглядит мой сниппет для PostCSS, вставляющий свойство с calc из размера единицы сетки:</span></p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><a name="7d7d"></a><span style=" font-family:'Courier New,courier';">“</span><span style=" font-family:'Courier New,courier';">Gutter step”: {<br />    “prefix”: “gs”,<br />    “body”: “$1: calc(var( — gs) * $2);$0”,<br />    “description”: “Insert property with calc of gutter steps”<br />}</span></p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><a name="a058"></a><span style=" font-family:'Ubuntu';">К</span><span style=" font-family:'Ubuntu';">ак видите, всё предельно просто. Привыкните оформлять утомляющие вас фрагменты кода, повторяемые из раза в раз, в виде сниппетов, и жизнь станет проще.</span></p>
<p style=" margin-top:18px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><a name="cf34"></a><span style=" font-family:'Ubuntu'; font-size:xx-large; font-weight:600;">I</span><span style=" font-family:'Ubuntu'; font-size:xx-large; font-weight:600;">ntellisense</span></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><img src="image1798357651.png" /><img src="image1122681658.png" /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Ubuntu';">Вывод описания и параметров функции в списке автосаджеста после добавления аннотации JSDoc</span></p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><a name="2faa"></a><span style=" font-family:'Ubuntu';">I</span><span style=" font-family:'Ubuntu';">ntellisense — это общий термин для обозначения автокомплита кода и вывода списка автосаджеста и хинтов при написании. Из коробки VSCode поддерживает фронтендерский стек языков, для остальных же можно поставить расширение с маркетплейса. Именно наличие Intellisense отличает редактор кода от текстового редактора — мы чувствуем, что пишем код, и редактор помогает нам в его написании. Для js Intellisense предоставляет список возможных для использования функций, классов, методов, полей и т.д. Для css предоставляет список подходящих свойств с кратким описанием. При написании разметки дублирует функционал Emmet. Для типовых JSON-файлов с определённым набором полей предоставляет список полей при постановке кавычек и возможные значения после двоеточия — особенно явно это видно с package.json и c файлом настроек settings.json.</span></p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><a name="4006"></a><span style=" font-family:'Ubuntu';">П</span><span style=" font-family:'Ubuntu';">о настройкам меня устраивает стандартная конфигурация. Единственное, что я поменял — это убрал вывод имён в автосаджест, т.е. обычных слов, которые забивают общий список:</span></p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><a name="89b4"></a><span style=" font-family:'Courier New,courier';">“</span><span style=" font-family:'Courier New,courier';">javascript.suggest.names”: false,</span></p>
<p style=" margin-top:16px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><a name="12cf"></a><span style=" font-family:'Ubuntu'; font-size:x-large; font-weight:600;">Д</span><span style=" font-family:'Ubuntu'; font-size:x-large; font-weight:600;">окументирование js кода</span></p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><a name="2ac4"></a><span style=" font-family:'Ubuntu';">С</span><span style=" font-family:'Ubuntu';">тоит немного рассказать о том, как получить профит от Intellisense для написанного вами кода. До Typescript я ещё не добрался, так что пользуюсь </span><span style=" font-family:'Ubuntu'; font-weight:600;">JSDoc</span><span style=" font-family:'Ubuntu';">-аннотациями. VSCode вставляет аннотацию после ввода </span><span style=" font-family:'Ubuntu'; font-weight:600;">/**</span><span style=" font-family:'Ubuntu';"> и нажатия Enter. Если речь идёт о функции, то VSCode попытается предположить наличие параметров и проставит табстопы по аналогии со сниппетами. От написания аннотаций для функций в принципе много профита — это и упрощает поддержку кода, и позволяет сгенерировать автоматическую документацию, но в отношении VSCode это кроме всего прочего даст нам хинты с описанием функции и её аргументов (типы и назначение). Например, мы документировали метод класса, позже создали объект класса, поставили </span><span style=" font-family:'Ubuntu'; font-weight:600;">“.”</span><span style=" font-family:'Ubuntu';"> и смотрим список автосаджеста. В нём мы увидим список всех методов и полей, но вместе с тем у нашего метода будет описание и корректные типы аргументов и возвращаемого типа (если есть). С другой стороны, когда код уже написан, мы можем навестись на имя метода и понять, что он делает по высвеченному описанию.</span></p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><a name="a226"></a><span style=" font-family:'Ubuntu';">Н</span><span style=" font-family:'Ubuntu';">апример, для метода открытия таба:</span></p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><a name="2670"></a><span style=" font-family:'Courier New,courier';">/</span><span style=" font-family:'Courier New,courier';">**<br />* Открывает панель таба.<br />*<br />* @param {Number} index Номер открываемой панели.<br />*/</span></p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><a name="c8a4"></a><span style=" font-family:'Ubuntu';">В</span><span style=" font-family:'Ubuntu';"> результате мы увидим картину, показанную на скриншоте в начале этого раздела.</span></p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><a name="8d26"></a><span style=" font-family:'Ubuntu';">Т</span><span style=" font-family:'Ubuntu';">акже рекомендую для сложных структур прописывать определение типов через </span><span style=" font-family:'Ubuntu'; font-weight:600;">@typedef</span><span style=" font-family:'Ubuntu';">. Например, для объекта состояний тех же табов:</span></p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><a name="5120"></a><span style=" font-family:'Courier New,courier';">/</span><span style=" font-family:'Courier New,courier';">**<br />* Состояние панели табов.<br />* @typedef {Object} TabsState<br />*<br />* @property {Number} index Индекс панели.<br />* @property {jQuery} $item Заголовок таба.<br />* @property {jQuery} $panel Панель таба.<br />* @property {String} itemId id заголовка таба.<br />* @property {String} panelId id панели таба.<br />*/</span></p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><a name="0f2a"></a><span style=" font-family:'Ubuntu';">И</span><span style=" font-family:'Ubuntu';"> в конструкторе описываем поле состояния, как соответствующее этому типу:</span></p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><a name="34d6"></a><span style=" font-family:'Courier New,courier';">/</span><span style=" font-family:'Courier New,courier';">**<br />* Cостояние активной панели табов.<br />* @type {TabsState}<br />*/</span></p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><a name="0b28"></a><span style=" font-family:'Ubuntu';">Б</span><span style=" font-family:'Ubuntu';">лагодаря такому определению, мы сразу можем увидеть из каких полей состоит объект состояния, который определяется позже на этапе инициализации.</span></p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><a name="6c5d"></a><span style=" font-family:'Ubuntu';">П</span><span style=" font-family:'Ubuntu';">осле этого VSCode выдаст нам следующие подсказки:</span></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><img src="image1505740871.png" /><img src="image1559359932.png" /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><img src="image1909964690.png" /><img src="image1785943674.png" /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Ubuntu';">Определение typedef добавляет подсказки при наведении на определённый тип и при обращении к полю этого типа</span></p>
<p style=" margin-top:18px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><a name="635b"></a><span style=" font-family:'Ubuntu'; font-size:xx-large; font-weight:600;">Л</span><span style=" font-family:'Ubuntu'; font-size:xx-large; font-weight:600;">интинг и форматирование</span></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><img src="image22560635.png" /><img src="image1279509610.png" /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Ubuntu';">Визуальная идентификация ошибок линтера на уровне редактора</span></p>
<p style=" margin-top:16px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><a name="e3d6"></a><span style=" font-family:'Ubuntu'; font-size:x-large; font-weight:600;">Л</span><span style=" font-family:'Ubuntu'; font-size:x-large; font-weight:600;">интинг</span></p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><a name="07a6"></a><span style=" font-family:'Ubuntu';">Ч</span><span style=" font-family:'Ubuntu';">то касается линтинга, то я сторонник подхода, при котором линтеры должны быть встроены проект, их конфиги должны быть утверждены и соответствовать единому кодстайлу. При таком подходе каждый работающий на проекте человек видит предупреждения линтера и работает с единым конфигом. То же самое касается и автоформатирования. Однако даже при таком подходе, когда линтер встроен в сборку, полезно иметь линтер на уровне редактора, т.к. в редакторе появляется подчёркивание некорректных фрагментов кода, а на вкладке Problems в нижней панели отображается список ошибок — это куда нагляднее, чем обычный вывод в консоль на уровне сборки. То есть иметь линтер на уровне сборки обязательно для всех на проекте, а интеграция в редактор, если подобная интеграция поддерживается, идёт как следующий уровень над линтером и упрощает работу, но уже по желанию. Таким образом, если у вас уже определены конфиги для линтеров на проекте, то вы просто передаёте эти же конфиги плагинам линтеров VSCode.</span></p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><a name="3eef"></a><span style=" font-family:'Ubuntu';">С</span><span style=" font-family:'Ubuntu';">обственно, что это за плагины? У себя я использую </span><span style=" font-family:'Ubuntu'; font-weight:600;">ESLint </span><span style=" font-family:'Ubuntu';">для js и </span><span style=" font-family:'Ubuntu'; font-weight:600;">Stylelint </span><span style=" font-family:'Ubuntu';">для css. Оба линтера настраиваются идентично. Сначала вам необходимо установить плагины из торговой площадки для VSCode: </span><a href="https://marketplace.visualstudio.com/items?itemName=dbaeumer.vscode-eslint"><span style=" font-family:'Ubuntu'; font-weight:600; text-decoration: underline; color:#0000ff;">ESLint</span></a><span style=" font-family:'Ubuntu'; font-weight:600;"> </span><span style=" font-family:'Ubuntu';">и </span><a href="https://marketplace.visualstudio.com/items?itemName=shinnn.stylelint"><span style=" font-family:'Ubuntu'; font-weight:600; text-decoration: underline; color:#0000ff;">Stylelint</span></a><span style=" font-family:'Ubuntu';">.</span></p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><a name="7c92"></a><span style=" font-family:'Ubuntu';">Ч</span><span style=" font-family:'Ubuntu';">тобы плагины работали, нужно чтобы у вас кроме плагинов были установлены сами линтеры. Т.к. проект изначально построен с линтингом in mind, то линтеры уже установлены локально. Также могут быть установлены дополнительные плагины линтеров и кастомные парсеры. При этом имеются проверенные конфиги, заточенные под конкретный проект. В таком случае сразу после установки плагинов редактора линтеры и конфиги найдутся автоматически, и всё заработает.</span></p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><a name="27fa"></a><span style=" font-family:'Ubuntu';">Е</span><span style=" font-family:'Ubuntu';">сли линтера на проекте нет, то есть возможность активировать его у себя на уровне редактора. Для этого нужно поставить линтеры глобально, а конфиги можно, как вариант, определить прямо в редакторе на уровне Workspace Settings. Но я всё же не вижу в этом смысла. Весь проект начнёт гореть красным, в Problems 2K+ ошибок, и никто кроме вас этого не видит. Зачем? Так что линтеры на уровне редактора, ещё раз повторюсь, предпочтительно использовать как второй уровень над линтерами, встроенными в проект — апгрейд интерфейса, если угодно.</span></p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><a name="eb56"></a><span style=" font-family:'Ubuntu';">Е</span><span style=" font-family:'Ubuntu';">сли вы подключаете линтеры для валидации кода, то встроенную проверку нужно отключать, чтобы они не перекрывали друг друга, и не возникало конфликтов:</span></p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><a name="0c6a"></a><span style=" font-family:'Courier New,courier';">“</span><span style=" font-family:'Courier New,courier';">javascript.validate.enable”: false,<br />“typescript.validate.enable”: false,<br />“css.validate”: false,<br />“less.validate”: false,<br />“scss.validate”: false,</span></p>
<p style=" margin-top:16px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><a name="c01c"></a><span style=" font-family:'Ubuntu'; font-size:x-large; font-weight:600;">Ф</span><span style=" font-family:'Ubuntu'; font-size:x-large; font-weight:600;">орматирование</span></p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><a name="bf98"></a><span style=" font-family:'Ubuntu';">Т</span><span style=" font-family:'Ubuntu';">акже в VSCode имеется возможность настроить форматирование. Я не использую Prettier, т.к. он слишком субъективен и не допускает гибкой настройки, а у меня имеется собственный взгляд на подобные вещи. autofix линтеров уже ближе, т.к. код видоизменяется строго в соответствии с вашими правилами, но, считаю, что он также должен быть на уровне проекта, а не редактора. Хотя для плагина ESLint имеется настройка, позволяющая его активировать, если угодно.</span></p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><a name="e7b2"></a><span style=" font-family:'Ubuntu';">К</span><span style=" font-family:'Ubuntu';">роме того VSCode имеет встроенную функцию форматирования. Его можно применять, когда скопировали страшный фрагмент кода со StackOverflow или CodePen и хотите понять, что там вообще происходит (не копируйте ничего так бездумно btw ☝️). Для этого можно выделить фрагмент и вызвать команду </span><span style=" font-family:'Ubuntu'; font-weight:600;">Format Selection</span><span style=" font-family:'Ubuntu';"> или использовать шорткат:</span></p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:40px; margin-right:40px; -qt-block-indent:0; text-indent:0px;"><a name="d414"></a><span style=" font-family:'Ubuntu'; font-weight:600;">C</span><span style=" font-family:'Ubuntu'; font-weight:600;">trl + K Ctrl + F </span><span style=" font-family:'Ubuntu';">— форматирование выделенного фрагмента.</span></p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><a name="cb7f"></a><span style=" font-family:'Ubuntu';">Д</span><span style=" font-family:'Ubuntu';">ругой рядовой случай: нам попался минифицированный файл. Мы можем отформатировать его, чтобы в общих чертах что-то в нём понять. От общей обфускации форматирование нас не избавит, но хотя бы что-то. Для этого используем </span><span style=" font-family:'Ubuntu'; font-weight:600;">Format Document</span><span style=" font-family:'Ubuntu';"> или шорткат:</span></p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:40px; margin-right:40px; -qt-block-indent:0; text-indent:0px;"><a name="9956"></a><span style=" font-family:'Ubuntu'; font-weight:600;">S</span><span style=" font-family:'Ubuntu'; font-weight:600;">hift + Alt + F</span><span style=" font-family:'Ubuntu';"> — форматирование всего документа.</span></p>
<p style=" margin-top:18px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><a name="c36a"></a><span style=" font-family:'Ubuntu'; font-size:xx-large; font-weight:600;">L</span><span style=" font-family:'Ubuntu'; font-size:xx-large; font-weight:600;">ive Share</span></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><img src="image1098472906.png" /><img src="image928691358.png" /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Ubuntu';">Процесс кооперативного написания кода с применением технологии Visual Studio Live Share.</span></p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><a name="bd8f"></a><span style=" font-family:'Ubuntu';">V</span><span style=" font-family:'Ubuntu';">isual Studio Live Share — это разработка Microsoft, позволяющая расшаривать свой редактор для других людей. Это может быть полезно для популярной нынче методики парного программирования, совместного поиска решения проблемы, код ревью в реальном времени, презентаций.</span></p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><a name="53a0"></a><span style=" font-family:'Ubuntu';">Ч</span><span style=" font-family:'Ubuntu';">тобы воспользоваться этими космическими технологиями в VSCode нужно установить себе расширение:</span></p>
<p style=" margin-top:16px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><a name="00a5"></a><a href="https://marketplace.visualstudio.com/items?itemName=MS-vsliveshare.vsliveshare"><span style=" font-family:'Ubuntu'; font-size:x-large; font-weight:600; text-decoration: underline; color:#0000ff;">V</span></a><span style=" font-family:'Ubuntu'; font-size:x-large; font-weight:600; text-decoration: underline; color:#0000ff;">S Live Share</span></p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><a name="28f6"></a><span style=" font-family:'Ubuntu';">К</span><span style=" font-family:'Ubuntu';">роме расширения всё, что вам нужно — это всем участникам сессии иметь VSCode или Visual Studio и аккаунт на GitHub для авторизации в первый раз.</span></p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><a name="9f45"></a><span style=" font-family:'Ubuntu';">Д</span><span style=" font-family:'Ubuntu';">ля управления Live Share расширение предоставляет отдельную вкладку на панели управления, а также кнопки в нижнем баре. Здесь можно начать новую сессию в доступном на запись или readonly режиме или присоединиться к чужой сессии.</span></p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><a name="994f"></a><span style=" font-family:'Ubuntu';">И</span><span style=" font-family:'Ubuntu';">нформацию в нижнем баре советую отображать только при активации сессии. При выключенном шаринге она только забивает интерфейс, дублируя функционал, и так доступный из панели управления. После коннекта же эта информация имеет место быть ввиду своей наглядности, к тому же она визуально идентифицирует тот факт, что сессия запущена:</span></p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><a name="c95a"></a><span style=" font-family:'Courier New,courier';">“</span><span style=" font-family:'Courier New,courier';">liveshare.showInStatusBar”: “whileCollaborating”,</span></p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><a name="eea5"></a><span style=" font-family:'Ubuntu';">Ч</span><span style=" font-family:'Ubuntu';">тобы протестировать работу Live Share, достаточно расшарить проект самому себе. Для этого начинаем новую сессию, входим через GitHub аккаунт, получаем ссылку на сессию и переходим по ссылке в браузере. Для шаринга с другими участниками делается то же самое — просто кидаете им ссылку, и они присоединяются, либо через браузер, либо через кнопку </span><span style=" font-family:'Ubuntu'; font-weight:600;">Join collaboration session</span><span style=" font-family:'Ubuntu';"> внутри вкладки Live Share. При заходе через браузер редактор откроется автоматически.</span></p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><a name="9c81"></a><span style=" font-family:'Ubuntu';">П</span><span style=" font-family:'Ubuntu';">осле присоединения второй участник сможет ходить по вашему проекту и, если сессия не в readonly режиме, изменять код. Позиция участников отмечается маркером и переход к этой позиции всегда можно осуществить кликом по имени участника на вкладке Live Share. Также доступен режим следования за другим участником — для включения/отключения его предназначена кнопка пина в верхнем правом углу.</span></p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><a name="6845"></a><span style=" font-family:'Ubuntu';">К</span><span style=" font-family:'Ubuntu';">роме шаринга кода можно расшаривать терминал и сервер. Первое происходит автоматически в readonly режиме, но имеется возможность выдать права на редактирование. Второе полезно для демонстрации результата со своего localhost другому участнику — для этого просто жмём </span><span style=" font-family:'Ubuntu'; font-weight:600;">Share server</span><span style=" font-family:'Ubuntu';">, вводим порт и имя для отображения в списке. После этого ссылка на сервер появляется у участников и после перехода по ней у них на некотором порту (не том же, который расшаривается) появится ваш результат.</span></p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><a name="4323"></a><span style=" font-family:'Ubuntu';">В</span><span style=" font-family:'Ubuntu';">се эти возможности можно по-разному применять в различных ситуациях. Для парного программирования открываете сессию с правами на изменение, связываетесь по голосовой связи и творите в коопе. На презентациях можно для всех желающих, пришедших с ноутбуками, запускать readonly сессию, включать режим следования, и участники смогут видеть демонстрируемый код прямо на экране своего монитора в любимом редакторе вместо того, чтобы вглядываться в неважную картинку проектора на другом конце зала. Шаринг сервера можно использовать для демонстрации незадеплоенных результатов работы, как альтернативу передаче ссылки на сервер в рамках общей сети.</span></p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><a name="6381"></a><span style=" font-family:'Ubuntu';">Е</span><span style=" font-family:'Ubuntu';">динственное, чего мне здесь не хватает — это внутреннего средства коммуникации. Microsoft не предоставляет встроенного решения для чата, и установить его можно только сторонними пакетами. Проблема в том, что я пробовал 2 варианта,и оба у меня не заработали. Так что будем ждать 😕</span></p>
<p style=" margin-top:18px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><a name="467e"></a><span style=" font-family:'Ubuntu'; font-size:xx-large; font-weight:600;">В</span><span style=" font-family:'Ubuntu'; font-size:xx-large; font-weight:600;">нешние зависимости</span></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><img src="image582941845.png" /><img src="image928691358.png" /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Ubuntu';">Отслеживание актуальности зависимостей через встроенные в package.json линзы расширением Version Lens</span></p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><a name="88ce"></a><span style=" font-family:'Ubuntu';">V</span><span style=" font-family:'Ubuntu';">SCode упрощает вашу работу с внешними зависимостями, предоставляя функционал Intellisense внутри </span><span style=" font-family:'Ubuntu'; font-weight:600;">package.json</span><span style=" font-family:'Ubuntu';">. Если вы решите добавить вручную новую зависимость, то сначала вам редактор предложит список зависимостей, а затем после выбора последнюю версию с различными флагами. Однако обычно эта возможность не нужна, т.к. зависимости ставятся через пакетный менеджер (yarn/npm), а package.json обновляется автоматически (при наличии флагов на сохранение, если нужны).</span></p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><a name="1959"></a><span style=" font-family:'Ubuntu';">Н</span><span style=" font-family:'Ubuntu';">о вот какая возможность объективно незаменима — это вывод информации по наведению на зависимость. По ховеру появляется окно с общим описанием, последней версией и ссылкой на репозиторий. Описание даёт общее представление о пакете, а по ссылке можно одним кликом перепрыгнуть к развернутому описанию и документации. Для контроля версий же есть более удобный интерфейс, который мы рассмотрим далее.</span></p>
<p style=" margin-top:16px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><a name="19fc"></a><a href="https://marketplace.visualstudio.com/items?itemName=pflannery.vscode-versionlens"><span style=" font-family:'Ubuntu'; font-size:x-large; font-weight:600; text-decoration: underline; color:#0000ff;">V</span></a><span style=" font-family:'Ubuntu'; font-size:x-large; font-weight:600; text-decoration: underline; color:#0000ff;">ersion Lens</span></p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><a name="06b7"></a><span style=" font-family:'Ubuntu';">Р</span><span style=" font-family:'Ubuntu';">асширение, которое позволяет держать ваши внешние зависимости актуальными. Активируется нажатием по кнопке </span><span style=" font-family:'Ubuntu'; font-weight:600;">Show Dependency Versions</span><span style=" font-family:'Ubuntu';"> на верхней правой панели. После активации в ваш package.json встраиваются линзы, показывающие наличие версии зависимости новее вашей. Если она имеется, то можно нажать на новую версию, и она заменит вашу текущую. После этого запускаете </span><span style=" font-family:'Ubuntu'; font-weight:600;">yarn install</span><span style=" font-family:'Ubuntu';"> (ну или npm) и обновляете зависимости.</span></p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><a name="1165"></a><span style=" font-family:'Ubuntu';">И</span><span style=" font-family:'Ubuntu';">значально отображается минифицированная версия линз. На той же панели имеется возможность дополнительно активировать вывод теггированных версий — например, alpha и beta релизов. А также вывести более броские цветные версии статусов зависимостей.</span></p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><a name="e4a8"></a><span style=" font-family:'Ubuntu';">П</span><span style=" font-family:'Ubuntu';">о умолчанию линзы активируются при запуске редактора. Я предпочёл отключить эту автоматическую активацию, т.к. они могут включаться только тогда, когда они нужны, через интерфейс по запросу:</span></p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><a name="bb85"></a><span style=" font-family:'Courier New,courier';">“</span><span style=" font-family:'Courier New,courier';">versionlens.showVersionLensesAtStartup”: false,</span></p>
<p style=" margin-top:18px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><a name="3f7f"></a><span style=" font-family:'Ubuntu'; font-size:xx-large; font-weight:600;">В</span><span style=" font-family:'Ubuntu'; font-size:xx-large; font-weight:600;">изуальный стиль</span></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><img src="image1824861951.png" /><img src="image928691358.png" /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Ubuntu';">Внешний вид проводника с подключённой иконочной темой vscode-icons</span></p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><a name="ada7"></a><span style=" font-family:'Ubuntu';">П</span><span style=" font-family:'Ubuntu';">о визуальной стилизации VSCode я выделю 3 основных способа персонализации: цветовая тема, иконочная тема и выбор шрифта.</span></p>
<p style=" margin-top:16px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><a name="e531"></a><span style=" font-family:'Ubuntu'; font-size:x-large; font-weight:600;">Ц</span><span style=" font-family:'Ubuntu'; font-size:x-large; font-weight:600;">ветовая тема</span></p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><a name="28a5"></a><span style=" font-family:'Ubuntu';">В</span><span style=" font-family:'Ubuntu';">ыбор тем для VSCode воистину огромен и каждый подберёт для себя что-то своё. В редакторе изначально есть набор предустановленных тем, из которых можно выбрать понравившуюся, но кроме того маркетплейс заполнен темами на любой вкус.</span></p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><a name="4a65"></a><span style=" font-family:'Ubuntu';">Б</span><span style=" font-family:'Ubuntu';">ыстрый просмотр тем можно осуществить через командную строку: </span><span style=" font-family:'Ubuntu'; font-weight:600;">Preferences: Color Theme</span><span style=" font-family:'Ubuntu';"> или через кнопку настроек в нижнем левом углу. Вызов этой команды открывает список установленных тем, по которым можно пройтись через стрелки клавиатуры, сразу увидев их превью.</span></p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><a name="f699"></a><span style=" font-family:'Ubuntu';">Л</span><span style=" font-family:'Ubuntu';">ично я, потратив некоторое время на поиски, остался на стандартной теме </span><span style=" font-family:'Ubuntu'; font-weight:600;">Dark+</span><span style=" font-family:'Ubuntu';">. По мне так, идеальная тёмная тема, приятная глазу.</span></p>
<p style=" margin-top:16px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><a name="92f6"></a><span style=" font-family:'Ubuntu'; font-size:x-large; font-weight:600;">И</span><span style=" font-family:'Ubuntu'; font-size:x-large; font-weight:600;">коночная тема</span></p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><a name="efc8"></a><span style=" font-family:'Ubuntu';">И</span><span style=" font-family:'Ubuntu';">коночная тема меняет представление иконок файлов различных расширений, отображаемых в проводнике на панели управления и непосредственно на вкладках редактора.</span></p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><a name="f1df"></a><span style=" font-family:'Ubuntu';">И</span><span style=" font-family:'Ubuntu';">з коробки доступны 2 темы, из которых можно выбрать. Но здесь я советую поставить тему с маркетплейса vscode-icons.</span></p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><a name="c02a"></a><a href="https://marketplace.visualstudio.com/items?itemName=robertohuertasm.vscode-icons"><span style=" font-family:'Ubuntu'; font-weight:600; text-decoration: underline; color:#0000ff;">v</span></a><span style=" font-family:'Ubuntu'; font-weight:600; text-decoration: underline; color:#0000ff;">scode-icons</span></p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><a name="25dc"></a><span style=" font-family:'Ubuntu';">Э</span><span style=" font-family:'Ubuntu';">то одна из самых популярных загрузок среди всех товаров торговой площадки в принципе (на данный момент ~10M скачиваний), и такая популярность оправдана. Порой кажется, что у этой темы есть своя иконка просто для всего, настолько их там много.</span></p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><a name="a9d7"></a><span style=" font-family:'Ubuntu';">Т</span><span style=" font-family:'Ubuntu';">акже эту тему от дефолтных выгодно выделяет наличие иконок для директорий. Т.е. определены иконки для ряда типовых наименований директорий. Например, у меня на верхнем уровне это src, dist, public, config, node_modules. Внутри src идут scripts, styles, templates, images, fonts, ну и так далее. Кроме того у всех этих иконок есть вариации для открытой и закрытой папки, что ещё придаёт наглядности.</span></p>
<p style=" margin-top:16px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><a name="1fee"></a><span style=" font-family:'Ubuntu'; font-size:x-large; font-weight:600;">В</span><span style=" font-family:'Ubuntu'; font-size:x-large; font-weight:600;">ыбор шрифта</span></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><img src="image512082944.png" /><img src="image1282310508.png" /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Ubuntu';">Демонстрация лигатур шрифта Fira Code</span></p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><a name="5c53"></a><span style=" font-family:'Ubuntu';">V</span><span style=" font-family:'Ubuntu';">SCode поддерживает шрифты с лигатурами, так что если хотите быть самыми модными, то советую загрузить себе шрифт </span><a href="https://github.com/tonsky/FiraCode"><span style=" font-family:'Ubuntu'; font-weight:600; text-decoration: underline; color:#0000ff;">Fira Code</span></a><span style=" font-family:'Ubuntu';">. Это очень популярный шрифт, который рекомендуют именно в связке с VSCode. Скачиваете себе шрифт из репозитория, устанавливаете на компьютер и прописываете в настройках редактора имя шрифта и поддержку лигатур:</span></p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><a name="96ac"></a><span style=" font-family:'Courier New,courier';">“</span><span style=" font-family:'Courier New,courier';">editor.fontFamily”: “Fira Code”,<br />“editor.fontLigatures”: true,</span></p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><a name="35a4"></a><span style=" font-family:'Ubuntu';">Л</span><span style=" font-family:'Ubuntu';">игатуры — это объединение нескольких последовательно идущих символов в единую конструкцию, которые напрямую не ввести с клавиатуры, но которые выглядят более человекопонятно. Наглядный пример — это знак неравенства, который в js записывается, как !=. Fira Code преобразует его в аккуратный символ перечёркнутого равенства. На приложенном скриншоте можно видеть список всех подобных преобразований.</span></p>
<p style=" margin-top:18px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><a name="3b1e"></a><span style=" font-family:'Ubuntu'; font-size:xx-large; font-weight:600;">А</span><span style=" font-family:'Ubuntu'; font-size:xx-large; font-weight:600;">ссоциация типов файлов</span></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><img src="image1372343820.png" /><img src="image624751451.png" /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Ubuntu';">Меню настройки типа файла</span></p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><a name="31b7"></a><span style=" font-family:'Ubuntu';">Т</span><span style=" font-family:'Ubuntu';">ип файлов определяется автоматически, но бывают случаи с экзотическими расширениями или поведением, когда нужно указать ассоциации напрямую. Если тип не удаётся определить, то файл будет расценен, как обычный текст, т.е. будет отсутствовать любого рода подсветка синтаксиса. Если тип определён неверно, то подсветка будет, но неточная, и консоль заполнится предупреждениями о некорректном синтаксисе.</span></p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><a name="4317"></a><span style=" font-family:'Ubuntu';">Т</span><span style=" font-family:'Ubuntu';">екущий тип файла указывается справа в статус баре. Нажатие по нему открывает меню с управлением ассоциациями. Здесь можно указать напрямую с каким типом файлов ассоциировать текущее расширение.</span></p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><a name="d080"></a><span style=" font-family:'Ubuntu';">В</span><span style=" font-family:'Ubuntu';"> целом, я выделю 2 случая, когда это нужно. Первое — это </span><span style=" font-family:'Ubuntu'; font-weight:600;">JSON</span><span style=" font-family:'Ubuntu';">-конфиги со специфическим расширением, и второе — это </span><span style=" font-family:'Ubuntu'; font-weight:600;">PostCSS</span><span style=" font-family:'Ubuntu';">.</span></p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><a name="43dd"></a><span style=" font-family:'Ubuntu';">В</span><span style=" font-family:'Ubuntu';"> первом случае, ряд инструментов имеет рекомендации по описанию конфигов в файлах специфических расширений. В моём случае это конфиги PostCSS и StyleLint — для них vscode-icons корректно определяет иконку, но контент определяется, как Plain Text.</span></p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><a name="0555"></a><span style=" font-family:'Ubuntu';">В</span><span style=" font-family:'Ubuntu';">о втором случае, я использую PostCSS для файлов с расширением .css, т.к. PostCSS — это постпроцессор, который обрабатывает обычные css-файлы. Однако встроенная поддержка PostCSS в VSCode отсутствует. Чтобы её добавить, нужно поставить плагин с поддержкой синтаксиса.</span></p>
<p style=" margin-top:16px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><a name="c073"></a><a href="https://marketplace.visualstudio.com/items?itemName=mhmadhamster.postcss-language"><span style=" font-family:'Ubuntu'; font-size:x-large; font-weight:600; text-decoration: underline; color:#0000ff;">p</span></a><span style=" font-family:'Ubuntu'; font-size:x-large; font-weight:600; text-decoration: underline; color:#0000ff;">ostcss-sugarss-language</span></p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><a name="f367"></a><span style=" font-family:'Ubuntu';">Р</span><span style=" font-family:'Ubuntu';">асширение, которое добавляет поддержку PostCSS-синтаксиса. Т.к. я работаю с PostCSS, то мне нужно, чтобы редактор не расценивал за синтаксические ошибки, например, вложенные селекторы в *.css файлах. Проблема поддержки PostCSS, из-за которой она не встроена по умолчанию — это его непостоянство в плане единого стиля. Т.е. мы работаем с обычным CSS и плагинами расширяем его под себя. Можно ставить ассоциацию *.css файлов (или *.pcss, если угодно) с SCSS, и синтаксис будет воспринят примерно корректно, но не совсем. Например, комментарии на Ctrl + / будут не того формата (строчные вместо блочных). Существует целый ряд малопопулярных плагинов, которые нацелены решить эту проблему — этот из них реально работает.</span></p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><a name="dcd8"></a><span style=" font-family:'Ubuntu';">Т</span><span style=" font-family:'Ubuntu';">.о. настройки выглядят следующим образом:</span></p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><a name="ffec"></a><span style=" font-family:'Courier New,courier';">“</span><span style=" font-family:'Courier New,courier';">files.associations”: {<br />    “*.css”: “postcss”,<br />    “.postcssrc”: “json”,<br />    “.stylelintrc”: “json”<br />},</span></p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><a name="920b"></a><span style=" font-family:'Ubuntu';">В</span><span style=" font-family:'Ubuntu';"> разделе по линтингу я писал, что нужно отключать встроенную валидацию. Этот плагин добавляет новый тип postcss, так что для него также нужно прописать false:</span></p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><a name="59b4"></a><span style=" font-family:'Courier New,courier';">“</span><span style=" font-family:'Courier New,courier';">postcss.validate”: false,</span></p>
<p style=" margin-top:18px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><a name="f95a"></a><span style=" font-family:'Ubuntu'; font-size:xx-large; font-weight:600;">П</span><span style=" font-family:'Ubuntu'; font-size:xx-large; font-weight:600;">рочие расширения</span></p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><a name="a064"></a><span style=" font-family:'Ubuntu';">Н</span><span style=" font-family:'Ubuntu';">у и наконец, опишу ряд расширений, которые не попали в предыдущие разделы, но которые также помогают мне в работе.</span></p>
<p style=" margin-top:16px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><a name="db80"></a><a href="https://marketplace.visualstudio.com/items?itemName=kamikillerto.vscode-colorize"><span style=" font-family:'Ubuntu'; font-size:x-large; font-weight:600; text-decoration: underline; color:#0000ff;">C</span></a><span style=" font-family:'Ubuntu'; font-size:x-large; font-weight:600; text-decoration: underline; color:#0000ff;">olorize</span></p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><a name="cc59"></a><span style=" font-family:'Ubuntu';">Э</span><span style=" font-family:'Ubuntu';">тот плагин меняет выделение цветов с представления с боксом превью на представление с задним фоном этого цвета. Но это не его основная суть, главная киллер фича здесь в том, что он поддерживает переменные, при этом сам находит их в рамках проекта и добавляет корректное цветовыделение в местах их использования. Это просто космические технологии, т.к. я пытался добиться этого во всех редакторах до этого (Sublime Text, Brackets, Atom) и ни одно расширение мне не позволило этого сделать. Теперь же, к примеру, у нас есть файл customMedia.css или variables.pcss, в котором определяются все переменные таблиц стилей, среди них определяются и переменные цветов. В этом файле мы наглядно видим палитру проекта, но и, перейдя в любой другой файл со стилями, где эти переменные используются, мы видим какой цвет стоит за этой переменной — это добавляет </span><span style=" font-family:'Ubuntu'; font-weight:600;">+100 баллов к наглядности</span><span style=" font-family:'Ubuntu';"> и выигрывает нам время засчёт избавления от необходимости каждый раз лезть в файл с переменными и смотреть на какой цвет она ссылается. Теперь этот процесс требуется только при выборе из 50 оттенков серого, когда нужно посмотреть код цвета. К сожалению, превью значения при наведении не показывается, но это уже так-то и некасающийся цветов функционал.</span></p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><a name="297b"></a><span style=" font-family:'Ubuntu';">Д</span><span style=" font-family:'Ubuntu';">ля CSS-переменных вроде </span><span style=" font-family:'Ubuntu'; font-weight:600;">var( — cl-black)</span><span style=" font-family:'Ubuntu';"> такая возможность работает из коробки, а для SCSS-подобного синтаксиса </span><span style=" font-family:'Ubuntu'; font-weight:600;">$cl-black</span><span style=" font-family:'Ubuntu';"> и всех остальных нужно дописать их тип в массив поддерживаемых форматов переменных:</span></p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><a name="ec3c"></a><span style=" font-family:'Courier New,courier';">“</span><span style=" font-family:'Courier New,courier';">colorize.colorized_variables”: [<br />    “CSS”,<br />    “SASS”<br />],</span></p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><a name="fd9b"></a><span style=" font-family:'Ubuntu';">Т</span><span style=" font-family:'Ubuntu';">акже по настройкам я убрал скрытие цвета текущей строки. Мне такое поведение кажется избыточным и только отвлекает:</span></p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><a name="4033"></a><span style=" font-family:'Courier New,courier';">“</span><span style=" font-family:'Courier New,courier';">colorize.hide_current_line_decorations”: false,</span></p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><a name="1e43"></a><span style=" font-family:'Ubuntu';">И</span><span style=" font-family:'Ubuntu';"> остаётся проблема, что мы перешли на новый формат выделения цвета, но стандартный при этом остался, так что надо его отключить:</span></p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><a name="a595"></a><span style=" font-family:'Courier New,courier';">“</span><span style=" font-family:'Courier New,courier';">editor.colorDecorators”: false,</span></p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><a name="6506"></a><span style=" font-family:'Ubuntu';">К</span><span style=" font-family:'Ubuntu';"> сожалению, эта настройка не убирает боксы превью из файлов, ассоциированных с PostCSS, а только CSS, SASS и LESS. Так что в моём случае она не помогает, но я держу её включённой, надеясь, что когда-нибудь она заработает 😩</span></p>
<p style=" margin-top:16px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><a name="2054"></a><a href="https://marketplace.visualstudio.com/items?itemName=formulahendry.code-runner"><span style=" font-family:'Ubuntu'; font-size:x-large; font-weight:600; text-decoration: underline; color:#0000ff;">C</span></a><span style=" font-family:'Ubuntu'; font-size:x-large; font-weight:600; text-decoration: underline; color:#0000ff;">ode Runner</span></p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><a name="5a67"></a><span style=" font-family:'Ubuntu';">П</span><span style=" font-family:'Ubuntu';">орой бывает нужно протестировать работоспособность отдельного фрагмента кода — точно ли он делает то, что нужно. Для этого приходится комментировать весь ненужный код, оставляя только этот фрагмент, что довольно-таки геморно. Или другой случай — хочется показать коллегам какую-нибудь киллер фичу из лучшего языка на свете. Работая во фронтенд-среде, чтобы это сделать, пришлось бы как минимум создать index.html с тегом script. Другой вариант — воспользоваться внешним ресурсом для написания кода вроде Codepen или воспользоваться консолью в инструментах разработчика. Это проще первого варианта, но такой подход заставляет покинуть комфортный с любовью настроенный редактор, что, во-первых, долго, и, во-вторых, неудобно. Особенно неудобно для многострочных конструкций в консоли. Написал const — не получил в итоге желаемого результата, написал ещё раз — словил ошибку из-за переопределения.</span></p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><a name="ab3b"></a><span style=" font-family:'Ubuntu';">Н</span><span style=" font-family:'Ubuntu';">у и собственно Code Runner решает такую проблему, помогая запускать отдельные фрагменты кода, и предоставляя результаты исполнения (ваши console.log) во вкладке Output нижней панели. Чтобы выполнить отдельный фрагмент, просто выделите его мышью и нажмите </span><span style=" font-family:'Ubuntu'; font-weight:600;">Ctrl + Alt + N</span><span style=" font-family:'Ubuntu';">. То же самое можно сделать через контекстное меню на ПКМ или кнопку </span><span style=" font-family:'Ubuntu'; font-weight:600;">Run Code</span><span style=" font-family:'Ubuntu';"> в верхней правой части редактора.</span></p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><a name="06a3"></a><span style=" font-family:'Ubuntu';">Ч</span><span style=" font-family:'Ubuntu';">тобы была возможность запустить фрагмент кода не только из файлов с этим расширением, нужно прописать дефолтный язык. В моём случае это javascript:</span></p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><a name="d22d"></a><span style=" font-family:'Courier New,courier';">“</span><span style=" font-family:'Courier New,courier';">code-runner.defaultLanguage”: “javascript”,</span></p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><a name="2f5b"></a><span style=" font-family:'Ubuntu';">Т</span><span style=" font-family:'Ubuntu';">еперь я могу писать .md или .txt файл, захотеть протестить какую-то фичу и написать её прямо в теле документа. Иначе пришлось бы создавать .js файл и тогда уж проще зайти в браузер и воспользоваться консолью из инструментов разработчика, хоть это и не так удобно.</span></p>
<p style=" margin-top:16px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><a name="55e1"></a><a href="https://marketplace.visualstudio.com/items?itemName=chrmarti.regex"><span style=" font-family:'Ubuntu'; font-size:x-large; font-weight:600; text-decoration: underline; color:#0000ff;">R</span></a><span style=" font-family:'Ubuntu'; font-size:x-large; font-weight:600; text-decoration: underline; color:#0000ff;">egex Previewer</span></p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><a name="b5d9"></a><span style=" font-family:'Ubuntu';">Р</span><span style=" font-family:'Ubuntu';">асширение позволяет быстро тестировать регулярные выражения, предоставляя файл с тестовым текстом справа. При открытом превью можно навестись на любой регексп, и справа подсветятся все совпадения. Это очень удобно, в особенности если у вас есть глобальный файл с регулярными выражениями, определяемыми на уровне проекта. Без расширения приходилось бы для тестирования покидать редактор и переходить на внешние сервисы вроде </span><a href="http://regexr.com"><span style=" font-family:'Ubuntu'; font-weight:600; text-decoration: underline; color:#0000ff;">regexr.com</span></a><span style=" font-family:'Ubuntu';">. В целом, это всё равно более функциональный сервис, который предоставляет более широкий спектр возможностей, но конкретно для тестирования вы сможете обходиться возможностями встроенными прямо в редактор, что однозначно быстрее за счёт отсутствия необходимости переключения контекста. Можно в нижней панели включать флаги </span><span style=" font-family:'Ubuntu'; font-weight:600;">gm</span><span style=" font-family:'Ubuntu';">, чтобы совпадения выводились для регулярных выражений без этих флагов (выводились все совпадения в многострочном тексте). </span><span style=" font-family:'Ubuntu'; font-weight:600;">Code Lens</span><span style=" font-family:'Ubuntu';"> советую отключать и выводить превью через палитру команд, т.к. работает автоопределение нестабильно и может выводить </span><span style=" font-family:'Ubuntu'; font-weight:600;">“Test regex”</span><span style=" font-family:'Ubuntu';"> в строчках со слешами, где это не нужно. Например, в комментарии, внутри которого есть слеш.</span></p>
<p style=" margin-top:16px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><a name="dc02"></a><a href="https://marketplace.visualstudio.com/items?itemName=cssho.vscode-svgviewer"><span style=" font-family:'Ubuntu'; font-size:x-large; font-weight:600; text-decoration: underline; color:#0000ff;">S</span></a><span style=" font-family:'Ubuntu'; font-size:x-large; font-weight:600; text-decoration: underline; color:#0000ff;">VG Viewer</span></p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><a name="1760"></a><span style=" font-family:'Ubuntu';">Р</span><span style=" font-family:'Ubuntu';">асширение предоставляет возможность просматривать превью svg-файла прямо в редакторе. Иначе приходилось бы переходить в проводник и открывать файл, например, через браузер. Имеется возможность включить auto preview, после чего при открытии svg справа будет открываться превью. Однако я этого делать не советую, т.к. просматривая файлы один за другим, у вас скопится куча открытых превью, т.к. они не заменяются автоматически, как остальные файлы при просмотре без редактирования. Да и в целом на практике это не так удобно, как звучит.</span></p>
<p style=" margin-top:16px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><a name="a910"></a><a href="https://marketplace.visualstudio.com/items?itemName=formulahendry.auto-rename-tag"><span style=" font-family:'Ubuntu'; font-size:x-large; font-weight:600; text-decoration: underline; color:#0000ff;">A</span></a><span style=" font-family:'Ubuntu'; font-size:x-large; font-weight:600; text-decoration: underline; color:#0000ff;">uto Rename Tag</span></p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><a name="0399"></a><span style=" font-family:'Ubuntu';">К</span><span style=" font-family:'Ubuntu';">рохотный плагин, который предоставляет возможность, которая обычно встроена в редактор, но в VSCode по какой-то причине отсутствует — при редактировании открывающего тега параллельно редактируется и закрывающий и наоборот. Может со временем эта возможность станет встроенной, и необходимость в плагине отпадёт, благо в репозитории VSCode на данный момент числится открытый issue на эту тему.</span></p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><a name="f145"></a><span style=" font-family:'Ubuntu';">?</span><span style=" font-family:'Ubuntu';">? 🔥 🔥 Фух… На этом, пожалуй, у меня всё. В рамках этой статьи я описал все функции, которые использую на данный момент. Понятно, что большая часть сказанного здесь крайне субъективна, но она нарочито сделана такой персонифицированной. Полученную информацию можно пропустить через себя, профильтровать и пересмотреть свои подходы к использованию редактора. Надеюсь, что вы узнали для себя что-то новое и примените полученные знания на практике.</span></p>
<p style=" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><a name="0996"></a><span style=" font-family:'Ubuntu';">Е</span><span style=" font-family:'Ubuntu';">сли вам есть, что сказать, то оставляйте комментарии. Любой фидбек — это приятно 😌</span></p>
<p style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; font-family:'Ubuntu';"><br /></p></body></html>