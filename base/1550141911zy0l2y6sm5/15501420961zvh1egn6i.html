<html xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:fb="http://www.gribuser.ru/xml/fictionbook/2.0">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=windows-1251">
<title>HTML, XHTML и CSS на 100%</title>
<style type="text/css" media="screen">
		A { color : #0002CC }
		A:HOVER { color : #BF0000 }
		BODY {font-family : Verdana, Geneva, Arial, Helvetica, sans-serif; text-align : justify }
		H1{ font-size : 160%; font-style : normal; font-weight : bold; text-align : left; text-transform : capitalize;  border : 1px solid Black;  background-color : #E7E7E7; text-transform : capitalize;  margin-left : 0px;  padding-left : 0.5em;  }
		H2{ font-size : 130%; font-style : normal; font-weight : bold; text-align : left; text-transform : capitalize;  background-color : #EEEEEE;  border : 1px solid Gray; text-transform : capitalize;  padding-left : 1em; }
		H3{ font-size : 110%; font-style : normal; font-weight : bold; text-align : left;  background-color : #F1F1F1;  border : 1px solid Silver; text-transform : capitalize;  padding-left : 1.5em;}
		H4{ font-size : 100%; font-style : normal; font-weight : bold; text-align : left;  padding-left : 0.5em; text-transform : capitalize;  border : 1px solid Gray;  background-color : #F4F4F4;  padding-left : 2em;}
		H5{ font-size : 100%; font-style : italic; font-weight : bold; text-align : left; text-transform : capitalize;border : 1px solid Gray;  background-color : #F4F4F4;  padding-left : 2.5em;}
		H6{ font-size : 100%; font-style : italic; font-weight : normal; text-align : left; text-transform : capitalize;border : 1px solid Gray;  background-color : #F4F4F4;  padding-left : 2.5em;}
		SMALL{ font-size : 80% }
		BLOCKQUOTE{ margin : 0 1em 0.2em 4em }
		HR{ color : Black }
		UL{ padding-left : 1em; margin-left: 0}
		.epigraph{margin-right:5em; margin-left : 25%;}
		DIV{font-family : Verdana, Geneva, Arial, Helvetica, sans-serif; text-align : justify}
	</style>
<style type="text/css" media="print">
		A { color : #0002CC }
		A:HOVER { color : #BF0000 }
		BODY {font-family : "Times New Roman", Times, serif; text-align : justify }
		H1{ font-family : Verdana, Geneva, Arial, Helvetica, sans-serif; font-size : 160%; font-style : normal; font-weight : bold; text-align : left; text-transform : capitalize }
		H2{ font-family : Verdana, Geneva, Arial, Helvetica, sans-serif; font-size : 130%; font-style : normal; font-weight : bold; text-align : left; text-transform : capitalize }
		H3{ font-family : Verdana, Geneva, Arial, Helvetica, sans-serif; font-size : 110%; font-style : normal; font-weight : bold; text-align : left }
		H4{ font-family : Verdana, Geneva, Arial, Helvetica, sans-serif; font-size : 100%; font-style : normal; font-weight : bold; text-align : left }
		H5,H6{ font-family : Verdana, Geneva, Arial, Helvetica, sans-serif; font-size : 100%; font-style : italic; font-weight : normal; text-align : left; text-transform : uppercase }
		SMALL{ font-size : 80% }
		BLOCKQUOTE{ margin : 0 1em 0.2em 4em }
		HR{ color : Black }
		DIV{font-family : "Times New Roman", Times, serif; text-align : justify}
	</style>
</head>
<body>
<div xmlns="http://www.w3.org/1999/xhtml" style="text-align: center;"><img src="cover.jpg" alt=""></img></div><h1>HTML, XHTML и CSS на 100%</h1>
<h2><small><b>Игорь  Квинт<br xmlns="http://www.w3.org/1999/xhtml"></br></b></small></h2>
<hr>
<blockquote><ul>
<li xmlns="http://www.w3.org/1999/xhtml"><a href="#idm139732193445072">Введение</a></li><li xmlns="http://www.w3.org/1999/xhtml"><a href="#idm139732193450704">От главы коллектива авторов</a></li><li xmlns="http://www.w3.org/1999/xhtml"><a href="#idm139732193453392">От издательства</a></li><li xmlns="http://www.w3.org/1999/xhtml"><a href="#idm139732193456208">Глава 1</a><UL><li><a href="#idm139732208572880">1.1. Общие понятия HTML</a><UL><li><a href="#idm139732208574032">Элемент</a></li><li><a href="#idm139732208578384">Атрибут</a></li></UL></li><li><a href="#idm139732208581584">1.2. Структура HTML-документа</a><UL><li><a href="#idm139732208556368">Объявление типа документа</a></li><li><a href="#idm139732208566224">Элемент HTML</a></li><li><a href="#idm139732208541136">Элемент HEAD</a></li><li><a href="#idm139732208544848">Элемент TITLE</a></li><li><a href="#idm139732208554576">Элемент META</a></li><li><a href="#idm139732209546960">Элемент STYLE</a></li><li><a href="#idm139732227865936">Элемент LINK</a></li><li><a href="#idm139732227876944">Элемент SCRIPT</a></li><li><a href="#idm139732204136272">Элемент BASE</a></li><li><a href="#idm139732204115536">Элемент BODY</a></li><li><a href="#idm139732204092112">Комментарии</a></li></UL></li><li><a href="#idm139732204093520">Резюме</a></li></UL></li><li xmlns="http://www.w3.org/1999/xhtml"><a href="#idm139732204094928">Глава 2</a><UL><li><a href="#idm139732208989904">2.1. Создание заголовков</a></li><li><a href="#idm139732209003472">2.2. Создание абзацев</a></li><li><a href="#idm139732208981840">2.3. Создание обрывов строк</a></li><li><a href="#idm139732188274512">2.4. Создание списков</a><UL><li><a href="#idm139732188277968">Маркированный список</a></li><li><a href="#idm139732188244176">Нумерованный список</a></li><li><a href="#idm139732188211152">Список определений</a></li><li><a href="#idm139732226339024">Создание вложенных списков</a></li></UL></li><li><a href="#idm139732226319824">2.5. Ссылки</a><UL><li><a href="#idm139732226321360">Внешние ссылки</a></li><li><a href="#idm139732226330192">Внутренние ссылки</a></li><li><a href="#idm139732226290768">Общие моменты</a></li></UL></li><li><a href="#idm139732226275024">2.6. Форматирование текста</a><UL><li><a href="#idm139732226278608">Логические элементы для форматирования</a></li><li><a href="#idm139732171115088">Физические элементы для форматирования</a></li><li><a href="#idm139732171064272">Элементы для форматирования больших блоков текста</a></li><li><a href="#idm139732200257232">Вложение элементов</a></li></UL></li><li><a href="#idm139732200263120">Резюме</a></li></UL></li><li xmlns="http://www.w3.org/1999/xhtml"><a href="#idm139732200264528">Глава 3</a><UL><li><a href="#idm139732200272720">3.1. Что такое таблица</a></li><li><a href="#idm139732170641488">3.2. Создание тела таблицы</a></li><li><a href="#idm139732170644432">3.3. Ячейки таблицы</a></li><li><a href="#idm139732170590800">3.4. Граница таблицы</a></li><li><a href="#idm139732198185040">3.5. Ширина и высота таблицы и ячеек</a></li><li><a href="#idm139732198169168">3.6. Группировка строк и столбцов</a></li><li><a href="#idm139732198178256">3.7. Выравнивание таблицы и содержимого ячеек</a></li><li><a href="#idm139732198158672">3.8. Объединение ячеек таблицы</a></li><li><a href="#idm139732198167888">3.9. Установка фонового цвета или рисунка ячейки</a></li><li><a href="#idm139732198138320">3.10. Создание вложенных таблиц</a></li><li><a href="#idm139732198148560">Резюме</a></li></UL></li><li xmlns="http://www.w3.org/1999/xhtml"><a href="#idm139732198150864">Глава 4</a><UL><li><a href="#idm139732198120528">4.1. Встраивание изображений</a><UL><li><a href="#idm139732198130384">Размер изображения</a></li><li><a href="#idm139732208686544">Выравнивание изображения</a></li><li><a href="#idm139732208673104">Расстояние между текстом и изображением</a></li><li><a href="#idm139732208630096">Рамка вокруг изображения</a></li><li><a href="#idm139732208636752">Альтернативный текст</a></li><li><a href="#idm139732208613584">Предварительная загрузка</a></li><li><a href="#idm139732208622032">Ссылки изображения</a></li><li><a href="#idm139732202856528">Галереи изображений</a></li></UL></li><li><a href="#idm139732202858320">4.2. Добавление мультимедиа</a><UL><li><a href="#idm139732202859472">Ссылки на мультимедийные файлы</a></li><li><a href="#idm139732202866384">Встраивание объектов</a></li><li><a href="#idm139732202869200">Атрибуты элемента OBJECT</a></li><li><a href="#idm139732202830288">Элемент PARAM</a></li><li><a href="#idm139732202805456">Встраивание аудио</a></li><li><a href="#idm139732202797392">Встраивание видео</a></li><li><a href="#idm139732209394128">Встраивание Flash-графики</a></li><li><a href="#idm139732209402320">Проигрыватели</a></li><li><a href="#idm139732209378512">Дополнительные возможности элемента OBJECT</a></li></UL></li><li><a href="#idm139732209389648">Резюме</a></li></UL></li><li xmlns="http://www.w3.org/1999/xhtml"><a href="#idm139732209359056">Глава 5</a><UL><li><a href="#idm139732209365456">5.1. Создание фреймов</a></li><li><a href="#idm139732209325520">5.2. Границы фрейма</a></li><li><a href="#idm139732209334864">5.3. Полосы прокрутки</a></li><li><a href="#idm139732202518864">5.4. Ссылки внутри фреймов</a></li><li><a href="#idm139732202532816">5.5. Изменение размеров фреймов</a></li><li><a href="#idm139732202504528">5.6. Плавающие фреймы</a></li><li><a href="#idm139732202509008">5.7. Управление пространством внутри фрейма</a></li><li><a href="#idm139732202516816">5.8. Достоинства и недостатки фреймов</a></li><li><a href="#idm139732202477136">Резюме</a></li></UL></li><li xmlns="http://www.w3.org/1999/xhtml"><a href="#idm139732202478544">Глава 6</a><UL><li><a href="#idm139732202482512">6.1. Элемент FORM</a></li><li><a href="#idm139732169303248">6.2. Создание полей формы</a><UL><li><a href="#idm139732169304400">Общие атрибуты элемента INPUT</a></li><li><a href="#idm139732169308880">Текстовые поля</a></li><li><a href="#idm139732169270608">Поле для ввода пароля</a></li><li><a href="#idm139732169278928">Кнопки</a></li><li><a href="#idm139732169150544">Переключатели</a></li><li><a href="#idm139732169130448">Флажки</a></li><li><a href="#idm139732169143120">Поле для ввода файла</a></li><li><a href="#idm139732169102544">Создание картинок</a></li><li><a href="#idm139732169082448">Скрытые поля</a></li><li><a href="#idm139732169089488">Списки</a></li><li><a href="#idm139732227100880">Большие текстовые поля</a></li><li><a href="#idm139732227079376">Дополнительные удобства</a></li></UL></li><li><a href="#idm139732227034704">Резюме</a></li></UL></li><li xmlns="http://www.w3.org/1999/xhtml"><a href="#idm139732227035728">Глава 7</a><UL><li><a href="#idm139732203561936">7.1. Встраивание CSS в HTML</a></li><li><a href="#idm139732203514960">7.2. Синтаксис CSS</a><UL><li><a href="#idm139732203516112">Ключевые слова</a></li><li><a href="#idm139732203519312">Комментарии</a></li><li><a href="#idm139732203522256">Правила@</a></li></UL></li><li><a href="#idm139732203498320">7.3. Селекторы</a><UL><li><a href="#idm139732203499472">Группировка</a></li><li><a href="#idm139732203503824">Селекторы потомков</a></li><li><a href="#idm139732203814608">Сестринские селекторы</a></li><li><a href="#idm139732203816656">Селекторы атрибутов</a></li><li><a href="#idm139732203826512">Селекторы классов</a></li><li><a href="#idm139732203784784">ID-селекторы</a></li></UL></li><li><a href="#idm139732203763408">7.4. Псевдоэлементы и псевдоклассы</a><UL><li><a href="#idm139732203765840">Псевдокласс :first-child</a></li><li><a href="#idm139732203776208">Псевдоклассы ссылок</a></li><li><a href="#idm139732203730768">Динамические псевдоклассы</a></li><li><a href="#idm139732203737424">Псевдокласс :lang</a></li><li><a href="#idm139732203743312">Псевдоэлемент first-line</a></li><li><a href="#idm139732192679504">Псевдоэлемент first-letter</a></li><li><a href="#idm139732192635600">Псевдоэлементы :before и: after</a></li></UL></li><li><a href="#idm139732202715216">7.5. Правило @media</a></li><li><a href="#idm139732202699344">7.6. Правила !important</a></li><li><a href="#idm139732202704976">7.7. Правило @import</a></li><li><a href="#idm139732202709584">Резюме</a></li></UL></li><li xmlns="http://www.w3.org/1999/xhtml"><a href="#idm139732202710608">Глава 8</a><UL><li><a href="#idm139732202680784">8.1. Выделение текста цветом</a><UL><li><a href="#idm139732168431568">Цвет текста</a></li><li><a href="#idm139732168441296">Цвет фона</a></li></UL></li><li><a href="#idm139732168416976">8.2. Шрифты</a><UL><li><a href="#idm139732168418128">Семейство шрифта</a></li><li><a href="#idm139732168426704">Стиль шрифта</a></li><li><a href="#idm139732168400976">Вид шрифта</a></li><li><a href="#idm139732168406352">Ширина шрифта</a></li><li><a href="#idm139732168412496">Размер шрифта</a></li></UL></li><li><a href="#idm139732168372688">8.3. Форматирование текста</a><UL><li><a href="#idm139732168373840">Отступы</a></li><li><a href="#idm139732168377936">Выравнивание текста</a></li><li><a href="#idm139732168351440">Декоративное оформление</a></li><li><a href="#idm139732168360400">Расстояние между буквами</a></li><li><a href="#idm139732168365392">Расстояние между словами</a></li><li><a href="#idm139732194590544">Трансформация текста</a></li><li><a href="#idm139732194596176">Пустое место</a></li><li><a href="#idm139732194599760">Направление вывода текста</a></li></UL></li><li><a href="#idm139732194601552">Резюме</a></li></UL></li><li xmlns="http://www.w3.org/1999/xhtml"><a href="#idm139732194602960">Глава 9</a><UL><li><a href="#idm139732194574928">9.1. Фон</a></li><li><a href="#idm139732194568656">9.2. Генерируемое содержимое</a><UL><li><a href="#idm139732194522704">Псевдоэлементы :before и: after</a></li><li><a href="#idm139732194527312">Свойство content</a></li><li><a href="#idm139732194534864">Кавычки</a></li></UL></li><li><a href="#idm139732228204368">9.3. Автоматическая нумерация и списки</a><UL><li><a href="#idm139732228183632">Стили счетчиков</a></li><li><a href="#idm139732228189904">Счетчики со свойством display: none</a></li><li><a href="#idm139732228159568">Списки</a></li><li><a href="#idm139732227551312">Маркеры</a></li></UL></li><li><a href="#idm139732187792464">9.4. Таблицы</a><UL><li><a href="#idm139732187793616">Селекторы столбцов</a></li><li><a href="#idm139732187798864">Положение и выравнивание заголовка</a></li><li><a href="#idm139732187764048">Слои и прозрачность таблицы</a></li><li><a href="#idm139732187746640">Ширина таблицы</a></li><li><a href="#idm139732187748432">Высота таблицы</a></li><li><a href="#idm139732187749840">Вертикальное выравнивание</a></li><li><a href="#idm139732187752784">Горизонтальное выравнивание</a></li><li><a href="#idm139732187732304">Динамические эффекты строк и столбцов</a></li><li><a href="#idm139732187733712">Границы</a></li><li><a href="#idm139732187738576">Стили границ</a></li><li><a href="#idm139732340549328">Пустые ячейки</a></li></UL></li><li><a href="#idm139732340551248">9.5. Интерфейс пользователя</a><UL><li><a href="#idm139732340552400">Указатели мыши</a></li><li><a href="#idm139732340559312">Пользовательские настройки цветов</a></li><li><a href="#idm139732340523472">Пользовательские настройки шрифтов</a></li><li><a href="#idm139732340528208">Контуры</a></li></UL></li><li><a href="#idm139732340484688">9.6. Поля и отступы</a><UL><li><a href="#idm139732340485840">Свойства полей</a></li><li><a href="#idm139732340494544">Свойства отступов</a></li></UL></li><li><a href="#idm139732340467408">9.7. Границы</a><UL><li><a href="#idm139732340468560">Ширина границы</a></li><li><a href="#idm139732340474448">Цвет границы</a></li><li><a href="#idm139732340478032">Стиль границы</a></li></UL></li><li><a href="#idm139732340452816">9.8. Работа с блоками</a><UL><li><a href="#idm139732340453968">Выбор схемы позиционирования</a></li><li><a href="#idm139732340459472">Смещение блоков</a></li><li><a href="#idm139732200053072">Позиционирование перемещаемого объекта</a></li><li><a href="#idm139732200066384">Фиксированное позиционирование</a></li><li><a href="#idm139732200008528">Определение позиционного уровня</a></li></UL></li><li><a href="#idm139732199990992">Резюме</a></li></UL></li><li xmlns="http://www.w3.org/1999/xhtml"><a href="#idm139732199992016">Глава 10</a><UL><li><a href="#idm139732199996496">10.1. Браузер и HTML-документ</a></li><li><a href="#idm139732199960400">10.2. Родительские и дочерние объекты</a></li><li><a href="#idm139732320254288">10.3. Объекты браузера</a><UL><li><a href="#idm139732320255440">Объект Window</a></li><li><a href="#idm139732168646736">Объект Navigator</a></li><li><a href="#idm139732168598224">Объект Screen</a></li><li><a href="#idm139732168579920">Объект History</a></li><li><a href="#idm139732184920400">Объект Location</a></li></UL></li><li><a href="#idm139732184863824">10.4. Объектная модель документа (DOM)</a><UL><li><a href="#idm139732184865104">Объект Document</a></li><li><a href="#idm139732184818896">Доступ к объектам документа</a></li></UL></li><li><a href="#idm139732192843216">Резюме</a></li></UL></li><li xmlns="http://www.w3.org/1999/xhtml"><a href="#idm139732192844240">Глава 11</a><UL><li><a href="#idm139732192848208">11.1. Работа с информацией</a><UL><li><a href="#idm139732192805200">Метод alert()</a></li><li><a href="#idm139732192815568">Метод prompt()</a></li><li><a href="#idm139732192793040">Метод confirm()</a></li></UL></li><li><a href="#idm139732192800080">11.2. Переменные и типы данных</a><UL><li><a href="#idm139732192801232">Идентификаторы</a></li><li><a href="#idm139732187696336">Ключевые и зарезервированные слова</a></li><li><a href="#idm139732187700432">Литералы</a></li><li><a href="#idm139732187643088">Переменные</a></li><li><a href="#idm139732187612624">Массивы</a></li></UL></li><li><a href="#idm139732187606736">11.3. Выражения</a><UL><li><a href="#idm139732187607888">Операции присвоения</a></li><li><a href="#idm139732187579984">Арифметические операции</a></li><li><a href="#idm139732198035280">Операции сравнения</a></li><li><a href="#idm139732198021200">Операции над строками</a></li><li><a href="#idm139732198025424">Логические операции</a></li><li><a href="#idm139732197995984">Условные операции</a></li><li><a href="#idm139732197998032">Поразрядные операции</a></li><li><a href="#idm139732198000848">Другие операции</a></li></UL></li><li><a href="#idm139732198004688">11.4. Условия и циклы</a><UL><li><a href="#idm139732198005840">Условные операторы</a></li><li><a href="#idm139732197960528">Операторы цикла</a></li></UL></li><li><a href="#idm139732185193808">11.5. Функции и события</a><UL><li><a href="#idm139732185194960">Функции</a></li><li><a href="#idm139732185134032">Знакомство с событиями</a></li></UL></li><li><a href="#idm139732185112528">11.6. Встроенные объекты JavaScript</a><UL><li><a href="#idm139732185117776">Объект Global</a></li><li><a href="#idm139732185072208">Объект String</a></li><li><a href="#idm139732185076688">Объект Number</a></li><li><a href="#idm139732185079376">Объект Boolean</a></li><li><a href="#idm139732185081296">Объект Array</a></li><li><a href="#idm139732185083984">Объект Function</a></li><li><a href="#idm139732185056720">Объект Date</a></li><li><a href="#idm139732185065808">Объект Math</a></li><li><a href="#idm139732185068880">Объект RegExp</a></li><li><a href="#idm139732201979856">Объект Object</a></li></UL></li><li><a href="#idm139732201982544">Резюме</a></li></UL></li><li xmlns="http://www.w3.org/1999/xhtml"><a href="#idm139732201983568">Глава 12</a><UL><li><a href="#idm139732201987152">12.1. Организация рабочего окружения</a><UL><li><a href="#idm139732201988304">Текстовые редакторы</a></li><li><a href="#idm139732201990096">Браузеры</a></li><li><a href="#idm139732201992528">Отладчики сценариев JavaScript</a></li></UL></li><li><a href="#idm139732201930576">12.2. Внедрение сценариев в HTML-документ</a><UL><li><a href="#idm139732201933264">Встраивание сценариев в гиперссылку</a></li><li><a href="#idm139732201937744">Встраивание сценариев для обработки событий</a></li><li><a href="#idm139732201941584">Встраивание сценариев в рамках элемента SCRIPT</a></li></UL></li><li><a href="#idm139732201889104">12.3. Вводим первый сценарий</a></li><li><a href="#idm139732201868752">12.4. Разбор нашего сценария в среде FrontPage</a></li><li><a href="#idm139732201876688">12.5. Отладка сценария в Microsoft Script Editor</a></li><li><a href="#idm139732201857232">Резюме</a></li></UL></li><li xmlns="http://www.w3.org/1999/xhtml"><a href="#idm139732201859664">Глава 13</a><UL><li><a href="#idm139732188982352">13.1. Структура XHTML-документов</a></li><li><a href="#idm139732188953424">13.2. Отличие XHTML от HTML</a><UL><li><a href="#idm139732188954576">Значения атрибутов должны быть в кавычках</a></li><li><a href="#idm139732188957648">Необходимо наличие закрывающего тега</a></li><li><a href="#idm139732188912848">Необходимо корректно вкладывать элементы друг в друга</a></li><li><a href="#idm139732188919760">Назначение имен тегов и атрибутов зависит от регистра</a></li><li><a href="#idm139732188921168">Требуется явно задавать значения атрибутов</a></li><li><a href="#idm139732188922960">Включение сценариев и специальных символов в документы XHTML</a></li></UL></li><li><a href="#idm139732188879568">13.3. Проблемы использования XHTML</a></li><li><a href="#idm139732188813776">Резюме</a></li></UL></li>
</ul></blockquote>
<h1 xmlns="http://www.w3.org/1999/xhtml" class="master">Игорь Квинт<br></br>
HTML, XHTML и CSS на 100%
</h1><h1 xmlns="http://www.w3.org/1999/xhtml" id="idm139732193445072" class="master">Введение
</h1><div xmlns="http://www.w3.org/1999/xhtml" style="text-align: justify" class="hsection1">   Всемирная паутина стала одним из наиболее значительных достижений XX века. В наше время стремительных перемен такой возраст можно уже считать существенным, но технологии работы в Интернете развиваются до сих пор. В основе всех этих технологий лежит язык HTML (HyperText Markup Language – язык гипертекстовой разметки), переживший несколько этапов развития, которые завершались появлением новых версий.<br></br>   В настоящее время используется последняя версия языка HTML под названием XHTML (eXtensible HyperText Markup Language – расширяемый язык гипертекстовой разметки), включающая поддержку языка XML (eXtensible Markup Language – расширяемый язык разметки). За исключением поддержки XML обе спецификации языка (HTML и XHTML) в общем аналогичны, поэтому основное внимание в книге уделено языку HTML как наиболее часто используемому средству для создания сайтов. В последней же главе описаны основы языка XHTML, его отличия от HTML, а также требования, которым должен следовать разработчик веб-страниц, чтобы его сайт удовлетворял требованиям языка XHTML.<br></br>   С помощью собственно HTML можно создавать веб-страницы со статическим (неизменным) содержимым. Однако при первом же путешествии по Всемирной паутине вы можете увидеть, что содержимое сайтов подобными страницами не ограничивается. Посетив любой крупный сайт, сразу можно заметить, что на его страницах есть компоненты, реагирующие на щелчки кнопкой мыши. Такие страницы называются <i>динамическими.</i> Для их создания используются небольшие программы, внедренные в HTML-код данной страницы. Эти приложения называются <i>сценариями</i> (script). Наиболее популярным языком создания сценариев на сегодняшний момент является JavaScript. В данной книге приведены общие сведения об этом языке, достаточные для написания и отладки небольших сценариев, которые создаются для большинства сайтов. Цель этого издания – научить читателей создавать такие сайты. У вас появятся практические навыки работы с HTML-кодом и JavaScript, необходимые практикующему веб-дизайнеру. Прочитав книгу, вы сможете создавать динамичные сайты профессионального вида и содержания.<br></br>   Книга начинается с описания структуры документа HTML. В первой главе рассказано, из каких компонентов состоит HTML-код, применяемый для создания любой веб-страницы. Вводятся основные понятия и даются сведения о синтаксических конструкциях языка HTML (элементах и атрибутах), указывается, что такое заголовок и тело документа HTML.<br></br>   В следующих трех главах описываются методы создания и оформления основных частей документа HTML. Вы познакомитесь со способами ввода текста и его форматирования, настройки внешнего вида таблиц, а также включения в страницу веб-графики и мультимедийной информации (аудио– и видеоклипов). Эти элементы дизайна улучшают восприятие веб-страницы, превращая скучный документ в яркую и красочную витрину вашего сайта, которая не оставит равнодушным ни одного посетителя.<br></br>   В очередных двух главах описываются <i>фреймы</i> и <i>формы.</i> Фрейм – это вставленная в HTML-страницу другая HTML-страница. Такая структура очень удобна, когда на веб-страницу нужно поместить несколько различных компонентов, отображаемых поочередно по желанию посетителя. С формами знаком практически каждый, кто пользовался почтовыми сервисами на большинстве сайтов. Формы позволяют поместить на веб-страницу элементы управления, как в обычном интерфейсе Windows, и использовать их для ввода и отправления писем, данных интерактивных опросов и т. д.<br></br>   Следующие главы книги посвящены очень важным средствам веб-дизайна – языкам CSS (Cascading Style Sheets – каскадные таблицы стилей) и JavaScript. С помощью JavaScript, как вы уже знаете, создаются динамичные веб-страницы, позволяющие вести интерактивное взаимодействие с посетителем сайта. По сути сценарии JavaScript позволяют превратить веб-страницу в небольшую программу. Вы освоите концепцию языка, его синтаксис и способы внедрения в HTML-код.<br></br>   Язык CSS – очень эффективный и современный инструмент оформления вебстраниц, напоминающий стилевое форматирование, которое применяется в Word. Вместо того чтобы каждый раз вводить множество параметров форматирования части документа, вы определяете стиль и применяете его там, где необходимо. Язык CSS позволяет сделать это в простой и удобной форме.<br></br>   Материал книги исчерпывающе объясняет все основные моменты веб-дизайна динамичных и статичных веб-страниц, причем в простой и удобной для усвоения форме – в виде набора пошаговых процедур, реализующих конкретные операции веб-дизайна, с хорошо подобранными и выразительными примерами. Шаг за шагом выполняя эти процедуры, вы станете настоящим мастером веб-дизайна, способным решать любые задачи по созданию профессиональных сайтов.<br></br></div><h1 xmlns="http://www.w3.org/1999/xhtml" id="idm139732193450704" class="master">От главы коллектива авторов
</h1><div xmlns="http://www.w3.org/1999/xhtml" style="text-align: justify" class="hsection1">   Высказать замечания и пожелания, задать вопросы по этой книге вы можете по адресу <a href="mailto:alexanderzhadaev@sigmaplus.mcdir.ru">alexanderzhadaev@sigmaplus.mcdir.ru</a> или посетив мою домашнюю страничку <a href="http://www.sigmaplus.mcdir.ru/">www.sigmaplus.mcdir.ru</a>. Меня очень интересует ваше мнение о книге, и я обязательно учту все ваши пожелания и замечания в следующих изданиях.<br></br>   <i>Александр Жадаев</i><br></br></div><h1 xmlns="http://www.w3.org/1999/xhtml" id="idm139732193453392" class="master">От издательства
</h1><div xmlns="http://www.w3.org/1999/xhtml" style="text-align: justify" class="hsection1">   Ваши замечания, предложения и вопросы отправляйте по адресу электронной почты <a href="mailto:gromakovski@minsk.piter.com">gromakovski@minsk.piter.com</a> (издательство «Питер», компьютерная редакция).<br></br>   Мы будем рады узнать ваше мнение!<br></br>   На сайте издательства <a href="http://www.piter.com/">http://www.piter.com</a> вы найдете подробную информацию о наших книгах.<br></br></div><h1 xmlns="http://www.w3.org/1999/xhtml" id="idm139732193456208" class="master">Глава 1<br></br>
Правила построения HTML-страниц
</h1><div xmlns="http://www.w3.org/1999/xhtml" style="text-align: justify" class="hsection1"><div style="text-align: justify" class="section2">   1.1. Общие понятия HTML<br></br>
   1.2. Структура HTML-документа<br></br>
   Для создания веб-страниц часто используется язык гипертекстовой разметки HTML. Конечно, каждый сайт индивидуален, но существуют общие правила построения HTML-страниц. Им обязательно нужно следовать – только в этом случае ваш HTML-код будет верно распознаваться и отображаться браузером.<br></br>
</div><h2 id="idm139732208572880">1.1. Общие понятия HTML
</h2><div style="text-align: justify" class="hsection2"><div style="text-align: justify" class="section3">   Существуют общие правила записи HTML-документов и принципы, используемые при создании сайтов. Их мы и рассмотрим в этом разделе.<br></br>
</div><h3 id="idm139732208574032">Элемент
</h3><div style="text-align: justify" class="hsection3">   Основой языка HTML является <i>элемент.</i> Он несет в себе определенную информацию, может описывать документ в целом или способ форматирования текста. Элементы можно назвать основой построения сайта. Все, что вы захотите создать на вашей странице, будет сделано с помощью элементов.<br></br>   Название элемента помещается в угловые скобки, например &lt;P&gt;. Полученное выражение называется <i>тегом.</i> В данном случае это открывающий тег. Иногда необходимо задать парный закрывающий тег, который записывается так: &lt;/P&gt;. В основном парные теги используются при форматировании текста, они задают начало и конец блока форматирования. Иногда закрывающий тег вообще не требуется, а иногда его можно пропустить, однако для корректной обработки документа рекомендуется всегда использовать закрывающий тег.<br></br>   Кратко функции данных тегов можно описать так: открывающий тег включает форматирование, а закрывающий выключает. При этом основным отличием в записи тегов, кроме постановки символа / в закрывающем теге, является отсутствие атрибутов у последнего.<br></br>   Примером необходимости использования закрывающего тега является работа с элементом P, который обозначает абзац:<br></br>   &lt;Р&gt;Текст абзаца&lt;/Р&gt;<br></br>   Однако и в данном случае закрывающий тег является необязательным, но желательным. Элемент IMG, который добавляет картинку на сайт, наоборот, не требует наличия закрывающего тега. По назначению элемента зачастую можно догадаться, требуется ли ему закрывающий тег.<br></br>   Элементы применяются для того, чтобы сказать браузеру, какой блок вы хотите видеть в определенном месте страницы, а также какую информацию этот блок должен содержать. Кроме того, браузеру нужно сообщить, как отображать эту информацию. Для этого используют атрибуты элементов.<br></br></div><h3 id="idm139732208578384">Атрибут
</h3><div style="text-align: justify" class="hsection3">   С помощью <i>атрибутов</i> можно указывать различные способы отображения информации, добавляемой с помощью одинаковых элементов, а в некоторых случаях применение элемента без атрибутов не дает результатов. Например, в одном абзаце нужно выровнять текст по левому краю, а в другом – по правому. Чтобы задать выравнивание абзаца, используем атрибут align элемента P:<br></br>   &lt;P align="left"&gt;Выравнивание по левому краю&lt;/P&gt;<br></br>   &lt;P align="right"&gt;Выравнивание по правому краю&lt;/P&gt;<br></br>   Значения атрибутов задаются после знака равенства в кавычках и могут быть разными. Некоторым атрибутам присущ набор фиксированных значений, для других количество значений не ограничено.<br></br>   Элементы и их атрибуты являются основой языка HTML, но для правильного отображения страницы в браузерах еще важно верно создать структуру документа. Для этого существуют строгие правила. Есть элементы, без которых HTML-документ не может обойтись, потому что именно они определяют его структуру.<br></br></div></div><h2 id="idm139732208581584">1.2. Структура HTML-документа
</h2><div style="text-align: justify" class="hsection2"><div style="text-align: justify" class="section3">   Для создания структуры документа и хранения служебной информации в нем предусмотрено много элементов, которые охватывают все необходимые пункты построения документа.<br></br>
   Из листинга 1.1 видно, что HTML-документ содержит следующие компоненты:<br></br>
   • строку объявления типа документа;<br></br>
   • декларативный заголовок;<br></br>
   • тело документа.<br></br>
<h5 class="subtitle"><b>Листинг 1.1.</b> Описание документа в элементе DOCTYPE</h5>   &lt;!DOCTYPE HTML PUBLIC «-//W3C//DTD HTML 4.01 Transitional//EN»<br></br>
   "http://www.w3.org/TR/html4/loose.dtd"&gt;<br></br>
   &lt;HTML&gt;<br></br>
   &lt;HEAD&gt;<br></br>
   &lt;TITLE&gt;Это листинг структуры документа HTML&lt;/TITLE&gt;<br></br>
   ...Элементы заголовка...<br></br>
   &lt;/HEAD&gt;<br></br>
   &lt;BODY&gt;<br></br>
   ...Тело документа...<br></br>
   &lt;/BODY&gt;<br></br>
   &lt;/HTML&gt;<br></br>
</div><h3 id="idm139732208556368">Объявление типа документа
</h3><div style="text-align: justify" class="hsection3">   В начале каждого HTML-документа следует помещать строку объявления такого рода:<br></br>   &lt;!DOCTYPE HTML PUBLIC «-//W3C//DTD HTML 4.01 Transitional//EN» «http://www.w3.org/ TR/html4/loose.dtd»&gt;<br></br>   Эта строка дает браузеру общую информацию об HTML-документе. Несмотря на то что вам вряд ли придется заполнять строку иначе, рассмотрим ее по частям и выясним, какую информацию о документе несут данные из элемента DOCTYPE.<br></br>   • HTML – показывает, что для создания документа применяется язык HTML.<br></br>   • PUBLIC – указывает на то, что при создании документа использована общепринятая версия HTML.<br></br>   • "-//W3C//DTD HTML 4.01 Transitional//EN" – задает публичное имя спецификации языка, применяемого для разметки документа. Если браузер по этому имени сможет распознать, где находятся правила обработки данного документа, он воспользуется ими, иначе сможет загрузить их по ссылке в следующем атрибуте. В данном случае это язык HTML версии 4.01, новейшей на момент написания книги.<br></br>   • "http://www.w3.org/TR/html4/loose.dtd" – URL-адрес документа, содержащего <i>наборы определений типа документа,</i> подготовленного в соответствии с языком HTML 4.01.<br></br>   Что такое набор правил определения типа документа (Document Type Definition, DTD), мы обсудим в конце книги, когда приступим к освоению языка XHTML. Сейчас же просто запомните, что это сведения, которые необходимы браузеру или другой программе, предназначенной для работы с данным документом HTML, для его правильной обработки. Для документов HTML 4.01 организация W3C определила три набора таких правил DTD.<br></br>   • Набор <i>строгих правил DTD,</i> которые требуют, чтобы данный HTML-документ точно соответствовал всем требованиям спецификации HTML 4.01. Документы с этим набором правил содержат такое объявление:<br></br>   &lt;!DOCTYPE HTML PUBLIC «-//W3C//DTD HTML 4.01//EN» «http://www.w3.org/TR/html4/strict.dtd»&gt;<br></br>   • Набор <i>переходных (transitional) правил DTD,</i> которые допускают использование устаревших, не поддерживаемых в версии HTML 4.01 элементов и атрибутов. Документы с этим набором правил содержат такое объявление:<br></br>   &lt;!DOCTYPE HTML PUBLIC «-//W3C//DTD HTML 4.01 Transitional//EN» «http://www.w3.org/ TR/html4/loose.dtd»&gt;<br></br>   • Набор <i>правил DTD для документов HTML 4.01 с фреймами.</i> Что такое фреймы, вы уже знаете: если веб-страница выглядит в окне браузера как набор нескольких окон со своими полосами прокрутки, значит, это и есть фреймовый HTML-документ. Документы такого типа должны содержать следующее объявление:<br></br>   &lt;!DOCTYPE HTML PUBLIC «-//W3C//DTD HTML 4.01 Frameset//EN» «http://www.w3.org/TR/html4/frameset.dtd»&gt;<br></br>   В этом объявлении содержится общая служебная информация о данном документе HTML 4.01. Если вы пропустите его при создании HTML-документа, браузер, скорее всего, сам сможет догадаться, как ему отобразить соответствующую страницу, но организация W3C настоятельно рекомендует включать объявления DOCTYPE во все разрабатываемые документы.<br></br>   Может возникнуть вопрос: а зачем существуют строгие и переходные правила DTD и какие из них следует использовать? Ответ связан с историей развития Интернета в целом и языка HTML в частности. Отказ от устаревших средств языка и использование строгих DTD могут привести к тому, что ваш документ HTML 4.01 не будет корректно воспроизводиться отдельными устаревшими программами, поэтому в настоящее время безопаснее использовать переходный набор DTD.<br></br>   После того как вы ввели общую информацию о странице, нужно разобраться с ее структурой.<br></br></div><h3 id="idm139732208566224">Элемент HTML
</h3><div style="text-align: justify" class="hsection3">   Корневым элементом документа HTML 4.01 является &lt;HTML&gt;. Это значит, что все остальные элементы содержатся внутри тегов &lt;HTML&gt; и &lt;/HTML&gt;. Тем не менее в документах HTML 4.01 этот элемент не является обязательным, хотя W3C рекомендует включать его. В XHTML-документах наличие HTML обязательно.<br></br>   В элементе HTML могут применяться следующие атрибуты.<br></br>   • lang – определяет язык документа.<br></br>   • dir – задает направление чтения на языке документа (RTL – справа налево, LTR – слева направо).<br></br>   • version – определяет версию стандарта HTML, использованного при составлении документа. Это устаревший атрибут, и его применение не рекомендовано.<br></br>   • title – определяет всплывающую подсказку для страницы.<br></br>   В листинге 1.2 представлен пример использования элемента HTML вместе с атрибутами, указывающими на использование русского языка и направление чтения слева направо.<br></br><h5 class="subtitle"><b>Листинг 1.2.</b> Элемент HTML с атрибутами</h5>   &lt;!DOCTYPE HTML PUBLIC «-//W3C//DTD HTML 4.01 Transitional//EN»<br></br>   "http://www.w3.org/TR/html4/loose.dtd"&gt;<br></br>   &lt;html lang="ru" dir="LTR" title="Моя страничка"&gt;<br></br>   &lt;–!Содержимое документа–&gt;<br></br>   &lt;/html&gt;<br></br>   На рис. 1.1 представлен результат использования атрибутов элемента HTML.<br></br><div class="wrap_pict"><div style="text-align: center;"><img src="i_001.png" alt=""></img></div>   <b>Рис. 1.1.</b> Значение атрибута title отображено в виде экранной подсказки<br></br></div><br></br>   Следует отметить, что атрибут dir в данном случае не обеспечен достаточной поддержкой известных браузеров даже последних версий. Например, IE 6 и Opera 9 просто выравнивают текст по правому краю, а некоторые устаревшие браузеры этот атрибут просто игнорируют. Так что, если вы намерены использовать текст с альтернативным направлением чтения (иврит, арабский язык), этот атрибут нужно применять с осторожностью.<br></br></div><h3 id="idm139732208541136">Элемент HEAD
</h3><div style="text-align: justify" class="hsection3">   После того как для документа создана основа, внутри нее нужно создать заглавную область. Информация, вводимая в элемент HEAD, не отображается в окне браузера, а помогает ему в обработке страницы.<br></br>   В заголовке должны присутствовать как открывающий, так и закрывающий теги &lt;HEAD&gt; и &lt;/HEAD&gt;, между которыми располагаются другие элементы, несущие служебную информацию о странице. Элементы, находящиеся внутри элемента HEAD, играют очень важную роль: данные, содержащиеся в них, помогают браузеру в обработке страницы, а поисковым системам – в индексации документа.<br></br>   Для элемента HEAD определены те же атрибуты, что и для HTML, а также атрибут profil. Он позволяет задать адрес файла с настройками, которые устанавливаются элементами &lt;META&gt; внутри заголовка. С его помощью можно будет избежать многократной записи одних и тех же элементов &lt;META&gt;. Однако этот атрибут пока не введен в действие и рассчитан на будущее развитие языка HTML.<br></br>   Элементы, которые можно использовать внутри элемента HEAD, представлены в табл. 1.1.<br></br><h5 class="subtitle"><b>Таблица 1.1.</b> Элементы, используемые внутри элемента HEAD</h5><div style="text-align: center;"><img src="i_002.png" alt=""></img></div>   В таблице элементы описаны кратко, дальше мы рассмотрим некоторые из них подробнее. Как можно увидеть из краткого описания в табл. 1.1, они содержат данные, единые для всей страницы.<br></br>   Начнем с элемента, определяющего заголовок страницы.<br></br></div><h3 id="idm139732208544848">Элемент TITLE
</h3><div style="text-align: justify" class="hsection3">   Он задает название страницы, которое будет отображаться в строке заголовка окна браузера. Согласно спецификации HTML 4.01 в содержимом элемента HEAD обязательно наличие элемента TITLE, причем в единственном числе.<br></br>   Элемент требует наличия закрывающего тега &lt;/TITLE&gt;. Текст, содержащийся между открывающим и закрывающим тегами, и будет отображаться в строке заголовка окна браузера.<br></br>   Помимо основной функции – рассказать посетителю, о чем страница, – элемент выполняет несколько косвенных задач. Некоторые поисковые системы используют текст, содержащийся в этом элементе, для поиска и выводят его в качестве заголовка результата поиска, поэтому корректно и качественно составленное заглавие может привлечь посетителей на сайт.<br></br>   По тексту заголовка пользователь получает дополнительную информацию: что это за сайт и как называется текущая страница. Не стоит думать, что достаточно в документе указать логотип сайта и проигнорировать заголовок. Посетитель может сворачивать окна, и тогда заголовки будут отображаться на кнопках Панели задач – по ним можно будет легко сориентироваться, с каким сайтом работать.<br></br>   Большинство браузеров поддерживают возможность сохранения веб-страницы на компьютер. В этом случае имя сохраненного файла совпадает с названием заголовка документа. Если в тексте заголовка содержатся символы, недопустимые в имени файла (\ /: *? " &lt; &gt; |), то они будут проигнорированы или заменены другими разрешенными символами.<br></br>   При сохранении в разделе браузера Избранное в качестве названия ссылки будет использоваться текст, записанный в элементе TITLE. В этом случае адрес текущей страницы с ее заголовком помещается в список ссылок. Поскольку этот список, как правило, хранится в виде отдельных файлов, к их именам также применяется вышеописанное правило.<br></br>   В листинге 1.3 показан пример использования элемента TITLE.<br></br><h5 class="subtitle"><b>Листинг 1.3.</b> Использование элемента TITLE</h5>   &lt;!DOCTYPE HTML PUBLIC «-//W3C//DTD HTML 4.01 Transitional//EN»<br></br>   "http://www.w3.org/TR/html4/loose.dtd"&gt;<br></br>   &lt;html&gt;<br></br>   &lt;head&gt;<br></br>   &lt;title&gt;Пример создания заголовка страницы&lt;/title&gt;<br></br>   &lt;–!Другое содержимое заголовка–&gt;<br></br>   &lt;/head&gt;<br></br>   &lt;–!Содержимое документа–&gt;<br></br>   &lt;/html&gt;<br></br>   Название страницы нужно придумывать, логически исходя из ее содержимого.<br></br>   На рис. 1.2 представлен результат работы листинга 1.3. Видно, что текст заголовка отображается в строке заголовка окна.<br></br><div class="wrap_pict"><div style="text-align: center;"><img src="i_003.png" alt=""></img></div>   <b>Рис. 1.2.</b> Вид заголовка страницы<br></br></div><br></br>   Мы определились с заголовком новой страницы, теперь посмотрим, какая служебная информация может содержаться внутри элемента HEAD.<br></br></div><h3 id="idm139732208554576">Элемент META
</h3><div style="text-align: justify" class="hsection3">   Элемент META используется для хранения дополнительной информации о странице. Эту информацию браузеры применяют для обработки страницы, а поисковые системы – для ее индексации. Например, чтобы указать автора HTML-документа, можно использовать элемент META следующим образом:<br></br>   &lt;META name="Author" content="Вася Пупкин"&gt;<br></br>   Здесь значение атрибута name задает имя свойства Author, которому в атрибуте content присваивается имя – «Вася Пупкин». В этом и состоит общее правило применения элементов META: с их помощью вы задаете в атрибуте name имя нового свойства, которому далее в атрибуте content присваиваете значение. Вместо атрибута name можно использовать атрибут http-equiv, который служит для обмена служебной информацией браузера с веб-сервером. Например, рассмотрим такой элемент:<br></br>   &lt;META http-equiv="Expires" content="Sun, 1 Nov 2009 16:20:47 GMT"&gt;<br></br>   Он сообщает браузеру, когда будет исчерпан срок хранения в кэше данной страницы. После этого нужно будет выполнить повторный запрос сервера.<br></br>   В элементе HEAD может быть несколько элементов META, потому что в зависимости от используемых атрибутов они могут нести разную информацию. В табл. 1.2 представлены возможные значения атрибута http-equiv. Заметьте, спецификация HTML 4.01 не определяет значения этого атрибута, поскольку они устанавливаются протоколом обмена информацией с веб-сервером. Использовать элементы META с такими атрибутами рекомендуется только подготовленным специалистам.<br></br><h5 class="subtitle"><b>Таблица 1.2.</b> Возможные значения атрибута http-equiv</h5><div style="text-align: center;"><img src="i_004.png" alt=""></img></div><br></br><div style="text-align: center;"><img src="i_005.png" alt=""></img></div>   Рассмотрим подробнее применение описанных выше атрибутов.<br></br>   В листинге 1.4 приведен пример того, как с помощью атрибута http-equiv задать свойства обработки страницы.<br></br><h5 class="subtitle"><b>Листинг 1.4.</b> Применение атрибута http-equiv</h5>   &lt;!DOCTYPE HTML PUBLIC «-//W3C//DTD HTML 4.01 Transitional//EN»<br></br>   "http://www.w3.org/TR/html4/loose.dtd"&gt;<br></br>   &lt;html title="Моя страничка" lang="ru"&gt;<br></br>   &lt;head&gt;<br></br>   &lt;title&gt;Использование элемента META&lt;/title&gt;<br></br>   &lt;meta http-equiv="Content-Type" content="text/html" charset="windows-1251" /&gt;<br></br>   &lt;meta http-equiv="refresh" content="10" URL="http:\\test.ru" /&gt;<br></br>   &lt;meta http-equiv="pragma" content="no-cache" /&gt;<br></br>   &lt;meta http-equiv="expires" content="Sun, Oct 2010 10:09:00 GMT+3" /&gt;<br></br>   &lt;/head&gt;<br></br>   &lt;/html&gt;<br></br><br></br>   Как видно из примера, значение атрибута http-equiv указывает на переменную, значение которой определено с помощью атрибута content.<br></br>   Значение content-type, использованное в примере, будет одинаковым для всех сайтов в кириллической кодировке. Рекомендуем всегда указывать его, иначе браузер может некорректно отображать текст на вашей странице.<br></br>   Использование параметра refresh полезно, когда страницу перенесли в другое место или когда у нее много адресов. В таком случае вместо того чтобы создавать множество сайтов по разным адресам, можно просто задать возможность переброски посетителя на основной сайт. В примере из листинга 1.4 через 10 секунд после загрузки страницы загрузится сайт test.ru.<br></br><blockquote><div>   <b>Совет</b><br></br>
   Не все браузеры поддерживают автоматическую пересылку. На всякий случай на странице, с которой идет переадресация, нужно оставлять текстовую ссылку на страницу переадресации.<br></br>
</div></blockquote>   Рассмотрим возможные значения атрибута content для каждого из представленных свойств (табл. 1.3).<br></br><h5 class="subtitle"><b>Таблица 1.3.</b> Значения атрибута content для различных значений атрибута http-equiv</h5><div style="text-align: center;"><img src="i_006.png" alt=""></img></div>   Большинство значений атрибута content, которые вам могут пригодиться, представлены в таблице. Поначалу вы вообще можете ограничиться использованием свойства content-type (оно обязательно), а остальные параметры будете включать при необходимости.<br></br>   Атрибут name, как и http-equiv, содержит служебную информацию о документе, однако в нем записывается информация другого плана. Например, данные об авторе и содержимом документа. Эти данные не влияют на обработку документа браузером, однако дают информацию для поисковых систем.<br></br>   В табл. 1.4 представлены возможные значения атрибута name.<br></br><h5 class="subtitle"><b>Таблица 1.4.</b> Возможные значения атрибута name</h5><div style="text-align: center;"><img src="i_007.png" alt=""></img></div>   Как видно из табл. 1.4, большинство свойств отвечает за индексацию страницы в поисковиках. Это очень важный момент, ведь когда вы создаете сайт, то хотите сделать его посещаемым, а в этом помогает элемент META.<br></br>   Параметры, задаваемые в элементе META, помогают поисковым роботам ассоциировать ваш сайт с определенной тематикой. В результате, когда человек введет в поисковике слово, установленное для вашей страницы в качестве ключевого, среди результатов отобразится ссылка на страницу.<br></br><blockquote><div>   <b>Примечание</b><br></br>
   Роботы – это специальные программы, которые перемещаются по Интернету и запоминают просмотренные сайты. Результаты поиска заносятся в базы поисковых сайтов, и поиск с самих сайтов осуществляется по этим базам.<br></br>
   У каждого поисковика свои программы-роботы и своя логика поиска и хранения данных в базах, поэтому часто одинаковые запросы в разных поисковых системах дают различные результаты.<br></br>
</div></blockquote>   В листинге 1.5 приведен пример использования параметров элемента META для управления индексацией страницы.<br></br><h5 class="subtitle"><b>Листинг 1.5.</b> Параметры элемента META для индексации в поисковиках</h5>   &lt;!DOCTYPE HTML PUBLIC «-//W3C//DTD HTML 4.01 Transitional//EN»<br></br>   "http://www.w3.org/TR/html4/loose.dtd"&gt;<br></br>   &lt;html xmlns="http://www.w3.org/1999/xhtml" title="Моя страничка" lang="ru" xml:lang="ru"&gt;<br></br>   &lt;head&gt;<br></br>   &lt;title&gt;Использование элемента META&lt;/title&gt;<br></br>   &lt;meta http-equiv="Content-Type" content="text/html; charset=windows-1251" /&gt;<br></br>   &lt;meta http-equiv="pragma" content="no-cache" /&gt;<br></br>   &lt;meta http-equiv="expires" content="Sun, 10 Oct 2010 10:09:00 GMT+3" /&gt;<br></br>   &lt;meta name="author" content="Автор" /&gt;<br></br>   &lt;meta name="description" content="Использование элемента META для индексации сайта в поисковых системах" /&gt;<br></br>   &lt;meta name="document-state" content="Dynamic" /&gt;<br></br>   &lt;meta name="keywords" content="тег, мета, индексация, поиск" lang="ru" /&gt;<br></br>   &lt;meta name="keywords" content="tags, meta, index, search" lang="en" /&gt;<br></br>   &lt;meta name="Resource-Type" content="Document" /&gt;<br></br>   &lt;meta name="Revisit" content="2" /&gt;<br></br>   &lt;meta name="Robots" content="noindex,follow" /&gt;<br></br>   &lt;meta name="URL" content="http:\\test.test" /&gt;<br></br>   &lt;/head&gt;<br></br>   &lt;/html&gt;<br></br><br></br>   В примере из листинга 1.5 задано много свойств метаданных. Рассмотрим подробнее их действие.<br></br>   Параметр author задает имя автора. Если владельцем сайта является компания, то вместо author используется параметр copyright, а в качестве значения атрибута content нужно задать имя компании. Можно указать язык, на котором записано значение параметра content. Для этого используется атрибут lang.<br></br>   Свойство description задает описание документа. Текст, заданный для этого параметра, будет выводиться в качестве описания вашей страницы, отображаемого поисковиком в результатах поиска. Понятно, что этот параметр надо задавать очень аккуратно, потому что именно по этой фразе пользователь будет решать, имеет ли смысл посещение вашей страницы.<br></br>   Значение dynamic свойства document-state сообщает роботам, что страницу надо будет индексировать при следующем проходе, потому что ее содержимое может поменяться.<br></br>   Дальше два раза задаются ключевые слова свойства keywords: первый раз на русском языке, второй – на английском. При этом язык, на котором написаны ключевые слова, задается с помощью атрибута lang.<br></br>   Эффективность сайта напрямую зависит от того, насколько адекватно он отображается в поисковых системах, а это во многом определяется хорошо подобранными ключевыми словами.<br></br>   В качестве ключевых нужно использовать слова, имеющие прямое отношение к тексту, расположенному на странице. Это значит, что для каждой страницы вашего сайта надо составлять свой список ключевых слов так, чтобы они наилучшим образом отражали ее содержимое.<br></br>   Не стоит повторять ключевые слова по нескольку раз. Если используете словосочетания, не применяйте в них союзы и предлоги, так как они не несут полезной смысловой нагрузки, а только занимают место. Обычно поисковые роботы распознают первые 200–250 символов, определенных в параметре keyword. Порядок слов зависит от их важности, наиболее важные слова следует располагать в начале списка.<br></br>   При подборе ключевых слов постарайтесь предположить, какие сочетания и слова будет использовать пользователь при поиске страницы вашей тематики, и используйте в ключевых словах именно их. Для разных страниц сайта, даже если их тематика одинакова, старайтесь использовать разные сочетания ключевых слов, тогда шанс, что пользователь найдет именно ваш сайт, повысится.<br></br>   Однако помните, что сейчас поисковые системы ведут поиск не только по ключевым словам – зачастую роботы просматривают всю страницу, чтобы определить ее тематику. Старайтесь создавать страницы, в которых ключевые слова соответствуют содержанию, тогда у вас будет шанс оказаться в первых рядах при поиске.<br></br>   Параметр resource-type сообщает поисковому роботу тип страницы и применяется для больших сайтов, где много страниц различного назначения. Страница индексируется, только если в качестве значения resource-type задано document.<br></br>   Рассмотрим параметр revisit. Он говорит, что поисковый робот должен вернуться для переиндексации сайта через два дня. Этот параметр надо задавать, если вы регулярно обновляете содержимое страниц, что поспособствует хранению в поисковых системах актуальной информации о вашем сайте.<br></br>   Параметр robots дает роботам некоторые управляющие команды. В случае из примера он указывает на то, что текущую страницу индексировать не надо, однако нужно пройти по ссылкам на странице и проиндексировать остальную часть сайта.<br></br>   В табл. 1.5 представлены команды, которые можно использовать для управления роботами.<br></br><h5 class="subtitle"><b>Таблица 1.5.</b> Значения атрибута content для свойства robots</h5><div style="text-align: center;"><img src="i_008.png" alt=""></img></div>   Встретив строку URL, робот прекратит индексацию текущей страницы и перейдет на страницу с адресом test.ru.<br></br>   Из всего, что рассмотрено выше, становится понятна важность элемента META, он отвечает за многие параметры страницы. Далеко не все его возможности будут необходимы постоянно, однако всегда нужно помнить о том, что вы можете сделать с его помощью.<br></br>   Вы должны знать, что без возможностей элемента META для раскрутки сайта в поисковых системах не обойтись, но они не спасут, если сайт не будет соответствовать ожиданиям посетителей. Поэтому пользуйтесь ими в качестве дополнения к качественно сделанному сайту.<br></br></div><h3 id="idm139732209546960">Элемент STYLE
</h3><div style="text-align: justify" class="hsection3">   Внутри этого элемента задаются стили, используемые на странице. Таких элементов внутри заголовка страницы может быть несколько. Элемент STYLE поддерживает знакомые вам атрибуты lang и title, а также новые атрибуты type и media. Атрибут type указывает, какой язык задания стилей применяется в данном документе, а атрибут media определяет, на каком устройстве предполагается воспроизводить данный HTML-документ.<br></br>   Для задания стилей в документе HTML 4.01 применяется язык CSS, который мы будем подробно рассматривать в гл. 7. Здесь же мы немного познакомим вас с возможностями этого языка, чтобы вы поняли их достоинства. Они настолько велики, что консорциум W3C отказался от использования атрибутов форматирования содержимого HTML-документов в элементах, применяемых для разметки текста, например задающих шрифт, его начертание и прочие характеристики. Все эти методы признаны устаревшими, на их смену пришли средства CSS.<br></br>   Каскадные таблицы стилей (CSS) используют, чтобы максимально отделить HTML-код страницы от ее оформления. Иными словами, внутри таблицы описано оформление различных элементов, а в HTML-коде – только применяемый стиль. Это очень удобный метод – вы можете менять оформление страницы, цвет фона, шрифт, не перебирая огромное количество команд HTML-кода, а просто заменив его в таблице стилей.<br></br>   Элемент STYLE позволяет реализовать возможности CSS в документе без применения внешних источников. Внутри этого элемента можно записывать код форматирования содержимого странички в формате CSS. Чтобы браузер знал формат кода, атрибуту type элемента STYLE присваивается значение text/css, сообщающее браузеру о применении средств CSS. Вот пример задания CSS-стиля:<br></br>   &lt;style type="text/css"&gt;<br></br>   p.style {<br></br>   color:#CC0000;<br></br>   background:#9999CC;<br></br>   word-spacing:20px;<br></br>   }<br></br>   Здесь запись p.style указывает, что для элемента P, создающего абзац, определяется стиль под названием style, который определяет для текста внутри абзаца цвет шрифта (color: #CC0000), фона (background: #9999CC) и расстояние между словами (word-spacing:2 0px).<br></br>   Чтобы подключить к элементу какой-либо стиль, нужно использовать атрибут class и в качестве его значения установить название стиля, который необходимо применить к этому элементу:<br></br>   &lt;p class="style"&gt;<br></br>   Текст со стилем style<br></br>   &lt;/p&gt;<br></br>   Таким образом, используя язык CSS и элемент STYLE, можно создать стили для конкретного элемента или общий стиль, который будет применим к любому элементу, а далее просто ссылаться на этот стиль в процессе разметки документа.<br></br>   Более того, с помощью элемента STYLE можно задать разные стили для вывода на экран и для вывода на печать. Это полезно, если в качестве фона вы используете темные тона или рисунок. Совершенно не обязательно оставлять подобное декорирование документа при выводе на печать, тем более что это потребует больше краски от принтера. Для этого нужно использовать атрибут media.<br></br>   Значения атрибута media таковы:<br></br>   • print – стили для вывода на печать;<br></br>   • screen – стили для вывода на экран;<br></br>   • all – стили для вывода на любое устройство.<br></br>   На примере кода из листинга 1.6 рассмотрим основы синтаксиса CCS.<br></br><h5 class="subtitle"><b>Листинг 1.6.</b> Использование стилей</h5>   &lt;!DOCTYPE HTML PUBLIC «-//W3C//DTD HTML 4.01 Transitional//EN»<br></br>   "http://www.w3.org/TR/html4/loose.dtd"&gt;<br></br>   &lt;html&gt;<br></br>   &lt;head&gt;<br></br>   &lt;meta http-equiv="Content-Type" content="text/html; charset=windows-1251" /&gt;<br></br>   &lt;style type="text/css" media="screen" &gt;<br></br>   p.style {<br></br>   color:#CC0000;<br></br>   background:#9999CC;<br></br>   word-spacing:20px;<br></br>   }<br></br>   .style2 {<br></br>   color:#66FFFF;<br></br>   background:#990000;<br></br>   word-spacing:10px;<br></br>   }<br></br>   &lt;/style&gt;<br></br>   &lt;style type="text/css" media="print" &gt;<br></br>   p.style {<br></br>   color:#000000;<br></br>   background:#FFFFFF;<br></br>   word-spacing:20px;<br></br>   }<br></br>   .style2 {<br></br>   color:#000000;<br></br>   background:#FFFFFF;<br></br>   word-spacing:10px;<br></br>   }<br></br>   &lt;/style&gt;<br></br>   &lt;title&gt;Использование стилей&lt;/title&gt;<br></br>   &lt;/head&gt;<br></br>   &lt;body&gt;<br></br>   &lt;p class="style"&gt;<br></br>   Текст со стилем style<br></br>   &lt;/p&gt;<br></br>   &lt;p class="style2"&gt;<br></br>   Текст со стилем style2<br></br>   &lt;/p&gt;<br></br>   &lt;table border="1" &gt;<br></br>   &lt;tr&gt;<br></br>   &lt;td class="style2"&gt;<br></br>   Для ячейки применен стиль style2<br></br>   &lt;/td&gt;<br></br>   &lt;/tr&gt;<br></br>   &lt;/table&gt;<br></br>   &lt;/body&gt;<br></br>   &lt;/html&gt;<br></br>   В примере создано два стиля: style можно применять только для элемента P (для обозначения этого перед названием стиля стоит название элемента), style2 – для любого объекта. В листинге 1.6 стиль style2 применен еще и для ячейки таблицы.<br></br>   Результат обработки листинга 1.6 представлен на рис. 1.3.<br></br><div class="wrap_pict"><div style="text-align: center;"><img src="i_009.png" alt=""></img></div>   <b>Рис. 1.3.</b> Использование стилей<br></br></div><br></br>   Для вывода на печать будет использован черный шрифт с белым фоном. Этим мы сэкономим чернила пользователей.<br></br><br></br><blockquote><div>   <b>Совет</b><br></br>
   На странице можно делать ссылки на отображение документа в формате для вывода на печать. Это даст возможность пользователю определить, устраивает ли его установленный формат вывода.<br></br>
</div></blockquote>   Есть еще один способ применения к элементу стиля: встроить CSS-код непосредственно в элемент разметки в виде значения атрибута style. Такой атрибут доступен для всех элементов HTML. В нем в формате CSS через точку с запятой прописываются значения разных свойств элемента. Вот как это выглядит для элемента P:<br></br><br></br>   &lt;p style="color:#CC0000; background:#9999CC; word-spacing:20px;"&gt;<br></br><br></br>   Как видите, CSS-код совпадает с содержимым элемента STYLE из предыдущего примера. В листинге 1.7 представлен пример задания свойств элементов с помощью встраивания CSS-кода в значение атрибута style.<br></br><h5 class="subtitle"><b>Листинг 1.7.</b> Использование атрибута style</h5>   &lt;!DOCTYPE HTML PUBLIC «-//W3C//DTD HTML 4.01 Transitional//EN»<br></br>   "http://www.w3.org/TR/html4/loose.dtd"&gt;<br></br>   &lt;html&gt;<br></br>   &lt;head&gt;<br></br>   &lt;meta http-equiv="Content-Type" content="text/html; charset=windows-1251" /&gt;<br></br>   &lt;title&gt;Использование стилей&lt;/title&gt;<br></br>   &lt;/head&gt;<br></br>   &lt;body&gt;<br></br>   &lt;p style="color:#CC0000; background:#9999CC; word-spacing:20px;"&gt;<br></br>   Текст с атрибутом style="color:#CC0000; background:#9999CC; word-spacing:20px;"<br></br>   &lt;/p&gt;<br></br>   &lt;p style="color:#66FFFF; background:#990000; word-spacing:10px;"&gt;<br></br>   Текст с атрибутом style="color:#66FFFF; background:#990000; word-spacing:10px;"<br></br>   &lt;/p&gt;<br></br>   &lt;table border="1" &gt;<br></br>   &lt;tr&gt;<br></br>   &lt;td style="color:#66FFFF; background:#990000; word-spacing:10px;"&gt;<br></br>   Описание ячейки таблицы с атрибутом style="color:#66FFFF; background: #990000; word-spacing:10px;"<br></br>   &lt;/td&gt;<br></br>   &lt;/tr&gt;<br></br>   &lt;/table&gt;<br></br>   &lt;/body&gt;<br></br>   &lt;/html&gt;<br></br><br></br>   Здесь применены такие же стили, как и в предыдущем примере, но параметры заданы с помощью атрибута style.<br></br>   На рис. 1.4 показан результат обработки кода из листинга 1.7.<br></br><div class="wrap_pict"><div style="text-align: center;"><img src="i_010.png" alt=""></img></div>   <b>Рис. 1.4.</b> Установка стилей с помощью атрибута style<br></br></div><br></br>   Как видно из рисунков, результаты обоих листингов одинаковые по стилям. Однако задавать стили в начале документа удобнее, потому что при необходимости их легко будет найти и исправить.<br></br>   Еще один способ задать стили для документа – записать их в отдельный файл с разрешением CSS. Синтаксис записи в этот файл такой же, как и при использовании элемента STYLE, однако этот способ более универсален.<br></br>   Подключить файл со стилями к документу можно двумя способами. Первый представлен в листинге 1.8 и использует элемент STYLE. Внутри этого элемента нужно записать такую строку: @import URL("nyTb к файлу с таблицами");.<br></br><h5 class="subtitle"><b>Листинг 1.8.</b> Импорт файлов с таблицами стилей</h5>   &lt;!DOCTYPE HTML PUBLIC «-//W3C//DTD HTML 4.01 Transitional//EN»<br></br>   "http://www.w3.org/TR/html4/loose.dtd"&gt;<br></br>   &lt;html&gt;<br></br>   &lt;head&gt;<br></br>   &lt;style&gt;<br></br>   @import URL("test.css");<br></br>   &lt;/style&gt;<br></br>   &lt;meta http-equiv="Content-Type" content="text/html; charset=windows-1251" /&gt;<br></br>   &lt;title&gt;Использование стилей&lt;/title&gt;<br></br>   &lt;/head&gt;<br></br>   &lt;/html&gt;<br></br><br></br>   При такой настройке к элементам нашего документа можно будет применять стили, описанные в файле test.css.<br></br></div><h3 id="idm139732227865936">Элемент LINK
</h3><div style="text-align: justify" class="hsection3">   Использование элемента LINK – это второй способ подключения файла с таблицами стилей к документу. Элемент не требует наличия закрывающего тега. Его возможности намного шире, нежели просто подключение таблиц стилей. В общем, элемент LINK определяет отношения между текущей страницей и другими документами. Поскольку отношения могут быть разными, то и элементов LINK на странице может быть много.<br></br>   Основным для этого элемента является атрибут href; его значение – это путь к объекту, для которого описывается тип связи. Этот атрибут является обязательным, что вполне логично – странно было бы устанавливать связи с объектом, не указав, где он расположен.<br></br>   Другим атрибутом является type, он задает параметры объекта, с которым определяется связь. При связывании таблиц стилей этот атрибут принимает значение text/css.<br></br>   У элемента LINK есть два взаимодополняющих атрибута: rel и rev. Первый определяет отношение между текущим документом и другим, а второй – отношение другого документа к текущему. Эти атрибуты могут принимать различные фиксированные значения, которые обозначают типы отношений.<br></br>   В листинге 1.9 представлены примеры использования элемента LINK.<br></br><h5 class="subtitle"><b>Листинг 1.9.</b> Использование элемента LINK</h5>   &lt;!DOCTYPE HTML PUBLIC «-//W3C//DTD HTML 4.01 Transitional//EN»<br></br>   "http://www.w3.org/TR/html4/loose.dtd"&gt;<br></br>   &lt;html&gt;<br></br>   &lt;head&gt;<br></br>   &lt;link href="test.css" rel="stylesheet" type="text/css" /&gt;<br></br>   &lt;link href="copyrihgt.html" rel="copyright" /&gt;<br></br>   &lt;link href="help.html" rev="help" /&gt;<br></br>   &lt;meta http-equiv="Content-Type" content="text/html; charset=windows-1251" /&gt;<br></br>   &lt;title&gt;Использование элемента LINK&lt;/title&gt;<br></br>   &lt;/head&gt;<br></br>   &lt;/html&gt;<br></br>   В примере из листинга 1.9 элемент LINK использован для прикрепления к текущему документу таблиц стилей, для указания файла, содержащего информацию об авторском праве на данный документ, и для определения файла, в котором хранится справочная информация.<br></br>   В табл. 1.6 приведены некоторые возможные значения атрибута rel. За более подробной информацией стоит обратиться к специальной литературе или к спецификации на сайте W3C.<br></br><h5 class="subtitle"><b>Таблица 1.6.</b> Некоторые значения атрибута rel</h5><div style="text-align: center;"><img src="i_011.png" alt=""></img></div><br></br><blockquote><div>   <b>Совет</b><br></br>
   Использование значения alternate атрибута rel в сочетании с другими атрибутами hreflang и charset, которые задают в элементе LINK язык и кодировку документа, подскажет браузеру, где искать альтернативные версии текущего документа, написанные на других языках.<br></br>
</div></blockquote>   Мы разобрались с элементом LINK и выяснили его возможности относительно работы с различными документами и в частности с таблицами стилей. Теперь рассмотрим элемент, который пригодится при работе с другими важными объектами создания сайтов.<br></br></div><h3 id="idm139732227876944">Элемент SCRIPT
</h3><div style="text-align: justify" class="hsection3">   Элемент SCRIPT позволяет присоединять к документу сценарии. Он требует наличия закрывающего тега, при этом текст сценария может располагаться либо в этом элементе, либо во внешнем файле. Если текст сценария расположен во внешнем файле, то он подключается с помощью атрибутов элемента SCRIPT.<br></br>   Рассмотрим атрибуты этого элемента. Основным можно считать атрибут type, который задает язык сценария, присоединяемого к странице. Если этот атрибут задан, он отменяет установленный по умолчанию язык сценариев. На случай подключения внешнего файла со сценариями у элемента SCRIPT есть атрибут src, в качестве значения которого используют место расположения файла со сценариями. Это удобно, если для различных страниц нужно использовать одинаковые сценарии.<br></br>   У элемента SCRIPT есть еще один вспомогательный атрибут – defer, который запрещает загружать сценарий до окончания полной загрузки страницы.<br></br>   В листинге 1.10 показаны разные примеры подключения сценариев к HTML-документу.<br></br><h5 class="subtitle"><b>Листинг 1.10.</b> Использование элемента SCRIPT</h5>   &lt;!DOCTYPE HTML PUBLIC «-//W3C//DTD HTML 4.01 Transitional//EN»<br></br>   "http://www.w3.org/TR/html4/loose.dtd"&gt;<br></br>   &lt;html&gt;<br></br>   &lt;head&gt;<br></br>   &lt;script defer="defer" type="text/javascript"&gt;<br></br>   &lt;!–текст сценария–&gt;<br></br>   &lt;/script&gt;<br></br>   &lt;script type="text/javascript" src="test.js"&gt;<br></br>   &lt;/script&gt;<br></br>   &lt;title&gt;Использование элемента SCRIPT&lt;/title&gt;<br></br>   &lt;/head&gt;<br></br>   &lt;/html&gt;<br></br>   Количество подключаемых сценариев не ограничено, однако помните, что на их обработку требуется время, так что не стоит загружать браузер больше необходимого.<br></br></div><h3 id="idm139732204136272">Элемент BASE
</h3><div style="text-align: justify" class="hsection3">   Если внутри документа создаются относительные ссылки на файлы, то может возникнуть ситуация, когда текущий документ перемещен и файлы становятся недоступны. Но в языке HTML есть инструменты для решения этой проблемы.<br></br>   Элемент BASE служит для того, чтобы задать базовый адрес, относительно которого вычисляются все относительные адреса. Это поможет избежать проблем в случае переноса вашей страницы в другое место. Иначе говоря, все ссылки будут работать, как и прежде.<br></br><blockquote><div>   <b>Примечание</b><br></br>
   Абсолютный адрес документа использует полный путь к нему, начиная с корневого каталога. Например, C:\Test\test.jpg для файлов на вашем компьютере или http:// <a href="http://www.test.test/mytests/test.html">www.test.test/mytests/test.html</a> для документов, расположенных в Интернете. Если путь к файлу очень длинный и неудобно каждый раз вводить его, то можно задать относительный адрес. Например, чтобы из документа, находящегося по адресу C:\Test\MyTests\test.html, получить доступ к документу C:\Test\test.jpg, достаточно в нем набрать. \test.jpg, при этом знак «.» означает переход на более высокий уровень иерархии каталогов.<br></br>
</div></blockquote>   Основным атрибутом элемента BASE является href. В качестве его значения используется адрес базовой папки, относительно которой и будут вычисляться относительные адреса.<br></br>   Еще одним полезным атрибутом этого тега является target. Он предназначен для работы с фреймами, то есть с HTML-документами, представляющими собой набор окон, каждое из которых является дочерним к основному, родительскому окну документа. Атрибут target определяет, в какое окно будут загружаться страницы по ссылкам, встречающимся в документе. Этот атрибут может принимать четыре значения:<br></br>   • _top – отменяет все фреймы и загружает страницу в полное окно браузера;<br></br>   • _blanc – загружает страницу в новое окно;<br></br>   • _self – загружает страницу в текущее окно;<br></br>   • _parent – загружает страницу во фрейм-родитель.<br></br>   При этом можно использовать элемент BASE с указанием только одного из атрибутов.<br></br>   В листинге 1.11 представлен пример использования элемента BASE.<br></br><h5 class="subtitle"><b>Листинг 1.11.</b> Использование элемента BASE</h5>   &lt;!DOCTYPE HTML PUBLIC «-//W3C//DTD HTML 4.01 Transitional//EN»<br></br>   "http://www.w3.org/TR/html4/loose.dtd"&gt;<br></br>   &lt;html&gt;<br></br>   &lt;head&gt;<br></br>   &lt;base href="http://www.test.test/" target="_blank" /&gt;<br></br>   &lt;meta http-equiv="Content-Type" content="text/html; charset=windows-1251" /&gt;<br></br>   &lt;title&gt;Использование элемента BASE&lt;/title&gt;<br></br>   &lt;/head&gt;<br></br>   &lt;/html&gt;<br></br>   В примере из листинга 1.11 все относительные адреса будут браться от адреса <a href="http://www.test.test/">http://www.test.test/</a>, то есть если в тексте документа будет строка с адресом ../IMG/test.jpg, то браузер будет ее воспринимать как <a href="http://www.test.test/IMG/test.jpg">http://www.test.test/IMG/test.jpg</a>. При этом все ссылки будут открываться в новых окнах, если среди параметров самой ссылки не указать другой вариант.<br></br>   Мы разобрались со всеми элементами, которые можно использовать внутри элемента HEAD, и от заголовка документа пора перейти к его телу.<br></br></div><h3 id="idm139732204115536">Элемент BODY
</h3><div style="text-align: justify" class="hsection3">   Внутри элемента BODY располагается сам документ: весь текст, находящийся между открывающим тегом &lt;BODY&gt; и закрывающим тегом &lt;/BODY&gt;, будет отображаться браузером. Все элементы, отвечающие за форматирование документа, помещают внутрь элемента BODY.<br></br>   Атрибуты элемента BODY применяются для того, чтобы установить общие для всего документа свойства, и в этом отношении возможности данного элемента достаточно большие: можно задать цвет ссылок, параметры фона и т. п.<br></br>   Сначала рассмотрим атрибуты элемента BODY, управляющие отображением ссылок. Для удобства посетителей страницы надо задавать разные цвета для посещенных, непосещенных и активных ссылок, при этом нужно следить, чтобы они не сливались с цветом фона страницы, потому что это будет неудобно посетителям.<br></br>   За цвет ссылок отвечают следующие атрибуты элемента BODY:<br></br>   • alink – задает цвет активной ссылки;<br></br>   • vlink – определяет цвет посещенной ссылки;<br></br>   • link – устанавливает цвет непосещенной ссылки.<br></br>   Цвета ссылок можно задать в HEX-формате или ключевыми словами. Ключевые слова имеет смысл использовать, если вы хотите применить стандартный цвет. Ну а если вы собираетесь устанавливать нестандартные цвета, придется воспользоваться HEX-форматом.<br></br>   В примере из листинга 1.12 представлены оба варианта записи.<br></br><h5 class="subtitle"><b>Листинг 1.12.</b> Цвет ссылок</h5>   &lt;!DOCTYPE HTML PUBLIC «-//W3C//DTD HTML 4.01 Transitional//EN»<br></br>   "http://www.w3.org/TR/html4/loose.dtd"&gt;<br></br>   &lt;html&gt;<br></br>   &lt;head&gt;<br></br>   &lt;base href="http://www.test.test/" target="_blank" /&gt;<br></br>   &lt;meta http-equiv="Content-Type" content="text/html; charset=windows-1251" /&gt;<br></br>   &lt;title&gt;Использование элемента BODY&lt;/title&gt;<br></br>   &lt;/head&gt;<br></br>   &lt;body alink="#00FF00" vlink="red" link="#330000"&gt;<br></br>   &lt;/body&gt;<br></br>   &lt;/html&gt;<br></br>   В примере для активной и непосещенной ссылки цвет задан с помощью цифр и букв: они определяют код цвета в шестнадцатеричном формате и записываются в качестве значения соответствующего атрибута после знака #. Для посещенной ссылки цвет задан ключевым словом. Использовать ключевые слова просто. В качестве обозначения цвета с их помощью применяются стандартные названия цветов на английском языке. Указывайте простые названия цветов вроде blue, red, black и не ошибетесь.<br></br>   Что касается записи цвета в цифрах, то код для нужного цвета можно определить, используя любой графический редактор.<br></br>   Элемент BODY предоставляет большие возможности для управления фоном страницы. Рассмотрим атрибуты, отвечающие за это.<br></br>   Для начала надо задать фоновый цвет страницы. Это делается с помощью атрибута bgcolor, значение которого определяет цвет фона. Потом нужно указать фоновый рисунок страницы с помощью атрибута background, значение которого представляет собой адрес файла с рисунком для фона. При этом старайтесь ставить цвет фона, близкий к цветовой гамме фонового рисунка. Это пригодится, если у пользователя не загрузится фоновый рисунок. Когда цвет фона близок к цвету рисунка, не будет дисбаланса в общем виде страницы.<br></br>   Следующий атрибут управляет прокруткой фона и называется bgproperties. Он определяет, будет ли фон прокручиваться вместе с текстом. Этот атрибут принимает всего одно значение fixed, позволяющее зафиксировать фон документа и не прокручивать его вместе с текстом. В противоположном случае нужно просто удалить этот атрибут. При выборе параметров прокрутки фона надо действовать очень осторожно и следить за тем, чтобы при прокрутке не терялась читаемость текста.<br></br>   В листинге 1.13 представлен пример использования атрибутов элемента BODY, отвечающих за фон документа.<br></br><h5 class="subtitle"><b>Листинг 1.13.</b> Параметры фона</h5>   &lt;!DOCTYPE HTML PUBLIC «-//W3C//DTD HTML 4.01 Transitional//EN»<br></br>   "http://www.w3.org/TR/html4/loose.dtd"&gt;<br></br>   &lt;head&gt;<br></br>   &lt;base href="http://www.test.test/" target="_blank" /&gt;<br></br>   &lt;meta http-equiv="Content-Type" content="text/html; charset=windows-1251" /&gt;<br></br>   &lt;title&gt;Использование элемента BODY&lt;/title&gt;<br></br>   &lt;/head&gt;<br></br>   &lt;body background="test.jpg" bgcolor="#0033CC" bgproperties="fixed"&gt;<br></br>   &lt;/body&gt;<br></br>   &lt;/html&gt;<br></br>   В примере из листинга 1.13 файл test. jpg оформлен в синих тонах, поэтому и цвет фона взят из синей гаммы. Прокрутка фона вместе с текстом запрещена.<br></br>   После того как мы разобрались с фоном, можно задать положение содержимого страницы относительно границ окна браузера.<br></br>   За отступ от границ окна отвечают следующие атрибуты элемента BODY:<br></br>   • bottommargin – определяет расстояние от нижнего края окна браузера до содержимого страницы;<br></br>   • leftmargin – указывает расстояние от левого края окна браузера до содержимого страницы;<br></br>   • topmargin – задает расстояние от верхнего края окна браузера до содержимого страницы.<br></br>   Расстояние для всех атрибутов устанавливается в пикселах.<br></br>   В листинге 1.14 приведен пример указания расстояния до содержимого страницы с помощью атрибутов элемента BODY.<br></br><h5 class="subtitle"><b>Листинг 1.14.</b> Установка расстояния от границ окна до содержимого страницы</h5>   &lt;!DOCTYPE HTML PUBLIC «-//W3C//DTD HTML 4.01 Transitional//EN»<br></br>   "http://www.w3.org/TR/html4/loose.dtd"&gt;<br></br>   &lt;head&gt;<br></br>   &lt;base href="http://www.test.test/" target="_blank" /&gt;<br></br>   &lt;meta http-equiv="Content-Type" content="text/html; charset=windows-1251" /&gt;<br></br>   &lt;title&gt;Использование элемента BODY&lt;/title&gt;<br></br>   &lt;/head&gt;<br></br>   &lt;body topmargin="10" leftmargin="20" bottommargin="10"&gt;<br></br>   &lt;/body&gt;<br></br>   &lt;/html&gt;<br></br>   В примере расстояние сверху и снизу будет по 10 пикселов, а слева – 20 пикселов.<br></br>   У элемента BODY есть еще два атрибута, которые могут нам пригодиться. Атрибут text отвечает за цвет текста в документе. Когда задаете цвет текста, следите, чтобы он не сливался с фоном страницы.<br></br>   Атрибут scroll определяет, будет ли в окне документа вертикальная полоса прокрутки. У него всего два значения: yes и no, обозначающие разрешить и запретить прокрутку соответственно. На самом деле запрещать прокрутку не стоит, потому что документ, который у вас на экране виден полностью без проблем, у пользователя с низким разрешением монитора может не поместиться на экране. В итоге без полосы прокрутки он просто не увидит часть документа.<br></br>   Мы рассмотрели элемент BODY, его возможности и функции. Все параметры, определяемые в этом элементе, влияют на общий вид документа.<br></br>   Когда вы создаете большие сайты, то со временем можете забыть, что именно делает та или иная часть кода страницы. Комментарии помогут избежать этого.<br></br></div><h3 id="idm139732204092112">Комментарии
</h3><div style="text-align: justify" class="hsection3">   Комментарии могут располагаться в любом месте страницы, потому что не отображаются браузером. В качестве текста комментариев можно задавать пояснения к коду страницы. Это удобно, если код большой или с текстом работают несколько человек.<br></br>   Комментарии заключаются в тег: &lt;! – текст комментария – &gt;. Текст, расположенный внутри этого тега, не будет отображаться.<br></br></div></div><h2 id="idm139732204093520">Резюме
</h2><div style="text-align: justify" class="hsection2">   В этой главе вы ознакомились с основами построения HTML-документа и центральными понятиями, используемыми в языке HTML. Большое внимание было уделено метаданным, потому что именно они отвечают за распознавание кодировки страницы и ее индексацию в поисковых системах. Вы также познакомились с основами таблиц стилей и вариантами их подключения к странице.<br></br>   Большая часть главы была посвящена вспомогательным данным, которые позволят сделать ваш сайт доступным для потенциальных пользователей и дадут возможность браузерам корректно его обрабатывать.<br></br></div></div><h1 xmlns="http://www.w3.org/1999/xhtml" id="idm139732204094928" class="master">Глава 2<br></br>
Ввод и оформление текста
</h1><div xmlns="http://www.w3.org/1999/xhtml" style="text-align: justify" class="hsection1"><div style="text-align: justify" class="section2">   2.1. Создание заголовков<br></br>
   2.2. Создание абзацев<br></br>
   2.3. Создание обрывов строк<br></br>
   2.4. Создание списков<br></br>
   2.5. Ссылки<br></br>
   2.6. Форматирование текста<br></br>
   Ввод текстовой информации на сайт осуществляется внутри элемента BODY. Однако чаще всего простое расположение текста внутри элемента BODY неприемлемо, необходимо его оформлять, например разделять на абзацы или создавать заголовки. Для оформления текста HTML предоставляет много возможностей: для любого абзаца или заголовка можно задать уникальный внешний вид. Язык HTML также позволяет создавать списки с маркерами любого типа. Можно менять цвет, размер и шрифт текста. В общем, у создателя сайта есть возможность оформить свой текст очень красочно.<br></br>
   Сначала рассмотрим общие принципы структурного форматирования текста, а затем перейдем непосредственно к управлению его внешним видом. При изучении материала этой главы следует помнить, что в новейшей версии языка XHTML форматировать текстовую информацию предлагается с помощью языка CSS, который мы будем изучать в гл. 7–9. Тем не менее содержимое главы весьма важно для практической работы, поскольку вам еще не раз придется столкнуться с многочисленными веб-страницами, оформленными согласно устаревшим средствам, ведь они применялись много лет и на их основе было создано огромное количество документов.<br></br>
</div><h2 id="idm139732208989904">2.1. Создание заголовков
</h2><div style="text-align: justify" class="hsection2">   Заголовки – важный элемент сайта, они помогают систематизировать текст. В HTML доступно создание заголовков разных уровней, поэтому очень легко выделять смысловые темы и подтемы. Текст, находящийся в заголовках, влияет на индексацию сайта поисковыми системами, так как многие роботы при поиске обращают внимание на содержимое заголовков, имеющихся на сайте.<br></br>   В HTML можно создавать заголовки шести уровней. Самым важным считается заголовок первого уровня, а самым малозначимым – шестого.<br></br>   Заголовки создаются с помощью элементов H1, H2, H3, H4, H5, H6. По умолчанию заголовок самого верхнего уровня выделяется самым крупным шрифтом, и чем ниже уровень заголовка, тем меньше шрифт.<br></br>   Для заголовка любого уровня можно задать выравнивание по горизонтали. Это делается с помощью атрибута align.<br></br>   Значения атрибута align:<br></br>   • left – по левому краю;<br></br>   • right – по правому краю;<br></br>   • center – по центру;<br></br>   • justify – по ширине (только для заголовков длиннее строки).<br></br>   Для заголовков можно задать атрибут title, значение которого – текст всплывающей подсказки, появляющейся при наведении указателя мыши на заголовок.<br></br>   В листинге 2.1 представлен пример кода для создания разных типов заголовков и для их различного выравнивания.<br></br><h5 class="subtitle"><b>Листинг 2.1.</b> Заголовки</h5>   &lt;html&gt;<br></br>   &lt;head&gt;<br></br>   &lt;title&gt;Создание заголовков&lt;/title&gt;<br></br>   &lt;/head&gt;<br></br>   &lt;body&gt;<br></br>   &lt;h1 align="center"&gt;Заголовок 1 уровня&lt;/h1&gt;<br></br>   &lt;h2 align="justify"&gt;Заголовок 2 уровня&lt;/h2&gt;<br></br>   &lt;h3 align="left"&gt;Заголовок 3 уровня&lt;/h3&gt;<br></br>   &lt;h4 align="right"&gt;Заголовок 4 уровня&lt;/h4&gt;<br></br>   &lt;h5&gt;Заголовок 5 уровня&lt;/h5&gt;<br></br>   &lt;h6 title="Заголовок 6 уровня"&gt;Заголовок 6 уровня&lt;/h6&gt;<br></br>   &lt;/body&gt;<br></br>   &lt;/html&gt;<br></br>   На рис. 2.1 показан результат обработки листинга 2.1 браузером.<br></br><div class="wrap_pict"><div style="text-align: center;"><img src="i_012.png" alt=""></img></div>   <b>Рис. 2.1.</b> Вид заголовков<br></br></div><br></br>   На рис. 2.1 видно различие между заголовками разного размера. В принципе, придать тексту подобный вид можно с помощью управления обычным текстом, но, поскольку поисковики воспринимают текст заголовков как важный, имеет смысл для выделения важной информации использовать именно элементы заголовков.<br></br>   При отображении заголовок всегда начинается с новой строки, а после него всегда идет новая строка – это отделяет заголовок от остального текста.<br></br>   Для управления другими моментами отображения заголовков, например цветом или шрифтом, используется CSS. Поэтому в элементах H1-H6 разрешено использовать атрибуты style и class, которые подключают стили.<br></br>   После того как заголовки созданы, можно добавить к ним немного обычного текста, который нужно логически разбить на абзацы.<br></br></div><h2 id="idm139732209003472">2.2. Создание абзацев
</h2><div style="text-align: justify" class="hsection2">   Абзацы, как известно, делят текст на логические части и на письме выделяются отступом от края листа. В HTML абзацы отделяются друг от друга расстоянием в одну строку.<br></br>   Для организации абзацев в HTML предусмотрен элемент P, который подразумевает наличие закрывающего тега. Элемент P, наверное, является самым востребованным – наибольшее количество текста, представленного в Интернете, находится внутри элемента P.<br></br>   Для управления внешним видом текста абзацев в основном используются таблицы стилей, однако небольшое редактирование можно выполнить и с помощью HTML.<br></br>   Для элемента P можно задать атрибут, определяющий выравнивание. Он называется align и может принимать следующие значения.<br></br>   • center – выравнивание по центру. При таком виде выравнивания текст прижимается к центру экрана, образуя рваные края. Не стоит использовать подобное выравнивание для текста большого объема, потому что его будет неудобно читать.<br></br>   • left – выравнивание по левому краю. Текст прижимается к левому краю окна браузера, а справа остаются неровные края. Это самый обычный вид выравнивания, текст такого вида достаточно легок для чтения.<br></br>   • right – выравнивание по правому краю. Текст прижимается к правому краю экрана, образуя неровные края слева. Такое выравнивание подойдет небольшим эпиграфам. Читать большой текст, выровненный таким образом, будет неудобно.<br></br>   • justify – выравнивание по ширине. Пробелы между словами автоматически регулируются таким образом, чтобы текст прижимался к левому и правому краям окна. Этот вид выравнивания является наилучшим для больших объемов текста, отсутствие рваных краев слева и справа придает ему аккуратный вид.<br></br>   Кроме выравнивания, для абзаца можно задать всплывающую подсказку, которая появляется при наведении указателя мыши на текст. Подсказка создается с помощью атрибута title, значением которого является текст подсказки.<br></br>   В листинге 2.2 приведен пример создания абзацев с разным выравниванием и всплывающими подсказками.<br></br><h5 class="subtitle"><b>Листинг 2.2.</b> Создание абзацев</h5>   &lt;html&gt;<br></br>   &lt;head&gt;<br></br>   &lt;title&gt;Абзацы&lt;/title&gt;<br></br>   &lt;/head&gt;<br></br>   &lt;body&gt;<br></br>   &lt;p align="center" title="Абзац, выровненный по центру"&gt;Это небольшой заголовочный абзац, выровненный по центру&lt;/p&gt;<br></br>   &lt;p align="right" title="Абзац, выровненный по правому краю"&gt;Здесь эпиграф&lt;/p&gt;<br></br>   &lt;p align="left" title="Абзац, выровненный по левому краю"&gt;Этот абзац с текстом выровнен по левому краю, поэтому края с правого края будут рваными&lt;/p&gt;<br></br>   &lt;p align="justify" title="Абзац, выровненный по ширине"&gt;Этот абзац с основным текстом, выровненный по ширине. Края этого абзаца прилегают к краям окна браузера&lt;/p&gt;<br></br>   &lt;/body&gt;<br></br>   &lt;/html&gt;<br></br>   На рис. 2.2 показан результат обработки листинга 2.2, где видно различие между абзацами с разным выравниванием.<br></br><div class="wrap_pict"><div style="text-align: center;"><img src="i_013.png" alt=""></img></div>   <b>Рис. 2.2.</b> Оформление абзацев<br></br></div><br></br>   Для дальнейшего оформления текста абзацев используют каскадные таблицы стилей, для этого элемент P допускает использование атрибутов style и class.<br></br></div><h2 id="idm139732208981840">2.3. Создание обрывов строк
</h2><div style="text-align: justify" class="hsection2">   С оформлением абзаца все понятно. Что же делать, если возникает необходимость оборвать строку, не закрывая абзац, например в том же эпиграфе для записи стихов?<br></br>   В HTML есть возможность перенести текст на новую строку, не заканчивая абзац. Обычно браузер переносит слова в зависимости от размера окна, и возможность самостоятельно определить место переноса может пригодиться при записи стихов или для отделения различных элементов друг от друга.<br></br>   Для переноса текста на новую строку служит элемент BR, он не требует закрывающего тега, однако рекомендуется записывать его открывающий тег как &lt;BR /&gt;, чтобы все программы отображали его корректно.<br></br>   В листинге 2.3 представлен пример кода для принудительного переноса строки.<br></br><h5 class="subtitle"><b>Листинг 2.3.</b> Обрыв строки</h5>   &lt;html&gt;<br></br>   &lt;head&gt;<br></br>   &lt;title&gt;Обрыв строки&lt;/title&gt;<br></br>   &lt;/head&gt;<br></br>   &lt;body&gt;<br></br>   Наша Таня громко плачет,&lt;br /&gt;<br></br>   Уронила в речку мячик.&lt;br /&gt;<br></br>   &lt;/body&gt;<br></br>   &lt;/html&gt;<br></br>   На рис. 2.3 представлен результат обработки браузером кода из листинга 2.3.<br></br><div class="wrap_pict"><div style="text-align: center;"><img src="i_014.png" alt=""></img></div>   <b>Рис. 2.3.</b> Обрыв строки<br></br></div><br></br>   Из рис. 2.3 видно, что при использовании элемента BR пустая строка после переноса не добавляется.<br></br>   Есть еще один вариант применения элемента BR. Его используют, когда нужно задать обтекание текстом таблицы, изображения или любого другого плавающего элемента страницы (то есть элемента, для которого задан атрибут align).<br></br>   Для этого применяют атрибут clear элемента BR. Атрибут может принимать следующие значения:<br></br>   • all – запрещает обтекание элемента с двух сторон;<br></br>   • left – запрещает обтекание с левой стороны плавающего объекта, расположенного после элемента BR;<br></br>   • right – запрещает обтекание с правой стороны плавающего объекта, расположенного после элемента BR;<br></br>   • none – отменяет свойство.<br></br>   Если обтекание запрещено, то текст, следующий за элементом BR, будет отображаться на строке после плавающего объекта.<br></br>   Кроме обязательного переноса строки, иногда нужно использовать обратное действие, то есть гарантировать, что текст не будет перенесен на новую строку ни в коем случае. Для создания таких неразрывных строк предназначен элемент NOBR, который требует наличия закрывающего тега. Текст, расположенный внутри элемента, будет размещаться в одной строке. При необходимости браузер создаст горизонтальную полосу прокрутки.<br></br>   Иногда строка может оказаться очень длинной и неудобной для чтения, поэтому внутри элемента NOBR можно использовать элемент WBR, который указывает место для возможного переноса строки.<br></br>   В листинге 2.4 представлен пример использования элементов NOBR и WBR.<br></br><h5 class="subtitle"><b>Листинг 2.4.</b> Запрет переноса строки</h5>   &lt;html&gt;<br></br>   &lt;head&gt;<br></br>   &lt;meta http-equiv="Content-Type" content="text/html; charset=windows-1251" /&gt;<br></br>   &lt;title&gt;Обрыв строки&lt;/title&gt;<br></br>   &lt;/head&gt;<br></br>   &lt;body&gt;<br></br>   &lt;nobr&gt;Это очень важная строка, ее ни в коем случае нельзя переносить на другую строку, однако в этом месте &lt;wbr&gt;возможно сделать перенос.&lt;/nobr&gt;<br></br>   &lt;/body&gt;<br></br>   &lt;/html&gt;<br></br><br></br>   На рис. 2.4 показано отображение в браузере кода из листинга 2.4.<br></br><div class="wrap_pict"><div style="text-align: center;"><img src="i_015.png" alt=""></img></div>   <b>Рис. 2.4.</b> Запрет переносов<br></br></div><br></br>   Как видно на рис. 2.4, браузер создал горизонтальную полосу прокрутки и перенес строку в том месте, где было разрешено.<br></br>   Возможность управлять переносами в браузере позволяет контролировать общий вид страницы, но нужно внимательно следить за тем, как браузер организовал переносы.<br></br></div><h2 id="idm139732188274512">2.4. Создание списков
</h2><div style="text-align: justify" class="hsection2"><div style="text-align: justify" class="section3">   Простые списки можно создать с помощью обрывов страниц, но HTML предлагает для этого лучший инструмент.<br></br>
   Списки – важный инструмент, они применяются для организации и группировки данных. Это может пригодиться при создании карты сайта (то есть его оглавления), описания сложных структур и других подобных объектов.<br></br>
   В HTML можно выделить несколько типов списков:<br></br>
   • маркированный;<br></br>
   • нумерованный;<br></br>
   • список определений.<br></br>
   Они отличаются по типам представления информации.<br></br>
</div><h3 id="idm139732188277968">Маркированный список
</h3><div style="text-align: justify" class="hsection3">   Маркированные списки – это списки, в которых пункты отмечаются с помощью различных символов. Такие списки еще называют ненумерованными, или неупорядоченными, потому что для элементов данного списка последовательность неважна. Эти списки можно использовать для простого перечисления объектов или их свойств.<br></br>   Для создания списков в HTML предусмотрен элемент UL, требующий наличия закрывающего тега. Пункты списка находятся внутри элемента UL. Каждый пункт начинается с элемента LI.<br></br>   У элемента UL есть атрибут type, определяющий вид маркера списка. Он может принимать следующие значения:<br></br>   • circle – создает маркер в виде круга, белого внутри;<br></br>   • square – создает маркер в виде квадрата;<br></br>   • disc – создает маркер в виде круга, закрашенного черным цветом.<br></br>   Маркер можно выбирать любой, на ваш взгляд наиболее соответствующий виду страницы.<br></br>   В листинге <i>2.5</i> представлен пример создания маркированных списков с разными маркерами.<br></br><h5 class="subtitle"><b>Листинг 2.5.</b> Маркированные списки</h5>   &lt;html<br></br>   &lt;head&gt;<br></br>   &lt;title&gt;Списки&lt;/title&gt;<br></br>   &lt;body&gt;<br></br>   &lt;ul type="circle"&gt;<br></br>   &lt;li&gt;Венера&lt;/li&gt;<br></br>   &lt;li&gt;Земля&lt;/li&gt;<br></br>   &lt;li&gt;Юпитер&lt;/li&gt;<br></br>   &lt;li&gt;Марс&lt;/li&gt;<br></br>   &lt;/ul&gt;<br></br>   &lt;ul compact type="square" &gt;<br></br>   &lt;li&gt;Венера&lt;/li&gt;<br></br>   &lt;li&gt;Земля&lt;/li&gt;<br></br>   &lt;li&gt;Юпитер&lt;/li&gt;<br></br>   &lt;li&gt;Марс&lt;/li&gt;<br></br>   &lt;/ul&gt;<br></br>   &lt;ul compact type="disc" &gt;<br></br>   &lt;li&gt;Венера&lt;/li&gt;<br></br>   &lt;li&gt;Земля&lt;/li&gt;<br></br>   &lt;li&gt;Юпитер&lt;/li&gt;<br></br>   &lt;li&gt;Марс&lt;/li&gt;<br></br>   &lt;/ul&gt;<br></br>   &lt;/body&gt;<br></br>   &lt;/html&gt;<br></br>   Результат обработки кода из листинга 2.5 показан на рис. 2.5. Здесь видно, как выглядят разные маркеры списков.<br></br><div class="wrap_pict"><div style="text-align: center;"><img src="i_016.png" alt=""></img></div>   <b>Рис. 2.5.</b> Маркированные списки<br></br></div><br></br>   При создании маркированных списков с помощью элемента LI можно задать вид маркера отдельно для каждого пункта списка.<br></br>   В листинге 2.6 приведен пример создания списка с разными маркерами для различных пунктов.<br></br><h5 class="subtitle"><b>Листинг 2.6.</b> Список с разными маркерами</h5>   &lt;html&gt;<br></br>   &lt;head&gt;<br></br>   &lt;title&gt;Списки&lt;/title&gt;<br></br>   &lt;body&gt;<br></br>   &lt;ul&gt;<br></br>   &lt;li type="circle"&gt;Земля&lt;/li&gt;<br></br>   &lt;li type="circle"&gt;Марс&lt;/li&gt;<br></br>   &lt;li type="square"&gt;Солнце&lt;/li&gt;<br></br>   &lt;li type="circle"&gt;Венера&lt;/li&gt;<br></br>   &lt;li type="disc"&gt;Луна&lt;/li&gt;<br></br>   &lt;/ul&gt;<br></br>   &lt;/body&gt;<br></br>   &lt;/html&gt;<br></br><br></br>   Результат обработки браузером кода из листинга 2.6 представлен на рис. 2.6.<br></br><div class="wrap_pict"><div style="text-align: center;"><img src="i_017.png" alt=""></img></div>   <b>Рис. 2.6.</b> Список с разными маркерами<br></br></div><br></br>   В примере различные маркеры отмечают объекты разных типов.<br></br>   Иногда удобнее создавать свои маркеры для списков, в этом случае внешний вид списков будет намного лучше соответствовать стилю вашего сайта и вашим желаниям.<br></br>   В HTML есть возможность создать список с графическими маркерами. Для этого нужно вместо элемента LI подставить картинку с желаемым изображением. Элемент UL укажет браузеру, что надо сделать отступ, а с помощью элемента BR можно перенести строку.<br></br>   В листинге 2.7 представлен пример создания списка с графическими маркерами.<br></br><h5 class="subtitle"><b>Листинг 2.7.</b> Список с графическими маркерами</h5>   &lt;html&gt;<br></br>   &lt;head&gt;<br></br>   &lt;title&gt;Списки&lt;/title&gt;<br></br>   &lt;body&gt;<br></br>   &lt;ul&gt;<br></br>   &lt;img src="marker.jpg" /&gt;Венера&lt;br /&gt;<br></br>   &lt;img src="marker.jpg" /&gt;Марс&lt;br /&gt;<br></br>   &lt;img src="marker.jpg" /&gt;Земля&lt;br /&gt;<br></br>   &lt;/ul&gt;<br></br>   &lt;/body&gt;<br></br>   &lt;/html&gt;<br></br><br></br>   Результат обработки кода из листинга 2.7 показан на рис. 2.7.<br></br><div class="wrap_pict"><div style="text-align: center;"><img src="i_018.png" alt=""></img></div>   <b>Рис. 2.7.</b> Список с графическими маркерами<br></br></div><br></br>   Теперь можно использовать картинки для создания симпатичных списков, соответствующих стилю вашего сайта.<br></br></div><h3 id="idm139732188244176">Нумерованный список
</h3><div style="text-align: justify" class="hsection3">   Однако использование неупорядоченных списков не всегда допустимо. Что делать, если нужно расписать порядок действий, например рецепт приготовления блюда? Для перечисления ингредиентов можно использовать неупорядоченный список, а для описания порядка действий понадобится пронумерованный список.<br></br>   Нумерованные списки применяются, когда порядок следования пунктов списка имеет большое значение, например при описании алгоритмов или других пошаговых действий. Особенностью списков этого типа является то, что все их элементы упорядочены.<br></br>   Для создания упорядоченных списков применяется элемент OL, которому требуется наличие закрывающего тега, а все пункты списка находятся внутри этого элемента.<br></br>   У элемента OL есть атрибут type, который задает формат символов, используемых для нумерации.<br></br>   Следующие значения атрибута type указывают, что пункты будут нумероваться с помощью:<br></br>   • A – заглавных букв латинского алфавита;<br></br>   • a – строчных букв латинского алфавита;<br></br>   • I – заглавных римских цифр;<br></br>   • i – строчных римских цифр;<br></br>   • 1 – арабских цифр.<br></br>   Вторым атрибутом элемента OL является атрибут start, указывающий, с какого числа начинать нумерацию всего списка.<br></br>   В листинге 2.8 приведен пример кода для создания упорядоченных списков с разной нумерацией.<br></br><h5 class="subtitle"><b>Листинг 2.8.</b> Упорядоченные списки</h5>   &lt;html&gt;<br></br>   &lt;head&gt;<br></br>   &lt;title&gt;Списки&lt;/title&gt;<br></br>   &lt;body&gt;<br></br>   &lt;ol type="1" start="6"&gt;<br></br>   &lt;li&gt;Достать ключ&lt;/li&gt;<br></br>   &lt;li&gt;Вставить ключ в замочную скважину&lt;/li&gt;<br></br>   &lt;li&gt;Повернуть ключ по часовой стрелке на два оборота&lt;/li&gt;<br></br>   &lt;li&gt;Достать ключ из замка&lt;/li&gt;<br></br>   &lt;li&gt;Открыть дверь&lt;/li&gt;<br></br>   &lt;/ol&gt;<br></br>   &lt;ol type="A"&gt;<br></br>   &lt;li&gt;Достать ключ&lt;/li&gt;<br></br>   &lt;li&gt;Вставить ключ в замочную скважину&lt;/li&gt;<br></br>   &lt;li&gt;Повернуть ключ по часовой стрелке на два оборота&lt;/li&gt;<br></br>   &lt;li&gt;Достать ключ из замка&lt;/li&gt;<br></br>   &lt;li&gt;Открыть дверь&lt;/li&gt;<br></br>   &lt;/ol&gt;<br></br>   &lt;ol type="a"&gt;<br></br>   &lt;li&gt;Достать ключ&lt;/li&gt;<br></br>   &lt;li&gt;Вставить ключ в замочную скважину&lt;/li&gt;<br></br>   &lt;li&gt;Повернуть ключ по часовой стрелке на два оборота&lt;/li&gt;<br></br>   &lt;li&gt;Достать ключ из замка&lt;/li&gt;<br></br>   &lt;li&gt;Открыть дверь&lt;/li&gt;<br></br>   &lt;/ol&gt;<br></br>   &lt;ol type="I"&gt;<br></br>   &lt;li&gt;Достать ключ&lt;/li&gt;<br></br>   &lt;li&gt;Вставить ключ в замочную скважину&lt;/li&gt;<br></br>   &lt;li&gt;Повернуть ключ по часовой стрелке на два оборота&lt;/li&gt;<br></br>   &lt;li&gt;Достать ключ из замка&lt;/li&gt;<br></br>   &lt;li&gt;Открыть дверь&lt;/li&gt;<br></br>   &lt;/ol&gt;<br></br>   &lt;ol type="i"&gt;<br></br>   &lt;li&gt;Достать ключ&lt;/li&gt;<br></br>   &lt;li&gt;Вставить ключ в замочную скважину&lt;/li&gt;<br></br>   &lt;li&gt;Повернуть ключ по часовой стрелке на два оборота&lt;/li&gt;<br></br>   &lt;li&gt;Достать ключ из замка&lt;/li&gt;<br></br>   &lt;li&gt;Открыть дверь&lt;/li&gt;<br></br>   &lt;/ol&gt;<br></br>   &lt;/body&gt;<br></br>   &lt;/html&gt;<br></br>   Фрагмент отображения в браузере кода из листинга 2.8 показан на рис. 2.8.<br></br><div class="wrap_pict"><div style="text-align: center;"><img src="i_019.png" alt=""></img></div>   <b>Рис. 2.8.</b> Упорядоченные списки<br></br></div><br></br>   В примере созданы списки с различными типами нумерации, для списка с арабской нумерацией задан стартовый номер 6.<br></br>   При создании упорядоченных списков на элемент LI можно возложить дополнительные функции. Как и в примере с маркированными списками, в элементе LI можно задать вид нумерации конкретного пункта с помощью атрибута type. Помимо этого, с помощью атрибута value можно задать номер, с которого будет продолжена нумерация списка.<br></br>   В примере из листинга 2.9 представлен код для создания списка с разными типами нумерации и различным порядком следования элементов.<br></br><h5 class="subtitle"><b>Листинг 2.9.</b> Список с разными типами нумерации</h5>   &lt;html&gt;<br></br>   &lt;head&gt;<br></br>   &lt;title&gt;Списки&lt;/title&gt;<br></br>   &lt;body&gt;<br></br>   &lt;ol type="1" &gt;<br></br>   &lt;li type="1" value="10"&gt;Закрой дверь&lt;/li&gt;<br></br>   &lt;li&gt;Сходи в магазин&lt;/li&gt;<br></br>   &lt;li value="1"&gt;Открой дверь&lt;/li&gt;<br></br>   &lt;li&gt;Возьми деньги&lt;/li&gt;<br></br>   &lt;li type="I"&gt;Иди налево&lt;/li&gt;<br></br>   &lt;li type="I"&gt;Потом поверни направо&lt;/li&gt;<br></br>   &lt;li&gt;Увидишь магазин&lt;/li&gt;<br></br>   &lt;/ol&gt;<br></br>   &lt;/body&gt;<br></br>   &lt;/html&gt;<br></br><br></br>   Результат обработки листинга 2.9 представлен на рис. 2.9.<br></br><div class="wrap_pict"><div style="text-align: center;"><img src="i_020.png" alt=""></img></div>   <b>Рис. 2.9.</b> Упорядоченный список с разной нумерацией<br></br></div><br></br>   Как видно из примера, порядок нумерации и тип ее отображения отделены друг от друга, изменение типа чисел не влияет на числовое обозначение пунктов.<br></br></div><h3 id="idm139732188211152">Список определений
</h3><div style="text-align: justify" class="hsection3">   Бывает, что на сайте нужно создать список терминов или словарь. Это особенно актуально для сайтов узкой направленности. Для создания подобных конструкций служит список определений.<br></br>   Список определений – это особый вид списка, который применяется для форматирования словарей или когда необходимо пояснять значения терминов.<br></br>   Особенность списка определений следует из его функций: элемент такого списка всегда состоит из двух частей. Первая часть задает определяемое слово, а вторая – описание или расшифровку термина. При этом форматирование производится таким образом, что описание термина отображается с отступом от края экрана и, возможно, с пропуском строки от определения.<br></br>   Для организации списков определений служит элемент DL – внутри него будут находиться определение и описание термина. У этого элемента нет атрибутов, кроме стандартных style и class, с помощью которых к данному определению можно подключить стили.<br></br>   Чтобы внести информацию внутрь элемента DL, нужно задать элементы DT и DD. Первый используется для того, чтобы задать определение; у него нет никаких особенных атрибутов.<br></br>   Второй применяется для описания термина из элемента DT. Особых атрибутов в нем также не предусмотрено. Чтобы изменить вид информации, представленной в этом элементе, нужно использовать таблицы стилей.<br></br>   В листинге 2.10 представлен пример создания списков определений.<br></br><h5 class="subtitle"><b>Листинг 2.10.</b> Списки определений</h5>   &lt;html&gt;<br></br>   &lt;head&gt;<br></br>   &lt;title&gt;Списки&lt;/title&gt;<br></br>   &lt;body&gt;<br></br>   &lt;dl&gt;<br></br>   &lt;dt&gt;Земля&lt;/dt&gt;<br></br>   &lt;dd&gt;Третья планета Солнечной системы&lt;/dd&gt;<br></br>   &lt;dt&gt;Марс&lt;/dt&gt;<br></br>   &lt;dd&gt;Четвертая планета Солнечной системы&lt;/dd&gt;<br></br>   &lt;/dl&gt;<br></br>   &lt;/body&gt;<br></br>   &lt;/html&gt;<br></br>   Результат работы кода из листинга 2.10 показан на рис. 2.10.<br></br><div class="wrap_pict"><div style="text-align: center;"><img src="i_021.png" alt=""></img></div>   <b>Рис. 2.10.</b> Списки определений<br></br></div><br></br>   На рис. 2.10 видны особенности форматирования списков определений; информацию в таком виде гораздо проще воспринимать.<br></br></div><h3 id="idm139732226339024">Создание вложенных списков
</h3><div style="text-align: justify" class="hsection3">   Возможностей простых списков часто не хватает. Например, при создании оглавлений не обойтись без вложенных пунктов. Поэтому рассмотрим создание вложенных списков.<br></br>   В HTML можно комбинировать и вкладывать друг в друга списки разных типов, но при этом нужно внимательно следить за тем, где заканчивается вложенный список, а где список верхнего уровня, иначе будут проблемы с отображением информации.<br></br>   В листинге 2.11 представлен код для создания вложенного списка.<br></br><h5 class="subtitle"><b>Листинг 2.11.</b> Вложенные списки</h5>   &lt;html&gt;<br></br>   &lt;head&gt;<br></br>   &lt;title&gt;Списки&lt;/title&gt;<br></br>   &lt;body&gt;<br></br>   &lt;ol&gt;<br></br>   &lt;li&gt;<br></br>   Открой дверь<br></br>   &lt;ul&gt;<br></br>   &lt;li&gt;Ключом&lt;/li&gt;<br></br>   &lt;li&gt;Отмычкой&lt;/li&gt;<br></br>   &lt;/ul&gt;<br></br>   &lt;/li&gt;<br></br>   &lt;li&gt;<br></br>   Зайди в квартиру<br></br>   &lt;ul&gt;<br></br>   &lt;li&gt;Тихо шагая&lt;/li&gt;<br></br>   &lt;li&gt;Громко топая&lt;/li&gt;<br></br>   &lt;/ul&gt;<br></br>   &lt;/li&gt;<br></br>   &lt;li&gt;Ложись спать&lt;/li&gt;<br></br>   &lt;/ol&gt;<br></br>   &lt;/body&gt;<br></br>   &lt;/html&gt;<br></br>   На рис. 2.11 можно увидеть, как выглядит вложенный список.<br></br><div class="wrap_pict"><div style="text-align: center;"><img src="i_022.png" alt=""></img></div>   <b>Рис. 2.11.</b> Вложенный список<br></br></div><br></br>   Видно, что элементы внутренних списков отступают от элементов списка более высокого уровня.<br></br>   Мы разобрались с большей частью оформления текста, правда, осталось самое главное – то, на чем основан Интернет, – ссылки.<br></br></div></div><h2 id="idm139732226319824">2.5. Ссылки
</h2><div style="text-align: justify" class="hsection2"><div style="text-align: justify" class="section3">   По своей сути Интернет – это текст и ссылки. Ссылки связывают документы, разбросанные по всему Интернету, в одну сеть. Ваш сайт может находиться на разных компьютерах, но для посетителя он будет казаться единым целым, и все это благодаря ссылкам.<br></br>
   Можно выделить два типа ссылок: внешние и внутренние. Первые связывают страницы в один сайт и помогают передвигаться по нему. Вторые помогают передвигаться в рамках одной страницы.<br></br>
</div><h3 id="idm139732226321360">Внешние ссылки
</h3><div style="text-align: justify" class="hsection3">   Внешними называют ссылки на объекты, расположенные вне текущей страницы. Это могут быть картинки, другие страницы сайта, мультимедийные приложения.<br></br>   Основой внешних ссылок является URL-адрес объекта, на который вы собираетесь сослаться.<br></br>   Для создания гиперссылок в HTML служит элемент A, который требует наличия закрывающего тега. Внутри элемента располагается текст, который будет выделен как ссылка. На самом деле, чтобы сообщить человеку, что в каком-то месте сайта у вас расположена ссылка, совершенно не обязательно писать прямым текстом адрес следующей страницы. Язык HTML дает возможность «замаскировать» адрес под текст ссылки. Получается, что у вас отдельно есть текст ссылки, который должен внятно описывать, что пользователь увидит, перейдя по ней, и отдельно находится адрес страницы, на которую будет сделан переход при щелчке кнопкой мыши на ссылке. Между тегами &lt;A&gt; и &lt;/A&gt; располагается именно текст ссылки.<br></br>   Адрес документа для перехода записывается в элементе A в качестве значения атрибута href. Таким образом, перемещение по сайту становится удобным, легким и прозрачным для пользователя. Ему абсолютно все равно, где находится документ, на который указывает ссылка, он видит только текст описания.<br></br>   В листинге 2.12 представлен пример создания ссылки на HTML-страницу и рисунок.<br></br><h5 class="subtitle"><b>Листинг 2.12.</b> Создание ссылок</h5>   &lt;html&gt;<br></br>   &lt;head&gt;<br></br>   &lt;title&gt;Ссылки&lt;/title&gt;<br></br>   &lt;body&gt;<br></br>   &lt;a href="aboutme.html"&gt;Обо мне&lt;/a&gt;&lt;br /&gt;<br></br>   &lt;a href="myfoto.jpg"&gt;Мое фото&lt;/a&gt;<br></br>   &lt;/body&gt;<br></br>   &lt;/html&gt;<br></br>   Пример отображения ссылок в браузере показан на рис. 2.12.<br></br><div class="wrap_pict"><div style="text-align: center;"><img src="i_023.png" alt=""></img></div>   <b>Рис. 2.12.</b> Ссылки<br></br></div><br></br>   Текст ссылки отображается подчеркнутым, а указатель мыши меняет вид при наведении на ссылку.<br></br>   Когда посетитель сайта щелкнет кнопкой мыши на ссылке, он перейдет на страницу, которая указана в качестве адреса.<br></br>   Что же делать, если нужно организовать быстрое перемещение в рамках одной страницы? Здесь тоже помогут ссылки.<br></br></div><h3 id="idm139732226330192">Внутренние ссылки
</h3><div style="text-align: justify" class="hsection3">   Внутренние ссылки организуют переходы внутри одного HTML-документа. Они применяются, когда на одной странице много текста. Для простоты навигации можно создать ссылки, при щелчке кнопкой мыши на которых пользователь автоматически перейдет к нужной части документа.<br></br>   Чтобы создать такую ссылку, сначала нужно определить место, к которому ссылка приводит. Это делается с помощью атрибута name элемента A. Необходимый кусок текста заключается в элемент A. Хотя совершенно не обязательно помещать туда текст, можно просто установить теги этого элемента в месте, к которому браузер должен переходить при щелчке кнопкой мыши на ссылке.<br></br>   В качестве значения атрибута name можно взять любое имя, желательно, чтобы оно характеризовало текущее место, так вам самим будет проще пользоваться метками.<br></br>   Затем нужно создать ссылку на эту метку. Ссылка на внутреннюю метку создается так же, как и ссылка на внешний документ, только вместо URL-адреса желаемой страницы надо ввести адрес метки в виде #met1. При этом metl – имя вашей метки.<br></br>   Теперь при щелчке кнопкой мыши на ссылке браузер автоматически перейдет к месту, указанному меткой.<br></br>   В листинге 2.13 показан пример создания внутренних ссылок.<br></br><h5 class="subtitle"><b>Листинг 2.13.</b> Внутренние ссылки</h5>   &lt;html&gt;<br></br>   &lt;head&gt;<br></br>   &lt;title&gt;Ссылки&lt;/title&gt;<br></br>   &lt;body&gt;<br></br>   &lt;a name="met2"&gt;Это метка для перехода 2&lt;/a&gt;&lt;br /&gt;<br></br>   &lt;a href="#met1"&gt;Щелкните кнопкой мыши для перехода к метке 1&lt;/a&gt;&lt;br /&gt;<br></br>   &lt;a href="#met2"&gt;Щелкните кнопкой мыши для перехода к метке 2&lt;/a&gt;&lt;br /&gt;<br></br>   &lt;a name="met1"&gt;Это метка для перехода 1&lt;/a&gt;<br></br>   &lt;/body&gt;<br></br>   &lt;/html&gt;<br></br>   Представление внутренних ссылок в браузере показано на рис. 2.13.<br></br><div class="wrap_pict"><div style="text-align: center;"><img src="i_024.png" alt=""></img></div>   <b>Рис. 2.13.</b> Внутренние ссылки<br></br></div><br></br>   Как видно, внутренние ссылки при отображении ничем не отличаются от внешних, а текст, отмеченный как метка, никак не выделяется.<br></br>   Внутренние ссылки по своему синтаксису такие же, как и внешние, поэтому атрибуты элемента A применимы для обоих типов.<br></br></div><h3 id="idm139732226290768">Общие моменты
</h3><div style="text-align: justify" class="hsection3">   Все немногочисленные атрибуты элемента A можно применять при создании как внутренних, так и внешних ссылок, их действие в зависимости от этого не меняется.<br></br>   У элемента A есть два вспомогательных атрибута. Первый – target – указывает на то, в каком окне должен открываться документ, отображающийся при выборе ссылки.<br></br>   Следующие значения атрибута target указывают, что страница загружается:<br></br>   • _blanc – в новое окно браузера;<br></br>   • _parent – во фрейм-родитель;<br></br>   • _self – в текущее окно;<br></br>   • _top – в полное окно браузера.<br></br>   Этот атрибут очень полезен, потому что иногда бывает удобно открыть ссылку в новом окне. Например, когда ссылка уводит на другой сайт, а вы не хотите, чтобы пользователь забыл о вашем. Открытие страницы в новом окне – гарантия того, что пользователь снова взглянет на вашу страницу.<br></br>   Вторым вспомогательным атрибутом является title, он позволяет создать всплывающую подсказку для вашей ссылки, что бывает очень удобно и дает пользователю дополнительную информацию о том, что его ждет под ссылкой. Значение атрибута – текст всплывающей подсказки.<br></br>   В листинге 2.14 представлен пример создания ссылок с рассмотренными выше атрибутами.<br></br><h5 class="subtitle"><b>Листинг 2.14.</b> Ссылки с дополнительными атрибутами</h5>   &lt;html&gt;<br></br>   &lt;head&gt;<br></br>   &lt;title&gt;Ссылки&lt;/title&gt;<br></br>   &lt;body&gt;<br></br>   &lt;a href="aboutme.html" target="_blank" title="Перейдя по ссылке, вы сможете узнать обо мне"&gt;Обо мне&lt;/a&gt;<br></br>   &lt;/body&gt;<br></br>   &lt;/html&gt;<br></br>   На рис. 2.14 показан пример отображения ссылки со всплывающей подсказкой.<br></br><div class="wrap_pict"><div style="text-align: center;"><img src="i_025.png" alt=""></img></div>   <b>Рис. 2.14.</b> Ссылки с дополнительными атрибутами<br></br></div><br></br>   Видно, что всплывающая подсказка может помочь посетителю страницы.<br></br>   Помимо этого, любой тип ссылки можно реализовать в виде изображения, то есть новая страница будет открываться при щелчке кнопкой мыши на рисунке. Можно, например, создать миниатюрные копии фотографий, при щелчке кнопкой мыши на которых будет открываться фото большего размера.<br></br>   Для создания ссылки-изображения достаточно поместить рисунок внутри элемента A.<br></br>   В листинге 2.15 показан пример создания ссылки-изображения.<br></br><h5 class="subtitle"><b>Листинг 2.15.</b> Ссылки-изображения</h5>   &lt;html&gt;<br></br>   &lt;head&gt;<br></br>   &lt;title&gt;Ссылки&lt;/title&gt;<br></br>   &lt;body&gt;<br></br>   &lt;a href="mypetfoto.html" target="_blank" title="Пройдя по ссылке, вы сможете увидеть фото моего зверя"&gt;&lt;img src="mypetfotomini.jpg" /&gt;&lt;/a&gt;<br></br>   &lt;/body&gt;<br></br>   &lt;/html&gt;<br></br><br></br>   На рис. 2.15 показано, как браузер отображает ссылки-изображения.<br></br><div class="wrap_pict"><div style="text-align: center;"><img src="i_026.png" alt=""></img></div>   <b>Рис. 2.15.</b> Ссылка-изображение<br></br></div><br></br>   Вокруг рисунка создается рамка, которая помогает посетителю понять, что перед ним не просто изображение, а ссылка.<br></br>   Теперь вы можете создать ссылку любого вида на любой объект. Следите за тем, чтобы ссылки имели понятные названия, соответствующие содержанию документов, расположенных за ними, тогда посетители сайта будут вашими постоянными гостями.<br></br>   Теперь рассмотрим, как можно влиять на внешний вид текста на странице.<br></br></div></div><h2 id="idm139732226275024">2.6. Форматирование текста
</h2><div style="text-align: justify" class="hsection2"><div style="text-align: justify" class="section3">   Для чего форматировать текст? Странный вопрос, ведь при создании сайта хочется, чтобы он был выдержан в одном стиле, а цвет и вид текста, принятые по умолчанию, не отвечают стилистике большинства сайтов. Поэтому приходится форматировать текст самостоятельно, благо HTML предоставляет для этого огромные возможности.<br></br>
   Есть много элементов для форматирования текста, и все они делятся на две группы: логические и физические. Друг от друга группы отличаются принципиально.<br></br>
   <i>Логические</i> элементы сообщают браузеру о том, какой тип информации в них содержится, например важный текст или цитата. Браузер сам решает, как отобразить такой текст. Конечно, есть принятые стандарты для отображения определенных элементов, но в таких элементах главное – смысл. По сути они разбивают документ на логические части и при этом не обязывают браузер отображать текст, расположенный внутри элемента, каким-либо конкретным образом.<br></br>
   <i>Физические</i> элементы просто говорят браузеру, как должен выглядеть тот или иной блок текста, не уточняя никак смысл и значимость его содержимого. Другими словами, такой элемент заставляет браузер нарисовать букву красной, полужирной или курсивом, не уточняя, почему буква должна выглядеть именно так.<br></br>
   В некотором роде действие на внешний вид текста у многих элементов одинаково: для выделения текста полужирным шрифтом, например, можно использовать как логические, так и физические элементы.<br></br>
   Начнем рассмотрение способов форматирования текста с использования логических элементов.<br></br>
</div><h3 id="idm139732226278608">Логические элементы для форматирования
</h3><div style="text-align: justify" class="hsection3">   Как уже говорилось, логические элементы для форматирования определяют не внешний вид текста, а его тип, и в зависимости от которого браузер применяет тот или иной вид внешнего форматирования. Все элементы, рассматриваемые ниже, являются контейнерами и требуют наличия закрывающего тега.<br></br>   Некоторые из этих элементов могут вообще не изменять отображение текста, поэтому при их рассмотрении будем делать упор на то, как они определяют значение текста, а не на то, как они его форматируют.<br></br><h5 class="subtitle"><b>Элемент ABBR</b></h5>   Элемент ABBR определяет текст как аббревиатуру. С помощью атрибута title можно задать всплывающую подсказку с расшифровкой аббревиатуры. При этом поисковые роботы индексируют именно полный вариант расшифровки, определенный в атрибуте title.<br></br>   Пример:<br></br>   &lt;abbr title="Научно-исследовательский институт"&gt;НИИ&lt;/abbr&gt;<br></br><h5 class="subtitle"><b>Элемент ACRONYM</b></h5>   Элемент ACRONYM указывает, что текст является акронимом.<br></br><blockquote><div>   <b>Примечание</b><br></br>
   Акронимы – это некие устоявшиеся сокращения, например СНГ, США и т. п.<br></br>
</div></blockquote>   Атрибут title позволяет задать расшифровку акронима. Пример:<br></br>   &lt;acronym&gt;СНГ&lt;/acronym&gt;<br></br><h5 class="subtitle"><b>Элемент CITE</b></h5>   Элемент CITE отмечает небольшую цитату или сноску, взятую из другого источника. Такой текст обычно отображается курсивом.<br></br>   Пример:<br></br>   &lt;cite&gt;Здесь указан источник информации&lt;/cite&gt;<br></br><h5 class="subtitle"><b>Элемент CODE</b></h5>   Этот элемент указывает на программный код, который может содержать, например, переменные, функции, небольшие куски программы. Такой текст обычно выводится моноширинным шрифтом.<br></br>   Пример:<br></br>   Зададим функцию &lt;code&gt; func(int a, char b);&lt;/code&gt;<br></br><h5 class="subtitle"><b>Элемент DEL</b></h5>   Элемент DEL помечает текст как удаленный и может использоваться при внесении изменений в документы. У этого элемента есть два атрибута: cite должен содержать URL документа, в котором описаны причины удаления фрагмента, а datetime – дату и время удаления фрагмента в формате ГГГГ-ММ-ДДTчч: мм: ccTZD (аббревиатура от Time Zone region with Daylight Saving Time – регион часового пояса с летним временем). Браузеры такой текст отображают как зачеркнутый.<br></br>   Пример:<br></br>   &lt;del cite="whydel.html" datetime="2007-10-06T10:11:45+3.00"&gt; Неактуальный фрагмент&lt;/del&gt;<br></br><h5 class="subtitle"><b>Элемент DFN</b></h5>   Этот элемент выделяет текст как определение. Элемент можно использовать, если новый термин встречается в тексте впервые и тут же дается его определение. Браузер отображает такой текст курсивом.<br></br>   Пример:<br></br>   &lt;dfn&gt;Определение&lt;/dfn&gt;-описание<br></br><h5 class="subtitle"><b>Элемент EM</b></h5>   Элемент EM выделяет важные фрагменты текста. Браузер отображает такой текст курсивом.<br></br>   Пример:<br></br>   &lt;em&gt;Важно&lt;/em&gt;<br></br><h5 class="subtitle"><b>Элемент INS</b></h5>   Элемент INS отмечает текст как вставку и применяется для выделения изменений, вносимых в документ. У этого элемента есть два атрибута: cite должен содержать URL документа, в котором описаны причины добавления фрагмента, а datetime должен содержать дату и время добавления в формате ГГГГ-ММ-ДДTчч: мм: ссTZD. Браузеры отображают такой текст как подчеркнутый.<br></br>   Пример:<br></br>   &lt;ins cite="whyadd.html" datetime="2007-10-06T10:11:45+3.00"&gt;Новый фрагмент&lt;/ins&gt;<br></br><h5 class="subtitle"><b>Элемент KBD</b></h5>   Элементом KBD помечают текст, вводимый пользователем с клавиатуры. Браузеры отображают такой текст моноширинным шрифтом.<br></br>   Пример:<br></br>   Введите слово &lt;kbd&gt;дом&lt;/kbd&gt;<br></br><h5 class="subtitle"><b>Элемент Q</b></h5>   Этот элемент обозначает текст как цитату и применяется для добавления коротких высказываний в текст. Обычно отображается как курсив, но некоторые браузеры берут в кавычки текст, отмеченный этим элементом.<br></br>   Пример:<br></br>   Цитата: &lt;q&gt;Как сказал поэт&lt;/q&gt;<br></br><h5 class="subtitle"><b>Элемент SAMP</b></h5>   Элемент SAMP определяет текст как пример и обычно используется для выделения результатов работы программы. Браузер выделяет этот текст моноширинным шрифтом.<br></br>   Пример:<br></br>   &lt;samp&gt;Образец&lt;/samp&gt;<br></br><h5 class="subtitle"><b>Элемент STRONG</b></h5>   Элемент STRONG предназначен для постановки акцента на тексте. Браузеры выделяют такой текст полужирным шрифтом.<br></br>   Пример:<br></br>   &lt;strong&gt;Очень важный фрагмент&lt;/strong&gt;<br></br><h5 class="subtitle"><b>Элемент VAR</b></h5>   Этот элемент применяется для выделения переменных из программ. Браузер отмечает такой текст курсивом.<br></br>   Пример:<br></br>   Введите переменную &lt;var&gt;X&lt;/var&gt;<br></br>   В листинге 2.16 показан код страницы с различным форматированием текста.<br></br><h5 class="subtitle"><b>Листинг 2.16.</b> Логическое форматирование текста</h5>   &lt;html&gt;<br></br>   &lt;head&gt;<br></br>   &lt;title&gt;Логические элементы для форматирования&lt;/title&gt;<br></br>   &lt;body&gt;<br></br>   &lt;abbr title="Научно-исследовательский институт"&gt;НИИ&lt;/abbr&gt;&lt;br /&gt;<br></br>   2.6. Форматирование текста<br></br>   &lt;acronym&gt;СНГ&lt;/acronym&gt;&lt;br /&gt;<br></br>   &lt;cite&gt;Здесь указан источник информации&lt;/cite&gt;&lt;br /&gt;<br></br>   Зададим функцию &lt;code&gt;func(int a, char b);&lt;/code&gt;&lt;br /&gt;<br></br>   &lt;del cite="whydel.html" datetime="2007-10-06T10:11:45+3.00"&gt;Неактуальный фрагмент&lt;/del&gt;&lt;br /&gt;<br></br>   &lt;dfn&gt;Определение&lt;/dfn&gt;-описание&lt;br /&gt;<br></br>   &lt;em&gt;Важно&lt;/em&gt;&lt;br /&gt;<br></br>   &lt;ins cite="whyadd.html" datetime="2007-10-06T10:11:45+3.00"&gt;Новый фрагмент&lt;/ins&gt;&lt;br /&gt;<br></br>   Введите слово &lt;kbd&gt;дом&lt;/kbd&gt;&lt;br /&gt;<br></br>   Цитата: &lt;q&gt;Как сказал поэт&lt;/q&gt;&lt;br /&gt;<br></br>   &lt;samp&gt;Образец&lt;/samp&gt;&lt;/br&gt;<br></br>   &lt;strong&gt;Очень важный фрагмент&lt;/strong&gt;&lt;br /&gt;<br></br>   Введите переменную &lt;var&gt;X&lt;/var&gt;&lt;br /&gt;<br></br>   &lt;/body&gt;<br></br>   &lt;/html&gt;<br></br>   Результат обработки браузером кода из листинга 2.16 показан на рис. 2.16.<br></br><div class="wrap_pict"><div style="text-align: center;"><img src="i_027.png" alt=""></img></div>   <b>Рис. 2.16.</b> Логическое форматирование текста<br></br></div><br></br>   На рис. 2.16 видно, что не все логические элементы для форматирования изменяют вид текста, потому что предназначены не для этого. Различные браузеры могут по-разному выводить различные элементы, поэтому перед тем как выложить сайт в Интернете, проверьте его вид в различных программах.<br></br></div><h3 id="idm139732171115088">Физические элементы для форматирования
</h3><div style="text-align: justify" class="hsection3">   Физические элементы для форматирования сообщают браузеру, как должен выглядеть текст, расположенный внутри элемента.<br></br><h5 class="subtitle"><b>Элемент B</b></h5>   Элемент B задает полужирное написание шрифта.<br></br>   Пример:<br></br>   &lt;b&gt;Полужирный шрифт&lt;/b&gt;<br></br><h5 class="subtitle"><b>Элемент I</b></h5>   Элемент I отображает выделенный текст курсивом.<br></br>   Пример:<br></br>   &lt;i&gt;Курсив&lt;/i&gt;<br></br><h5 class="subtitle"><b>Элемент TT</b></h5>   Этот элемент задает моноширинное написание текста.<br></br>   Пример:<br></br>   &lt;tt&gt;Моноширинный шрифт&lt;/tt&gt;<br></br><h5 class="subtitle"><b>Элемент U</b></h5>   Элемент U отображает текст подчеркнутым шрифтом.<br></br>   Пример:<br></br>   &lt;u&gt;Подчеркнутый&lt;/u&gt;<br></br><h5 class="subtitle"><b>Элемент S</b></h5>   Элемент S зачеркивает текст горизонтальной линией.<br></br>   Пример:<br></br>   &lt;s&gt;Зачеркнутый&lt;/s&gt;<br></br><h5 class="subtitle"><b>Элемент STRIKE</b></h5>   Этот элемент также зачеркивает текст горизонтальной линией.<br></br>   Пример:<br></br>   &lt;strike&gt;Снова зачеркнутый&lt;/strike&gt;<br></br><h5 class="subtitle"><b>Элемент BIG</b></h5>   Элемент BIG отображает текст, расположенный внутри, шрифтом большего размера, чем остальной текст. Если быть точнее, то размер шрифта увеличивается на единицу.<br></br><blockquote><div>   <b>Примечание</b><br></br>
   В языке HTML размеры шрифта измеряются в условных единицах от одного до семи. Размером по умолчанию принят третий размер.<br></br>
</div></blockquote>   При вложении элементов размер шрифта будет увеличиваться на единицу каждый раз.<br></br>   Пример:<br></br>   Шрифт &lt;big&gt;побольше &lt;big&gt;Еще больше&lt;/big&gt;&lt;/big&gt;<br></br><h5 class="subtitle"><b>Элемент SMALL</b></h5>   Элемент SMALL отображает выделенный текст шрифтом на единицу меньшего размера относительно окружающего текста. При вложении элементов шрифт будет уменьшаться на единицу с каждым вложением.<br></br>   Пример:<br></br>   Шрифт &lt;small&gt;поменьше&lt;/small&gt;<br></br><h5 class="subtitle"><b>Элемент SUB</b></h5>   Этот элемент задает подстрочное написание символов, то есть текст располагается ниже уровня базовой строки и становится меньшего размера. Удобно при вводе формул.<br></br>   Пример:<br></br>   &lt;sub&gt;Подстрочный&lt;/sub&gt; шрифт<br></br><h5 class="subtitle"><b>Элемент SUP</b></h5>   Элемент SUP задает надстрочное написание символов, то есть текст располагается выше базовой линии и становится меньшего размера. Этот элемент используют при написании формул.<br></br>   Пример:<br></br>   &lt;sup&gt;Надстрочный&lt;/sup&gt; шрифт<br></br><h5 class="subtitle"><b>Элемент SPAN</b></h5>   Элемент SPAN позволяет выделить часть текста и определить для нее особые параметры отображения с помощью таблиц стилей. Он применяется для выделения небольших областей текста.<br></br>   Пример:<br></br>   &lt;span style="background-color:#00FFFF"&gt;Текст с фоном&lt;/span&gt;<br></br>   В листинге 2.17 представлен код страницы с различным форматированием текста.<br></br><h5 class="subtitle"><b>Листинг 2.17.</b> Физическое форматирование</h5>   &lt;html&gt;<br></br>   &lt;head&gt;<br></br>   &lt;title&gt;Элементы физического форматирования&lt;/title&gt;<br></br>   &lt;body&gt;<br></br>   &lt;b&gt;Полужирный шрифт&lt;/b&gt;&lt;br /&gt;<br></br>   &lt;i&gt;Курсив&lt;/i&gt;&lt;br /&gt;<br></br>   &lt;tt&gt;Моноширинный шрифт&lt;/tt&gt;&lt;br /&gt;<br></br>   &lt;u&gt;Подчеркнутый&lt;/u&gt;&lt;br /&gt;<br></br>   &lt;s&gt;Зачеркнутый&lt;/s&gt;&lt;br /&gt;<br></br>   &lt;strike&gt;Снова зачеркнутый&lt;/strike&gt;&lt;br /&gt;<br></br>   Шрифт &lt;big&gt;побольше &lt;big&gt;Еще больше&lt;/big&gt;&lt;/big&gt;&lt;br /&gt;<br></br>   Шрифт &lt;small&gt;поменьше&lt;/small&gt;&lt;br /&gt;<br></br>   &lt;sub&gt;Подстрочный&lt;/sub&gt; шрифт&lt;br /&gt;<br></br>   &lt;sup&gt;Надстрочный&lt;/sup&gt; шрифт&lt;br /&gt;<br></br>   &lt;span style="background-color:#00FFFF"&gt;Текст с фоном&lt;/span&gt;<br></br>   &lt;/body&gt;<br></br>   &lt;/html&gt;<br></br>   Результат обработки браузером кода из листинга 2.17 представлен на рис. 2.17.<br></br><div class="wrap_pict"><div style="text-align: center;"><img src="i_028.png" alt=""></img></div>   <b>Рис. 2.17.</b> Физическое форматирование<br></br></div><br></br>   На рис. 2.17 видно, что любой физический элемент форматирования изменяет вид текста, потому что именно это является его функцией.<br></br>   Как видно из описания, зачастую действие логических и физических элементов дублируется. В принципе, рекомендуется использовать логические элементы форматирования, так как они определяют суть фрагмента текста.<br></br>   В табл. 2.1 кратко описаны аналоги рассмотренных физических элементов среди логических элементов и показано, какие элементы являются взаимозаменяемыми.<br></br><h5 class="subtitle"><b>Таблица 2.1.</b> Элементы форматирования текста</h5><div style="text-align: center;"><img src="i_029.png" alt=""></img></div>   Как видно из таблицы, для многих физических элементов форматирования можно найти логические аналоги, которые намного лучше опишут смысловую нагрузку выделенного текста.<br></br>   Все рассмотренные выше элементы применимы для форматирования небольших блоков текста. Дальше мы рассмотрим элементы, которые можно применять для изменения внешнего вида крупных текстовых блоков.<br></br></div><h3 id="idm139732171064272">Элементы для форматирования больших блоков текста
</h3><div style="text-align: justify" class="hsection3">   Элементы, которые мы рассмотрим в этом подразделе, позволяют форматировать большие блоки текста. Они определяют параметры отображения и расположения текста, заключенного в их блок.<br></br>   Начнем рассмотрение с элемента, напрямую отвечающего за параметры шрифта.<br></br><h5 class="subtitle"><b>Элемент FONT</b></h5>   Элемент FONT задает параметры шрифта для текста. Хотя для форматирования предпочтительнее использовать таблицы стилей, некоторые простые документы допускают и такое определение параметров текста.<br></br>   Параметры текста задаются с помощью атрибутов элемента FONT. Можно определить шрифт, размер и цвет текста, расположенного внутри него.<br></br>   За шрифт отвечает атрибут face, значением которого должно быть название шрифта. Однако название должно быть знакомо компьютеру пользователя, иначе будет применен шрифт по умолчанию. Для решения проблемы несоответствия или отсутствия шрифтов можно задать несколько допустимых типов, введя их через запятую в качестве значения атрибута face.<br></br>   За размер шрифта отвечает атрибут size. Значение задается в относительных величинах, то есть 2 или 6. По умолчанию используется размер 3. При этом можно задать размер шрифта относительно остального текста. Для этого нужно сначала указать +, если необходимо, чтобы размер шрифта на данном участке был больше, чем основной текст, или —, если требуется обратное форматирование. После знака надо указать количество пунктов, на которое текст должен быть больше или меньше.<br></br>   За цвет шрифта отвечает атрибут color, значением которого должно быть либо ключевое слово, обозначающее имя цвета, либо код цвета в формате #RRGGBB.<br></br><blockquote><div>   <b>Совет</b><br></br>
   Код цвета можно посмотреть в любом графическом редакторе.<br></br>
</div></blockquote>   В листинге 2.18 показан пример кода для определения параметров текста с помощью элемента FONT.<br></br><h5 class="subtitle"><b>Листинг 2.18.</b> Использование элемента FONT</h5>   &lt;html&gt;<br></br>   &lt;head&gt;<br></br>   &lt;title&gt;Элемент FONT&lt;/title&gt;<br></br>   &lt;body&gt;<br></br>   &lt;font color="#FF0000" face="Verdana, Arial, Helvetica, sans-serif" size="+2"&gt;<br></br>   Текст красного цвета с размером +2<br></br>   &lt;/font&gt;&lt;br /&gt;<br></br>   &lt;font color="#FF00FF" face="Verdana, Arial, Helvetica, sans-serif" size="-4"&gt;<br></br>   Текст фиолетового цвета с размером –4<br></br>   &lt;/font&gt;&lt;br /&gt;<br></br>   &lt;/body&gt;<br></br>   &lt;/html&gt;<br></br>   Результат вывода на экран кода из листинга 2.18 показан на рис. 2.18.<br></br><div class="wrap_pict"><div style="text-align: center;"><img src="i_030.png" alt=""></img></div>   <b>Рис. 2.18.</b> Использование элемента FONT<br></br></div><br></br>   В примере задан список похожих шрифтов. Браузер будет просматривать список по порядку и выведет текст тем шрифтом, который найдет первым. В качестве последнего варианта указан не шрифт, а семейство шрифтов Sans Serif. Если браузер не найдет ни один из перечисленных шрифтов, он возьмет известный ему шрифт из этого семейства.<br></br>   Как задать параметры шрифта, мы разобрались. Однако этот метод не лучший. Как уже говорилось, удобнее задавать форматирование с помощью таблиц стилей.<br></br><h5 class="subtitle"><b>Элемент DIV</b></h5>   Элемент DIV служит для выделения больших блоков текста под форматирование с помощью таблиц стилей. Иными словами, вы помещаете необходимый блок текста между тегами элемента DIV и либо задаете ему параметры в атрибуте style, либо подключаете класс из таблицы стилей с помощью атрибута class.<br></br>   Единственное, что вы можете сделать с помощью HTML, – выровнять текст в блоке с помощью атрибута align и создать всплывающую подсказку для блока с помощью атрибута title.<br></br>   В листинге 2.19 представлен пример кода для выделения текста с помощью элемента DIV.<br></br><h5 class="subtitle"><b>Листинг 2.19.</b> Использование элемента DIV</h5>   &lt;html&gt;<br></br>   &lt;head&gt;<br></br>   &lt;title&gt;Элемент DIV&lt;/title&gt;<br></br>   &lt;body&gt;<br></br>   &lt;div style="cursor:crosshair" align="center"&gt;<br></br>   Текст внутри этого элемента выровнен по центру, а с помощью стилей задается вид указателя мыши при наведении на этот блок.<br></br>   &lt;/div&gt;<br></br>   &lt;/body&gt;<br></br>   &lt;/html&gt;<br></br><br></br>   Результат обработки кода из листинга 2.19 показан на рис. 2.19.<br></br><div class="wrap_pict"><div style="text-align: center;"><img src="i_031.png" alt=""></img></div>   <b>Рис. 2.19.</b> Использование элемента DIV<br></br></div><br></br>   Теперь рассмотрим ситуацию, когда у вас уже есть отформатированный нужным образом текст и вы не хотите ничего менять.<br></br><h5 class="subtitle"><b>Элемент PRE</b></h5>   Этот элемент служит для ввода текста без форматирования, то есть с сохранением всех пробелов и переносов строк.<br></br><blockquote><div>   <b>Примечание</b><br></br>
   Обычно в HTML несколько пробелов подряд воспринимаются как один пробел.<br></br>
</div></blockquote>   При использовании этого элемента текст выводится моноширинным шрифтом. Элемент PRE часто используют для вывода кодов программ. Внутри этого элемента можно применять большинство элементов форматирования текста.<br></br>   В листинге 2.20 приведен пример использования элемента PRE.<br></br><h5 class="subtitle"><b>Листинг 2.20.</b> Использование элемента PRE</h5>   &lt;html&gt;<br></br>   &lt;head&gt;<br></br>   &lt;title&gt;Элемент PRE&lt;/title&gt;<br></br>   &lt;body&gt;<br></br>   &lt;pre&gt;<br></br>   Здесь<br></br>   можно<br></br>   расположить<br></br>   код<br></br>   программы<br></br>   &lt;/pre&gt;<br></br>   &lt;/body&gt;<br></br>   &lt;/html&gt;<br></br><br></br>   На рис. 2.20 показано, как текст, расположенный между тегами элемента PRE, выглядит в браузере.<br></br><div class="wrap_pict"><div style="text-align: center;"><img src="i_032.png" alt=""></img></div>   <b>Рис. 2.20. </b>Использование элемента PRE<br></br></div><br></br>   Далее рассмотрим элемент, предназначенный для форматирования больших объемов текста и отвечающий за цитаты.<br></br><h5 class="subtitle"><b>Элемент BLOCKQUOTE</b></h5>   Элемент BLOCKQUOTE определяет выделенный текст как цитату и применяется для описания больших высказываний. Он задает для текста отступы сверху, снизу и слева. Внутри этого элемента могут присутствовать элементы форматирования текста.<br></br>   В листинге 2.21 представлен пример выделения цитаты с помощью элемента BLOCKQUOTE.<br></br><h5 class="subtitle"><b>Листинг 2.21.</b> Ввод больших цитат</h5>   &lt;html xmlns="http://www.w3.org/1999/xhtml"&gt;<br></br>   &lt;head&gt;<br></br>   &lt;meta http-equiv="Content-Type" content="text/html; charset=windows-1251" /&gt;<br></br>   &lt;title&gt;Элемент BLOCKQUOTE&lt;/title&gt;<br></br>   &lt;body&gt;<br></br>   &lt;blockquote&gt;<br></br>   Здесь можно расположить важную и большую цитату.<br></br>   &lt;/blockquote&gt;<br></br>   &lt;/body&gt;<br></br>   &lt;/html&gt;<br></br><br></br>   На рис. 2.21 показано, как в браузере выглядит текст из элемента BLOCKQUOTE.<br></br><div class="wrap_pict"><div style="text-align: center;"><img src="i_033.png" alt=""></img></div>   <b>Рис. 2.21.</b> Использование элемента BLOCKQUOTE<br></br></div><br></br>   Мы рассмотрели, как действует каждый вариант форматирования текста отдельно, но HTML позволяет вкладывать элементы, при этом объединяя их действие.<br></br></div><h3 id="idm139732200257232">Вложение элементов
</h3><div style="text-align: justify" class="hsection3">   Язык HTML позволяет вкладывать элементы форматирования друг в друга. При этом их действия суммируются. Если вложить в элемент B элемент I, то получится текст, написанный полужирным курсивом. При этом нужно следить за правильным закрытием элементов: тот, что открыт раньше, закрывается позже.<br></br>   В листинге 2.22 показаны примеры правильного и неправильного вложения элементов.<br></br><h5 class="subtitle"><b>Листинг 2.22.</b> Вложение элементов</h5>   &lt;html xmlns="http://www.w3.org/1999/xhtml"&gt;<br></br>   &lt;head&gt;<br></br>   &lt;meta http-equiv="Content-Type" content="text/html; charset=windows-1251" /&gt;<br></br>   &lt;title&gt;Вложение элементов&lt;/title&gt;<br></br>   &lt;body&gt;<br></br>   &lt;del&gt;&lt;b&gt;&lt;i&gt;Это неправильное вложение элементов&lt;/b&gt;&lt;/i&gt;&lt;/del&gt;&lt;br /&gt;<br></br>   &lt;ins&gt;&lt;b&gt;&lt;i&gt;Это правильное вложение элементов&lt;/i&gt;&lt;/b&gt;&lt;/ins&gt;<br></br>   &lt;/body&gt;<br></br>   &lt;/html&gt;<br></br>   Неправильную запись некоторые браузеры могут отображать некорректно.<br></br></div></div><h2 id="idm139732200263120">Резюме
</h2><div style="text-align: justify" class="hsection2">   В данной главе были рассмотрены основные принципы форматирования текста с использованием возможностей HTML. Особенно подробно было рассказано об особенностях структурного форматирования документа и форматировании самого текста, были описаны особенности логического и физического форматирования текста, работа с большими блоками текста и вложением элементов.<br></br>   Теперь внешний вид текста на вашем сайте полностью подвластен вам. Помните, что ни один символ не может быть написан напрямую в элементе BODY. Текст всегда должен быть включен в элемент, который определяет его назначение и внешний вид.<br></br></div></div><h1 xmlns="http://www.w3.org/1999/xhtml" id="idm139732200264528" class="master">Глава 3<br></br>
Создание таблиц
</h1><div xmlns="http://www.w3.org/1999/xhtml" style="text-align: justify" class="hsection1"><div style="text-align: justify" class="section2">   3.1. Что такое таблица<br></br>
   3.2. Создание тела таблицы<br></br>
   3.3. Ячейки таблицы<br></br>
   3.4. Граница таблицы<br></br>
   3.5. Ширина и высота таблицы и ячеек<br></br>
   3.6. Группировка строк и столбцов<br></br>
   3.7. Выравнивание таблицы и содержимого ячеек<br></br>
   3.8. Объединение ячеек таблицы<br></br>
   3.9. Установка фонового цвета или рисунка ячейки<br></br>
   3.10. Создание вложенных таблиц<br></br>
   В технической литературе и в различных документах таблицы используют, чтобы расположить информацию в простом и понятном виде. О том, как использовать таблицы в своих сайтах, вы узнаете в этой главе.<br></br>
   В языке HTML таблицы используются в двух случаях: для представления числовых данных, разбитых по строкам и столбцам, или как средство форматирования веб-страниц, задания взаимного расположения элементов страницы. Ячейки таблицы могут содержать любые HTML-элементы, например заголовки, списки, абзацы, фигуры, графику, а также элементы форм. Фактически весь сайт расположен в большой сложной таблице (рис. 3.1).<br></br>
<div class="wrap_pict"><div style="text-align: center;"><img src="i_034.png" alt=""></img></div>   <b>Рис. 3.1.</b> Пример использования HTML-таблицы при создании сайта<br></br>
</div><br></br><blockquote><div>   <b>Примечание</b><br></br>
   Как и в прошлой главе, напоминаю, что оформление таблицы согласно требованиям языка XHTML должно выполняться средствами CSS. Все элементы и атрибуты форматирования признаны в спецификации языка HTML 4. 01 нежелательными.<br></br>
</div></blockquote></div><h2 id="idm139732200272720">3.1. Что такое таблица
</h2><div style="text-align: justify" class="hsection2">   Таблица состоит из ячеек, образующихся при пересечении строк и столбцов (рис. 3.2).<br></br><div class="wrap_pict"><div style="text-align: center;"><img src="i_035.png" alt=""></img></div>   <b>Рис. 3.2.</b> Пример стандартной таблицы<br></br></div><br></br>   Рассмотрим элементы таблицы.<br></br>   • Ячейка – это основной элемент таблицы. Она формируется пересечением строки и столбца.<br></br>   • Строка – это прямая линия ячеек, расположенных слева направо.<br></br>   • Столбец – это набор ячеек, расположенных одна над другой сверху вниз.<br></br>   • Граница – это линия, которая окружает каждую ячейку и таблицу в целом.<br></br>   В стандартной таблице каждая строка и каждый столбец содержат одинаковое количество ячеек. Однако таблицы могут очень сильно отличаться от предложенной стандартной. В таблице, изображенной на рис. 3.3, одна ячейка объединяет в себе четыре строки, а другая – три столбца.<br></br><div class="wrap_pict"><div style="text-align: center;"><img src="i_036.png" alt=""></img></div>   <b>Рис. 3.3.</b> Пример нестандартной таблицы<br></br></div><br></br>   Кстати, при создании таблицы лучше начать с ее планирования, потом будет легче верстать, так как вы наглядно будете видеть вашу таблицу и будет меньше вероятности ошибиться. Для этого вам следует выбрать оптимальный способ создания таблицы.<br></br>   Рассмотрим некоторые примеры планирования таблиц.<br></br>   • Нарисуйте таблицу на бумаге.<br></br>   • Нарисуйте таблицу в Paint, Adobe Photoshop или в AutoCAD.<br></br>   • Используйте HTML-совместимые текстовые редакторы, например Microsoft Word. Создайте таблицу и сохраните в редакторе HTML-страницы. Затем откройте страницу в окне браузера и скопируйте исходный текст в ваш HTML-редактор для дальнейшей корректировки и форматирования.<br></br></div><h2 id="idm139732170641488">3.2. Создание тела таблицы
</h2><div style="text-align: justify" class="hsection2">   В построении HTML-таблиц нет ничего сложного. Описание таблиц должно располагаться внутри элемента BODY. Документ может содержать произвольное количество таблиц, допускается вложение таблиц друг в друга. Каждая таблица должна начинаться тегом &lt;TABLE&gt; и завершаться тегом &lt;/TABLE&gt;:<br></br>   &lt;body&gt;<br></br>   &lt;table&gt;<br></br>   &lt;/table&gt;<br></br>   &lt;/body&gt;<br></br>   Все прочие элементы таблицы должны быть вложенными в элемент TABLE. Наименование таблицы определяется тегами &lt;CAPTION&gt;. &lt;/CAPTION&gt;. Выравнивание наименования задается с помощью атрибута align, который может принимать значения top (над таблицей) и bottom (под таблицей). По умолчанию наименование располагается над таблицей.<br></br></div><h2 id="idm139732170644432">3.3. Ячейки таблицы
</h2><div style="text-align: justify" class="hsection2">   Теперь приступим к созданию ячеек таблицы. Для начала нужно создать необходимое количество строк, затем поделить строки столбцами на ячейки. Количество пар тегов &lt;TR&gt; и &lt;/TR&gt; определяет количество горизонтальных строк в вашей таблице. Встречаются случаи, когда строка создана только с помощью тега &lt;TR&gt; без использования закрывающего тега &lt;/TR&gt;. Количество пар тегов &lt;TD&gt; и &lt;/TD&gt;, расположенных между тегами соответствующей строки, определяет количество ячеек (столбцов) в пределах строки. Встречаются случаи использования элемента TD без закрывающего тега.<br></br>   &lt;body&gt;<br></br>   &lt;table&gt;<br></br>   &lt;tr&gt;&lt;td&gt; &lt;/td&gt;&lt;td&gt; &lt;/td&gt;&lt;/tr&gt;<br></br>   &lt;tr&gt;&lt;td&gt; &lt;/td&gt;&lt;td&gt; &lt;/td&gt;&lt;/tr&gt;<br></br>   &lt;/table&gt;<br></br>   &lt;/body&gt;<br></br>   Чтобы созданная ячейка являлась заголовком в таблице (текст выравнивается по центру и выделяется полужирным шрифтом), нужно воспользоваться парой тегов &lt;TH&gt; и &lt;/TH&gt;. Встречаются случаи использования элемента TH без закрывающего тега. Элементы TH, TR и TD без закрывающих тегов корректно интерпретируются только в последней версии браузера Internet Explorer.<br></br>   Теперь вы можете создать простую HTML-таблицу. Рассмотрим пример таблицы, которая состоит из трех строк и трех столбцов, причем ячейки первой строки будут заголовками соответствующих столбцов (листинг 3.1). На рис. 3.4 показано, как данная таблица выглядит в окне браузера.<br></br><h5 class="subtitle"><b>Листинг 3.1.</b> Код простой HTML-таблицы, которая состоит из трех столбцов и трех строк</h5>   &lt;html&gt;<br></br>   &lt;head&gt;<br></br>   &lt;title&gt;Простая HTML-таблица&lt;/title&gt;<br></br>   &lt;/head&gt;<br></br>   &lt;body&gt;<br></br>   &lt;table&gt;<br></br>   &lt;caption&gt;Это заголовок таблицы&lt;/caption&gt;<br></br>   &lt;tr&gt;&lt;th&gt;Заголовок 1&lt;/th&gt;&lt;th&gt;Заголовок 2&lt;/th&gt;&lt;th&gt;Заголовок 3&lt;/th&gt;&lt;/tr&gt;<br></br>   &lt;tr&gt;&lt;td&gt;Ячейка 2x1 &lt;/td&gt;&lt;td&gt;Ячейка 2x2 &lt;/td&gt;&lt;td&gt;Ячейка 2x3 &lt;/td&gt;&lt;/tr&gt;<br></br>   &lt;tr&gt;&lt;td&gt;Ячейка 3x1 &lt;/td&gt;&lt;td&gt;Ячейка 3x2 &lt;/td&gt;&lt;td&gt;Ячейка 3x3 &lt;/td&gt;&lt;/tr&gt;<br></br>   &lt;/table&gt;<br></br>   &lt;/body&gt;<br></br>   &lt;/html&gt;<br></br><div style="text-align: center;"><img src="i_037.png" alt=""></img></div><br></br>   <b>Рис. 3.4.</b> Пример простой HTML-таблицы<br></br><br></br><blockquote><div>   <b>Совет</b><br></br>
   Все браузеры игнорируют любые символы пробела и табуляции и перевод строки вне тегов HTML-документа, поэтому описывать таблицу можно так, чтобы она легко читалась. Я считаю, что использование предложенного варианта описания таблицы позволит вам не упустить ни одного тега HTML-документа.<br></br>
</div></blockquote></div><h2 id="idm139732170590800">3.4. Граница таблицы
</h2><div style="text-align: justify" class="hsection2">   В рассмотренном выше примере в таблице и ее ячейках отсутствовали границы. Граница таблицы создается с помощью атрибута border элемента TABLE. Ширина границы таблицы указывается в пикселах. Если атрибут border не указан, то таблица выводится без видимой рамки. Благодаря атрибуту bordercolor можно задать цвет границы таблицы, указав код цвета. Добавим к уже созданной таблице черную границу шириной четыре пиксела.<br></br>   Для этого изменим строку<br></br>   &lt;table&gt;<br></br>   на<br></br>   &lt;table border="4" bordercolor="#000000"&gt;<br></br>   Граница таблицы (и другие элементы сайта) в окне каждого браузера отображается по-разному. На рис. 3.5 показано, как созданная таблица отображается в окне стандартного браузера Internet Explorer, а на рис. 3.6 эта же таблица изображена в браузере Opera. Опытные веб-программисты стараются просматривать созданную страницу под разными типами браузеров, чтобы все везде выглядело одинаково. У каждого браузера свои капризы, так что создать сайт, чтобы все выглядело одинаково в любом браузере, – задача непростая.<br></br><div class="wrap_pict"><div style="text-align: center;"><img src="i_038.png" alt=""></img></div>   <b>Рис. 3.5.</b> Отображение таблицы в окне Internet Explorer<br></br></div><br></br><div class="wrap_pict"><div style="text-align: center;"><img src="i_039.png" alt=""></img></div>   <b>Рис. 3.6.</b> Отображение таблицы в окне Opera<br></br></div><br></br>   Из рис. 3.5 видно, что между границами ячеек и внешней границей таблицы существует свободное пространство. Это пространство легко регулируется атрибутами cellspacing и cellpadding элемента TABLE. Атрибут cellspacing определяет расстояние между ячейками таблицы в пикселах, а атрибут cellpadding – между содержимым ячейки и ее границей.<br></br>   В листинге 3.2 приведен пример таблицы, у которой расстояние между содержимым ячеек и границей равно 10 пикселов, а расстояние между ячейками равно нулю (рис. 3.7).<br></br><h5 class="subtitle"><b>Листинг 3.2.</b> Код HTML-таблицы с нестандартными расстояниями между ячейками и границей</h5>   &lt;html&gt;<br></br>   &lt;head&gt;<br></br>   &lt;title&gt;Простая HTML-таблица&lt;/title&gt;<br></br>   &lt;/head&gt;<br></br>   &lt;body&gt;<br></br>   &lt;table border="4" bordercolor="#000000" cellspacing="0" cellpadding="10"&gt;<br></br>   &lt;caption&gt;Это заголовок таблицы&lt;/caption&gt;<br></br>   &lt;tr&gt;&lt;th&gt;Заголовок 1&lt;/th&gt;&lt;th&gt;Заголовок 2&lt;/th&gt;&lt;th&gt;Заголовок 3&lt;/th&gt;&lt;/tr&gt;<br></br>   &lt;tr&gt;&lt;td&gt;Ячейка 2x1 &lt;/td&gt;&lt;td&gt;Ячейка 2x2 &lt;/td&gt;&lt;td&gt;Ячейка 2x3 &lt;/td&gt;&lt;/tr&gt;<br></br>   &lt;tr&gt;&lt;td&gt;Ячейка 3x1 &lt;/td&gt;&lt;td&gt;Ячейка 3x2 &lt;/td&gt;&lt;td&gt;Ячейка 3x3 &lt;/td&gt;&lt;/tr&gt;<br></br>   &lt;/table&gt;<br></br>   &lt;/body&gt;<br></br>   &lt;/html&gt;<br></br><div class="wrap_pict"><div style="text-align: center;"><img src="i_040.png" alt=""></img></div>   <b>Рис. 3.7.</b> Таблица с нестандартными расстояниями между ячейками и границей<br></br></div><br></br>   Получив некоторые навыки работы с границей таблицы, вы можете приступать к управлению ее отображением. С помощью атрибута frame будем управлять отображением внешней границы, а с помощью атрибута rules – внутренними границами таблицы. Атрибут frame может принимать следующие значения:<br></br>   • above – отображается только верхняя линия границы;<br></br>   • below – видна только нижняя линия границы;<br></br>   • box – отображается внешняя граница таблицы;<br></br>   • border – видна внешняя граница таблицы (аналогично box);<br></br>   • hsides – отображаются только горизонтальные линии границы;<br></br>   • lhs – видна только левая линия границы;<br></br>   • rhs – отображается только правая линия границы;<br></br>   • void – внешняя граница таблицы не отображается;<br></br>   • vsides – видны только вертикальные линии границы.<br></br>   Frame и rules – это новые атрибуты в HTML, они поддерживаются только последними версиями браузеров.<br></br>   Атрибут rules может принимать следующие значения:<br></br>   • all – граница отображается вокруг каждой ячейки;<br></br>   • cols – видны только вертикальные границы между столбцами;<br></br>   • groups – отображаются только вертикальные границы между группами столбцов или горизонтальные границы между группами строк;<br></br>   • none – границы между ячейками не отображаются;<br></br>   • rows – видны только горизонтальные границы между группами строк.<br></br>   В листинге 3.3 приведен пример использования атрибутов frame и rules.<br></br><h5 class="subtitle"><b>Листинг 3.3.</b> Код HTML-таблицы с частичным отображением линий внешней и внутренней границ</h5>   &lt;html&gt;<br></br>   &lt;head&gt;<br></br>   &lt;title&gt;Простая HTML-таблица&lt;/title&gt;<br></br>   &lt;head&gt;<br></br>   &lt;body&gt;<br></br>   &lt;table border="4" bordercolor="#000000" cellspacing="0" cellpadding= "10" frame= Hsides rules= Cols&gt;<br></br>   &lt;caption&gt;Склонение слова пиксел по падежам &lt;/caption&gt;<br></br>   &lt;tr&gt;&lt;th&gt;Падеж&lt;/th&gt;&lt;th&gt;Пример &lt;/th&gt;&lt;/tr&gt;<br></br>   &lt;tr&gt;&lt;td&gt;Им. &lt;/td&gt;&lt;td&gt;пиксел &lt;/td&gt;&lt;/tr&gt;<br></br>   &lt;tr&gt;&lt;td&gt;Рд. &lt;/td&gt;&lt;td&gt;пиксела &lt;/td&gt;&lt;/tr&gt;<br></br>   &lt;tr&gt;&lt;td&gt;Дт. &lt;/td&gt;&lt;td&gt;пикселу &lt;/td&gt;&lt;/tr&gt;<br></br>   &lt;tr&gt;&lt;td&gt;Вт. &lt;/td&gt;&lt;td&gt;пиксел &lt;/td&gt;&lt;/tr&gt;<br></br>   &lt;tr&gt;&lt;td&gt;Тв. &lt;/td&gt;&lt;td&gt;пикселом &lt;/td&gt;&lt;/tr&gt;<br></br>   &lt;tr&gt;&lt;td&gt;Пр. &lt;/td&gt;&lt;td&gt;о пикселе &lt;/td&gt;&lt;/tr&gt;<br></br>   &lt;/table&gt;<br></br>   &lt;/body&gt;<br></br>   &lt;/html&gt;<br></br><br></br>   На рис. 3.8 показано, как рассмотренная таблица будет отображаться в окне браузера. У таблицы есть горизонтальные линии внешней и вертикальные линии внутренней границы, так как именно такие значения мы задали соответствующим атрибутам rules и frame.<br></br><div style="text-align: center;"><img src="i_041.png" alt=""></img></div>   <b>Рис. 3.8.HTML</b>-таблица с частичным отображением линий внешней и внутренней границ<br></br></div><h2 id="idm139732198185040">3.5. Ширина и высота таблицы и ячеек
</h2><div style="text-align: justify" class="hsection2">   Ширина таблицы задается атрибутом width элемента TABLE. Значение можно задавать как в абсолютных единицах (width="2 5 0"), так и в относительных (width="80 %"). Например, задав значение ширины в 600 пикселов, можно быть уверенным, что таблица поместится в окне браузера при любом разрешении монитора. Если же ширина задается в процентах, то они высчитываются от ширины окна браузера или от ширины ячейки другой таблицы, в которую вставлена данная. То же самое можно делать и с высотой таблицы с помощью атрибута height.<br></br>   Все вышесказанное относится и к ячейкам таблицы. Просто необходимо использовать элементы с соответствующими атрибутами. При этом вовсе не обязательно задавать размеры каждой отдельной ячейки. При изменении ширины или высоты ячейки все соседние ячейки в пределах столбца будут отображаться с учетом нового значения.<br></br>   При задании чрезмерно малых величин ширины и высоты таблицы браузер определяет минимальные значения, которые позволяют нормально отображать данные.<br></br>   На рис. 3.9 и 3.10 изображены две таблицы одинакового содержания, но разной ширины и высоты.<br></br><div class="wrap_pict"><div style="text-align: center;"><img src="i_042.png" alt=""></img></div>   <b>Рис. 3.9.</b> Ширина таблицы равна 80 % от ширины окна браузера<br></br></div><br></br><div class="wrap_pict"><div style="text-align: center;"><img src="i_043.png" alt=""></img></div>   <b>Рис. 3.10.</b> Ширина и высота таблицы равна 300 пикселам<br></br></div><br></br>   Ширина первой таблицы равна 80 % от размера окна браузера, а первый столбец этой таблицы занимает 50 % от всей ширины таблицы. Высота первой строки равна 100 пикселам.<br></br>   Вторая таблица квадратная, ширина стороны равна 300 пикселам. В листингах 3.4 и 3.5 приведены коды страниц, содержащих описанные таблицы.<br></br><h5 class="subtitle"><b>Листинг 3.4.</b> Код таблицы шириной 80 % от ширины окна браузера</h5>   &lt;html&gt;<br></br>   &lt;head&gt;<br></br>   &lt;title&gt;Простая HTML-таблица&lt;/title&gt;<br></br>   &lt;/head&gt;<br></br>   &lt;body&gt;<br></br>   &lt;table border="4" bordercolor="#000000" cellspacing="0" cellpadding="10" width="80%"&gt;<br></br>   &lt;caption&gt;Ширина таблицы 80%&lt;/caption&gt;<br></br>   &lt;tr&gt;&lt;th height="100" width="50%"&gt;Заголовок 1&lt;/th&gt;<br></br>   &lt;th&gt;Заголовок 2&lt;/th&gt;&lt;th&gt;Заголовок 3&lt;/th&gt;&lt;/tr&gt;<br></br>   &lt;tr&gt;&lt;td&gt;Ячейка 2x1 &lt;/td&gt;&lt;td&gt;Ячейка 2x2 &lt;/td&gt;&lt;td&gt;Ячейка 2x3 &lt;/td&gt;&lt;/tr&gt;<br></br>   &lt;tr&gt;&lt;td&gt;Ячейка 3x1 &lt;/td&gt;&lt;td&gt;Ячейка 3x2 &lt;/td&gt;&lt;td&gt;Ячейка 3x3 &lt;/td&gt;&lt;/tr&gt;<br></br>   &lt;/table&gt;<br></br>   &lt;/body&gt;<br></br>   &lt;/html&gt;<br></br><br></br><h5 class="subtitle"><b>Листинг 3.5.</b> Код таблицы шириной 300 пикселов</h5>   &lt;html&gt;<br></br>   &lt;head&gt;<br></br>   &lt;title&gt;Простая HTML-таблица&lt;/title&gt;<br></br>   &lt;/head&gt;<br></br>   &lt;body&gt;<br></br>   &lt;table border="4" bordercolor="#000000" cellspacing="0" cellpadding="10" width="300" height="300"&gt;<br></br>   &lt;caption&gt;Ширина таблицы 300 пикселов&lt;/caption&gt;<br></br>   &lt;tr&gt;&lt;th&gt;Заголовок 1&lt;/th&gt;&lt;th&gt;Заголовок 2&lt;/th&gt;&lt;th&gt;Заголовок 3&lt;/th&gt;&lt;/tr&gt;<br></br>   &lt;tr&gt;&lt;td&gt;Ячейка 2x1 &lt;/td&gt;&lt;td&gt;Ячейка 2x2 &lt;/td&gt;&lt;td&gt;Ячейка 2x3 &lt;/td&gt;&lt;/tr&gt;<br></br>   &lt;tr&gt;&lt;td&gt;Ячейка 3x1 &lt;/td&gt;&lt;td&gt;Ячейка 3x2 &lt;/td&gt;&lt;td&gt;Ячейка 3x3 &lt;/td&gt;&lt;/tr&gt;<br></br>   &lt;/table&gt;<br></br>   &lt;/body&gt;<br></br>   &lt;/html&gt;<br></br></div><h2 id="idm139732198169168">3.6. Группировка строк и столбцов
</h2><div style="text-align: justify" class="hsection2">   В стандарте HTML 4 появились новые элементы для группировки (не объединения, а именно группировки) строк и столбцов таблицы в группы с общими свойствами.<br></br>   Для группировки столбцов таблицы служат элементы COLGROUP и COL. Элемент COLGROUP создает структурную группу столбцов, которая выделяет множество логически однородных ячеек. Так, одна структурная группа может охватывать ячейки заголовков столбцов, а другая – ячейки, содержащие данные. Элемент COL предназначен для формирования неструктурных групп столбцов, которые делят таблицу на разделы, не имеющие отношения к структуре. Это удобно в том случае, когда не все столбцы содержат информацию одного типа.<br></br>   Полезным атрибутом элементов COLGROUP и COL является атрибут span со значением n. Атрибут распространяет свойства, заданные этими элементами на n столбцов в группе.<br></br>   &lt;table&gt;<br></br>   &lt;col span=2 style="color:red"&gt;<br></br>   &lt;tr&gt;&lt;td&gt; Этот текст будет красным цветом &lt;/td&gt;<br></br>   &lt;td&gt; И этот текст будет красным цветом &lt;/td&gt;<br></br>   &lt;td&gt; А этот текст будет черным цветом &lt;/td&gt;&lt;/tr&gt;<br></br>   &lt;/table&gt;<br></br>   Для группировки строк таблицы служат элементы THEAD, TBODY и TFOOT. Их использование существенно облегчает компоновку и форматирование таблиц.<br></br>   Для создания группы заголовков для столбцов таблицы используют элемент THEAD. Его допускается использовать в пределах таблицы только один раз. Для создания одной или нескольких групп строк таблицы, содержащих основные данные, применяется элемент TBODY. Элемент TFOOT позволяет создать группу строк для представления информации о суммах или итогах в нижней части таблицы. Этот элемент допускается использовать в пределах таблицы только один раз. Вовсе не обязательно создавать группы строк таблицы всех трех типов.<br></br>   &lt;thead&gt;<br></br>   &lt;tr&gt;&lt;th&gt; &lt;/th&gt;&lt;th&gt; &lt;/th&gt;&lt;th&gt; &lt;/th&gt;&lt;/tr&gt;<br></br>   &lt;/thead&gt;<br></br>   &lt;/tbody&gt;<br></br>   &lt;tr&gt;&lt;td&gt; &lt;/td&gt;&lt;td&gt; &lt;/td&gt;&lt;td&gt; &lt;/td&gt;&lt;/tr&gt;<br></br>   &lt;tr&gt;&lt;td&gt; &lt;/td&gt;&lt;td&gt; &lt;/td&gt;&lt;td&gt; &lt;/td&gt;&lt;/tr&gt;<br></br>   &lt;tbody&gt;<br></br>   Предположим, нужно создать таблицу, в которой внутренние линии не отображаются, а отображается только линия, отделяющая заголовки столбцов от основного текста (тела таблицы). Чтобы создать такую таблицу, необходимо выполнить следующее.<br></br>   1. Сгруппировать строки нужным образом.<br></br>   2. Указать видимость границы между группами строк.<br></br></div><h2 id="idm139732198178256">3.7. Выравнивание таблицы и содержимого ячеек
</h2><div style="text-align: justify" class="hsection2">   Для выравнивания элементов таблиц по горизонтали и вертикали в элементах TABLE, TR, TH и TD используют атрибуты align и valign.<br></br>   Атрибут align применяется ко всем элементам таблицы и определяет общее горизонтальное выравнивание:<br></br>   • &lt;table align=left/right/center&gt; – таблицы на странице по левому краю/правому краю/по центру;<br></br>   • &lt;tr align=left/right/center&gt; – элементов строки по левому краю/правому краю/по центру;<br></br>   • &lt;th align=left/right/center&gt; – заголовка таблицы по левому краю/правому краю/по центру (по умолчанию по центру);<br></br>   • &lt;td align=left/right/center/char&gt; – данных в ячейке по левому краю/ правому краю/по центру/по заданному символу (по умолчанию по левому краю).<br></br>   Атрибут valign также применяется ко всем элементам таблицы и определяет общее вертикальное выравнивание:<br></br>   • &lt;table valign=bottom/middle/top&gt; – элементов таблицы внизу/по центру/вверху (по умолчанию по центру);<br></br>   • &lt;tr valign=bottom/middle/top&gt; – элементов строки внизу/по центру/ вверху;<br></br>   • &lt;th valign=bottom/middle/top&gt; – заголовка таблицы внизу/по центру/ вверху;<br></br>   • &lt;td valign=bottom/middle/top&gt; – данных в ячейке внизу/по центру/ вверху.<br></br>   В листинге 3.6 приведен пример использования в различных комбинациях описанных выше атрибутов форматирования таблицы и содержимого ячеек (рис. 3.11).<br></br><h5 class="subtitle"><b>Листинг 3.6.</b> Пример использования выравнивания таблицы и содержимого ячеек</h5>   &lt;html&gt;<br></br>   &lt;head&gt;<br></br>   &lt;title&gt;Простая HTML-таблица&lt;/title&gt;<br></br>   &lt;/head&gt;<br></br>   &lt;body&gt;<br></br>   &lt;table border="4" bordercolor="#000000" cellspacing="0" cellpadding="0"width= "400" height="150" align=center&gt;<br></br>   &lt;caption&gt;Наименование товара&lt;/caption&gt;<br></br>   &lt;tr&gt;&lt;th&gt;Товар &lt;/th&gt;&lt;th&gt;Код&lt;/th&gt;&lt;th&gt;Количество&lt;/th&gt;&lt;th&gt;Цена &lt;/th&gt;&lt;/tr&gt;<br></br>   &lt;tr valign=bottom align=center&gt;<br></br>   &lt;td&gt;Клей&lt;/td&gt;&lt;td&gt;028&lt;/td&gt;&lt;td&gt;190 шт &lt;/td&gt;&lt;td&gt;12,2 руб&lt;/td&gt;&lt;/tr&gt;<br></br>   &lt;tr valign=bottom align=center&gt;<br></br>   &lt;td&gt;Скотч&lt;/td&gt;&lt;td&gt;058&lt;/td&gt;&lt;td&gt;120 шт &lt;/td&gt;&lt;td&gt;4,6 руб &lt;/td&gt;&lt;/tr&gt;<br></br>   &lt;tr valign=bottom align=center&gt;<br></br>   &lt;td&gt;Ластик&lt;/td&gt;&lt;td&gt;986&lt;/td&gt;&lt;td&gt;100 шт &lt;/td&gt;&lt;td&gt;2,3 руб &lt;/td&gt;&lt;/tr&gt;<br></br>   &lt;/table&gt;<br></br>   &lt;/body&gt;<br></br>   &lt;/html&gt;<br></br><div style="text-align: center;"><img src="i_044.png" alt=""></img></div>   <b>Рис. 3.11.</b> Пример использования выравнивания таблицы и содержимого ячеек<br></br></div><h2 id="idm139732198158672">3.8. Объединение ячеек таблицы
</h2><div style="text-align: justify" class="hsection2">   На практике встречается большое количество таблиц, в которых одна ячейка объединяет в себе несколько ячеек по высоте и ширине (см. рис. 3.2). В HTML ячейки объединяют с помощью атрибутов colspan и rowspan. Атрибут colspan определяет количество ячеек, на которые простирается данная ячейка по горизонтали, а rowspan – по вертикали.<br></br>   На рис. 3.12 изображена таблица с объединенными ячейками. Заголовок таблицы находится в ячейке, объединяющей все три ячейки строки. Таблица содержит еще две ячейки, каждая из которых объединяет две ячейки по вертикали. Код такой таблицы приведен в листинге 3.7.<br></br><div class="wrap_pict"><div style="text-align: center;"><img src="i_045.png" alt=""></img></div>   <b>Рис. 3.12.</b> Таблица с объединенными ячейками<br></br></div><br></br><h5 class="subtitle"><b>Листинг 3.7.</b> Пример использования атрибутов объединения ячеек</h5>   &lt;html&gt;<br></br>   &lt;head&gt;<br></br>   &lt;title&gt;HTML-таблица&lt;/title&gt;<br></br>   &lt;head&gt;<br></br>   &lt;body&gt;<br></br>   &lt;table border="4" bordercolor="#000000" cellspacing="0" cellpadding="5" &gt;<br></br>   &lt;tr align=center&gt;&lt;th colspan=3&gt;Ячейка объединяет в себе все ячейки строки &lt;/th&gt;&lt;/tr&gt;<br></br>   &lt;tr align=center&gt;&lt;td rowspan=2&gt;Ячейка на две строки &lt;/td&gt;<br></br>   &lt;td&gt;Ячейка 2х2&lt;/td&gt;&lt;td&gt;Ячейка 2х3&lt;/td&gt;&lt;/tr&gt;<br></br>   &lt;tr align=center&gt;&lt;td&gt;Ячейка 3х2&lt;/td&gt;&lt;td&gt;Ячейка 3х3&lt;/td&gt;&lt;/tr&gt;<br></br>   &lt;tr align=center&gt;&lt;td rowspan=2&gt;Ячейка на две строки&lt;/td&gt;<br></br>   &lt;td&gt;Ячейка 4х2&lt;/td&gt;&lt;td&gt;Ячейка 4х3&lt;/td&gt;&lt;/tr&gt;<br></br>   &lt;tr align=center&gt;&lt;td&gt;Ячейка 5х2&lt;/td&gt;&lt;td&gt;Ячейка 5х3&lt;/td&gt;&lt;/tr&gt;<br></br>   &lt;/table&gt;<br></br>   &lt;/body&gt;<br></br>   &lt;/html&gt;<br></br></div><h2 id="idm139732198167888">3.9. Установка фонового цвета или рисунка ячейки
</h2><div style="text-align: justify" class="hsection2">   В HTML возможны различные варианты установки фонового цвета или рисунка. Благодаря атрибуту bgcolor можно изменять цвет содержимого ячейки, строки, группы столбцов, группы строк, таблицы целиком.<br></br>   Используя конструкцию &lt;td bgcolor= "#000000"&gt;, чередующуюся с конструкцией &lt;td&gt;&lt;/td&gt; (со стандартным фоновым цветом ячеек), можно создать таблицу, изображенную на рис. 3.13.<br></br><div class="wrap_pict"><div style="text-align: center;"><img src="i_046.png" alt=""></img></div>   <b>Рис. 3.13.</b> Пример использования атрибута bgcolor<br></br></div><br></br>   С помощью атрибута background можно задать графический фон ячейки или таблицы целиком, указав путь к изображению. Например, &lt;td background="img\fon.gif"&gt;.<br></br>   Если размеры изображения превышают габариты ячейки или таблицы, для которых оно предназначено, браузер обрезает его таким образом, чтобы оно уместилось в пределах соответствующего объекта.<br></br></div><h2 id="idm139732198138320">3.10. Создание вложенных таблиц
</h2><div style="text-align: justify" class="hsection2">   Существуют такие моменты, когда необходимо создать ячейки, границы которых не должны совпадать (рис. 3.14). Здесь атрибут colspan бессилен.<br></br><div class="wrap_pict"><div style="text-align: center;"><img src="i_047.png" alt=""></img></div>   <b>Рис. 3.14.</b> Сложная HTML-таблица<br></br></div><br></br>   Команды, управляющие созданием и отображением таблиц, допускают вложение одного элемента TABLE внутрь другого, поэтому в ячейке можно создать новую таблицу с независимой структурой.<br></br>   В листинге 3.8 приведен код таблицы, изображенной на рис. 3.13. Здесь применяется метод вложения одной таблицы в другую. Внешняя таблица состоит из двух строк. Первая строка содержит четыре ячейки, вторая – таблицу со своей независимой структурой. Внутренняя таблица, в свою очередь, содержит две строки, каждая из которых содержит по три ячейки.<br></br><h5 class="subtitle"><b>Листинг 3.8.</b> Пример таблицы, которая содержит еще одну таблицу</h5>   &lt;html&gt;<br></br>   &lt;head&gt;<br></br>   &lt;title&gt;HTML-таблица&lt;/title&gt;<br></br>   &lt;head&gt;<br></br>   &lt;body&gt;<br></br>   &lt;table border="4" bordercolor="#000000" cellspacing="0" cellpadding="10"&gt;<br></br>   &lt;caption&gt;Создание вложенных таблиц&lt;/caption&gt;<br></br>   &lt;tr&gt;&lt;td&gt; 1x1&lt;/td&gt;&lt;td&gt;1x2&lt;/td&gt;&lt;td&gt;1x3&lt;/td&gt;&lt;td&gt;1x4&lt;/td&gt;&lt;/tr&gt;<br></br>   &lt;tr&gt;&lt;td colspan=4&gt;<br></br>   &lt;table border="3" bordercolor="#000000" cellspacing="0" cellpadding="10"&gt;<br></br>   &lt;tr&gt;&lt;td&gt; 1x1&lt;/td&gt;&lt;td&gt;1x2&lt;/td&gt;&lt;td&gt;1x3&lt;/td&gt;&lt;/tr&gt;<br></br>   &lt;tr&gt;&lt;td&gt; 2x1&lt;/td&gt;&lt;td&gt;2x2&lt;/td&gt;&lt;td&gt;2x3&lt;/td&gt;&lt;/tr&gt;<br></br>   &lt;/table&gt;<br></br>   &lt;/td&gt;<br></br>   &lt;/tr&gt;<br></br>   &lt;/table&gt;<br></br>   &lt;/body&gt;<br></br>   &lt;/html&gt;<br></br></div><h2 id="idm139732198148560">Резюме
</h2><div style="text-align: justify" class="hsection2">   В заключение следует отметить, что таблицы являются важнейшей частью любой веб-страницы. Для контроля над элементами веб-узла фирмы Microsoft (<a href="http://www.microsoft.com/">www.microsoft.com</a>) использованы таблицы.<br></br>   Умелое обращение с таблицами позволяет жестко связать текстовые блоки документа с графикой и другими объектами. Использование таблиц позволит странице загружаться быстрее, но большие рисунки следует разбить на несколько маленьких. Чтобы не нарушить целостность всего рисунка, его отдельные части следует расположить в ячейках таблицы таким образом, чтобы они образовали целый рисунок.<br></br>   Использование таблиц также позволит вам разделить всю HTML-страницу на функциональные части: заголовок страницы, место для рекламы, панель инструментов и т. д. Подобное разделение страницы даст возможность быстро создать свой индивидуальный «остов» сайта, который в последующем можно использовать для создания других страниц.<br></br></div></div><h1 xmlns="http://www.w3.org/1999/xhtml" id="idm139732198150864" class="master">Глава 4<br></br>
Добавление изображений и мультимедиа
</h1><div xmlns="http://www.w3.org/1999/xhtml" style="text-align: justify" class="hsection1"><div style="text-align: justify" class="section2">   4.1. Встраивание изображений<br></br>
   4.2. Добавление мультимедиа<br></br>
   При создании сайта невозможно обойтись без использования активных объектов вроде Flash-анимации, видео или картинок. Так мы можем улучшить вид сайта, сделать его ярче, интереснее и удобнее для посетителей. Однако неграмотное использование мультимедиа на странице способно погубить самые лучшие и интересные сайты. Поэтому в данной главе, помимо технических аспектов встраивания мультимедиа, будут освещены эстетические аспекты и моменты, связанные с удобством для посетителя.<br></br>
</div><h2 id="idm139732198120528">4.1. Встраивание изображений
</h2><div style="text-align: justify" class="hsection2"><div style="text-align: justify" class="section3">   Начнем с добавления изображения, потому что это самый простой для добавления и самый распространенный мультимедийный элемент, встречающийся в Интернете. У изображений много плюсов: статичность, небольшие размеры файлов (относительно других типов мультимедиа-содержимого), широкая область применения. Сейчас трудно представить сайт без картинок. Дизайнеры научились использовать их очень разумно. Современные скорости соединений позволяют размещать большое количество графики на странице. Однако нужно знать меру, сайт не должен выглядеть пустым, но в то же время не стоит и злоупотреблять рисунками. Грамотное и уместное использование изображений поможет сделать сайт красивым, интересным и удобным. Бывают ситуации, когда без большого количества картинок невозможно обойтись, например при создании галереи, фотоальбома, каталога. В таких случаях умелое распределение файлов по сайту и удобная навигация помогут сэкономить время загрузки и трафик. Получается, что при создании сайта без изображений вам не обойтись, этот объект является самым простым, удобным и распространенным.<br></br>
   Для встраивания изображений в HTML-документ применяется элемент IMG. Он имеет обязательный атрибут src, значением которого должен быть адрес встраиваемого изображения.<br></br>
   Простейший вариант записи для включения картинки: &lt;IMG src=" image.jpg"&gt;. При такой записи размер картинки на экране будет соответствовать ее реальному размеру.<br></br>
<blockquote><div>   <b>Примечание</b><br></br>
   Адрес изображения может быть указан либо полностью (например, когда картинка находится на другом сервере (<a href="http://www.mypage.ru/IMG/myfoto.jpg">http://www.mypage.ru/IMG/myfoto.jpg</a>)), либо относительно местоположения вашего документа (например, если картинка находится во вложенной папке (IMG/myfoto.jpg)). Во втором случае для указания директории, находящейся выше в иерархии каталогов, используются символы../ (переход из папки DOC, находящейся в одном каталоге с папкой IMG, будет выглядеть так:. /IMG/myfoto.jpg).<br></br>
</div></blockquote>   В листинге 4.1 продемонстрирован простейший вариант встраивания картинки.<br></br>
<h5 class="subtitle"><b>Листинг 4.1.</b> Простое встраивание изображения в документ</h5>   &lt;html&gt;<br></br>
   &lt;head&gt;<br></br>
   &lt;title&gt;Встраивание изображения&lt;/title&gt;<br></br>
   &lt;/head&gt;<br></br>
   &lt;body&gt;<br></br>
   &lt;img src="image.jpg"/&gt;<br></br>
   &lt;/body&gt;<br></br>
   &lt;/html&gt;<br></br>
   На рис. 4.1 показан результат обработки браузером кода из листинга 4.1 – простое встраивание картинки, без редактирования.<br></br>
<div class="wrap_pict"><div style="text-align: center;"><img src="i_048.png" alt=""></img></div>   <b>Рис. 4.1.</b> Вставка изображения<br></br>
</div><br></br>   Рисунок на странице отображается в реальном размере. Это простейший вариант вставки картинки, его можно использовать, когда нет необходимости ни в какой трансформации рисунка, например, если рисунок будет единственным элементом на странице.<br></br>
   Один рисунок на странице встречается нечасто, обычно на странице, помимо рисунка, присутствуют другие объекты, и большие размеры картинки становятся проблемой, но ничего страшного – размеры изображения можно легко подкорректировать.<br></br>
</div><h3 id="idm139732198130384">Размер изображения
</h3><div style="text-align: justify" class="hsection3">   Если необходимо значительно изменить размер изображения, то лучше использовать специальные программы, однако в небольших пределах допустимо использовать и атрибуты элемента IMG.<br></br>   Чтобы редактировать размер картинки, используют атрибуты width и height. Их значения можно указывать в пикселах или процентах от размера окна (в этом случае после размера ставится знак %).<br></br><blockquote><div>   <b>Примечание</b><br></br>
   При изменении размеров окна картинка, размер которой указан в процентах, тоже меняет размер.<br></br>
</div></blockquote>   Можно указать только один из атрибутов, и тогда второй будет вычисляться автоматически для сохранения пропорций рисунка.<br></br>   Меняя размер картинки с помощью атрибутов элемента IMG, внимательно следите за изображением, есть вероятность того, что рисунок исказится. Сам браузер не обрабатывает картинки под новый размер, поэтому, если размер выставлен неаккуратно, из произведения искусства рисунок может превратиться во что-то непонятное (особенно если задать размер больше, чем в реальности). Искажение пропорций тоже не приводит к улучшению качества изображения, как видно на рис. 4.2.<br></br><div class="wrap_pict"><div style="text-align: center;"><img src="i_049.png" alt=""></img></div>   <b>Рис. 4.2.</b> Размеры изображения<br></br></div><br></br>   В листинге 4.2 показан пример встраивания изображения с заданными размерами.<br></br><h5 class="subtitle"><b>Листинг 4.2.</b> Задание размеров изображения</h5>   &lt;html&gt;<br></br>   &lt;head&gt;<br></br>   &lt;title&gt;Встраивание изображения&lt;/title&gt;<br></br>   &lt;/head&gt;<br></br>   &lt;body&gt;<br></br>   Задана только ширина в пикселах &lt;br/&gt;<br></br>   &lt;img src="image.jpg" width="60"/&gt;<br></br>   Задана ширина в процентах&lt;br/&gt;<br></br>   &lt;img src="image.jpg" width="50%"/&gt;<br></br>   Ширина и высота заданы непропорционально (изображение искажается)&lt;br/&gt;<br></br>   &lt;img src="image.jpg" width="50" height="150"/&gt;<br></br>   &lt;/body&gt;<br></br>   &lt;/html&gt;IMG_0628.jpg<br></br><br></br>   В листинге 4.2 для первого изображения задана только ширина, высота вычисляется автоматически. Для второго изображения размер определен в процентах, а для третьего установлены неверные размеры, которые искажают картинку.<br></br>   Результат работы листинга 4.2 показан на рис. 4.2.<br></br>   На рис. 4.2 видно, что размеры все-таки имеют значение, особенно для картинок, поэтому следить за их изменением нужно очень внимательно. Если нет необходимости в изменении размеров, то задавайте размеры картинки, соответствующие реальности. Это позволит избежать искажений и ускорит обработку картинки браузером.<br></br><blockquote><div>   <b>Совет</b><br></br>
   Если вам нужно значительно изменить размер картинки, то используйте специальные программы для работы с изображениями. Они смогут проделать эту операцию, минимально исказив картинку или вовсе без искажений.<br></br>
</div></blockquote>   Помимо размеров картинки, на внешний вид сайта влияет расположение изображений.<br></br></div><h3 id="idm139732208686544">Выравнивание изображения
</h3><div style="text-align: justify" class="hsection3">   Расположение картинки влияет на общий вид страницы, на восприятие текста вокруг нее. Удобство чтения текста, находящегося около картинки, сильно зависит от их взаимного расположения.<br></br>   Есть множество вариантов выравнивания картинок относительно текста, и за все отвечает атрибут align элемента IMG. Он позволяет выравнивать изображения с правой, с левой стороны окна или относительно элементов строки.<br></br>   У атрибута align много значений, которые позволяют установить картинку именно так, как надо, и именно там, где надо.<br></br>   Горизонтальное выравнивание:<br></br>   • left – по левому краю;<br></br>   • right – по правому краю.<br></br>   Вертикальное выравнивание:<br></br>   • top – выравнивание верхней границы картинки по самому высокому элементу строки;<br></br>   • texttop – выравнивание верхней границы картинки по самому высокому элементу текста;<br></br>   • middle – середина изображения выравнивается по базовой линии строки;<br></br>   • absmiddle – середина изображения выравнивается по середине строки;<br></br>   • baseline – выравнивание нижней границы изображения по базовой линии строки;<br></br>   • bottom – аналогично baseline;<br></br>   • absbottom – нижняя граница изображения выравнивается по нижней границе текущей строки.<br></br><blockquote><div>   <b>Примечание</b><br></br>
   Базовая линия строки – это линия, на которой расположены все элементы. При этом некоторые буквы выступают за эту линию, например буква «р». Ее палочка заканчивается ниже базовой линии и будет самым нижним элементом строки. Заглавные буквы, наоборот, выступают сверху этой линии.<br></br>
</div></blockquote>   В листинге 4.3 приведены примеры выравнивания картинок относительно текста по вертикали.<br></br><h5 class="subtitle"><b>Листинг 4.3.</b> Выравнивание картинки по вертикали</h5>   &lt;html&gt;<br></br>   &lt;head&gt;<br></br>   &lt;title&gt;Встраивание изображения&lt;/title&gt;<br></br>   &lt;/head&gt;<br></br>   &lt;body&gt;<br></br>   &lt;img src="image.jpg" width="70" align="top"/&gt;Выравнивание по самому верхнему элементу в строке&lt;br/&gt;<br></br>   &lt;img src="image.jpg" width="70" align="absbottom"/&gt;Нижняя граница изображения выравнивается по нижней границе текущей строки&lt;br/&gt;<br></br>   &lt;img src="image.jpg" width="70" align="bottom"/&gt;Нижняя граница изображения выравнивается по базовой линии строки&lt;br/&gt;<br></br>   &lt;img src="image.jpg" width="70" align="middle"/&gt;Середина изображения выравнивается по базовой линии строки&lt;br/&gt; &lt;/body&gt;<br></br>   &lt;/html&gt;<br></br>   На рис. 4.3 показан результат обработки кода из листинга 4.3, где можно увидеть разницу между выравниваниями по базовой линии и по границам строки.<br></br><div class="wrap_pict"><div style="text-align: center;"><img src="i_050.png" alt=""></img></div>   <b>Рис. 4.3.</b> Выравнивание по вертикали<br></br></div><br></br>   С выравниваниями по горизонтали все проще. Код для выравнивания по горизонтали приведен в листинге 4.4.<br></br><h5 class="subtitle"><b>Листинг 4.4.</b> Выравнивание картинки по горизонтали</h5>   &lt;html&gt;<br></br>   &lt;head&gt;<br></br>   &lt;title&gt;Встраивание изображения&lt;/title&gt;<br></br>   &lt;/head&gt;<br></br>   &lt;body&gt;<br></br>   &lt;img src="image.jpg" width="100" align="right" /&gt;<br></br>   Кролики – потрясающие животные, особенно декоративные. Многие люди заводят их дома вместо кошек или собак, потому что они менее прихотливы. Кролики – чистоплотные животные, и их хозяева не испытывают проблем с воспитанием. Кормить этих зверюшек просто: овощи, сено и немного специального корма. Следите, чтобы клетка была чистой и в ней всегда лежали свежие опилки. Если вы рискуете выпускать зверя на прогулки по дому, то следите за проводами. Кролик может решить, что провода – это сено, и перегрызть их. &lt;/html&gt;<br></br><br></br>   На рис. 4.4 виден результат обработки браузером кода из листинга 4.4, текст обтекает картинку слева.<br></br><div class="wrap_pict"><div style="text-align: center;"><img src="i_051.png" alt=""></img></div>   <b>Рис. 4.4.</b> Выравнивание по горизонтали<br></br></div><br></br>   При горизонтальном выравнивании текст плотно обтекает картинку и для внешнего вида страницы важным параметром становится расстояние между текстом и изображением.<br></br></div><h3 id="idm139732208673104">Расстояние между текстом и изображением
</h3><div style="text-align: justify" class="hsection3">   Расстояние между текстом и картинкой влияет на читаемость текста. Очень маленькое или очень большое расстояние может оказаться неудобным.<br></br>   Чтобы отодвинуть текст от картинки, используют атрибуты hspace и vspace элемента IMG. Они задают расстояние в пикселах между изображением и текстом по горизонтали и вертикали.<br></br>   В листинге 4.5 указано очень большое расстояние по вертикали (100 пикселов) и очень маленькое по горизонтали (1 пиксел). На рис. 4.5 видно, что такое сочетание расстояний неудобно для чтения.<br></br><div class="wrap_pict"><div style="text-align: center;"><img src="i_052.png" alt=""></img></div>   <b>Рис. 4.5.</b> Задано расстояние от картинки до текста<br></br></div><br></br><h5 class="subtitle"><b>Листинг 4.5.</b> Задание расстояния от текста до изображения</h5>   &lt;html&gt;<br></br>   &lt;head&gt;<br></br>   &lt;title&gt;Встраивание изображения&lt;/title&gt;<br></br>   &lt;/head&gt;<br></br>   &lt;body&gt;<br></br>   &lt;img src="image.jpg" width="100" align="right" vspace="100" hspace="1"/&gt;Кролики – потрясающие животные, особенно декоративные. Многие люди заводят их дома вместо кошек или собак, потому что они менее прихотливы. Кролики – чистоплотные животные, и их хозяева не испытывают проблем с воспитанием. Кормить этих зверюшек просто: овощи, сено и немного специального корма. Следите, чтобы клетка была чистой и в ней всегда лежали свежие опилки. Если вы рискуете выпускать зверя на прогулки по дому, то следите за проводами. Кролик может решить, что провода – это сено, и перегрызть их. &lt;br/&gt; &lt;/body&gt;<br></br>   &lt;/html&gt;<br></br></div><h3 id="idm139732208630096">Рамка вокруг изображения
</h3><div style="text-align: justify" class="hsection3">   Кроме регулировки расстояния до текста, есть еще один способ отделить картинку от остального содержимого страницы.<br></br>   Отделить изображение от текста можно, поступив с ним, как с обычной картиной: поставив в рамку. Это делается с помощью атрибута border, значение которого указывает ширину рамки в пикселах.<br></br>   В листинге 4.6 задана рамка шириной 10 пикселов, а слева и справа указаны разумные расстояния по 50 пикселов. На рис. 4.6 видно, что с такими параметрами изображение выглядит намного лучше, чем в предыдущем примере, и текст гораздо проще воспринимать.<br></br><div class="wrap_pict"><div style="text-align: center;"><img src="i_053.png" alt=""></img></div>   <b>Рис. 4.6.</b> Рамка<br></br></div><br></br><h5 class="subtitle"><b>Листинг 4.6.</b> Задание рамки вокруг изображения</h5>   &lt;html&gt;<br></br>   &lt;head&gt;<br></br>   &lt;title&gt;Встраивание изображения&lt;/title&gt;<br></br>   &lt;/head&gt;<br></br>   &lt;body&gt;<br></br>   &lt;img src="image.jpg" width="100" align="right" vspace="10" hspace="10" border="20"/&gt;Кролики – потрясающие животные, особенно декоративные. Многие люди заводят их дома вместо кошек или собак, потому что они менее прихотливы. Кролики – чистоплотные животные, и их хозяева не испытывают проблем с воспитанием. Кормить этих зверюшек просто: овощи, сено и немного специального корма. Следите, чтобы клетка была чистой и в ней всегда лежали свежие опилки. Если вы рискуете выпускать зверя на прогулки по дому, то следите за проводами. Кролик может решить, что провода – это сено, и перегрызть их.<br></br>   &lt;/body&gt;<br></br>   &lt;/html&gt;<br></br></div><h3 id="idm139732208636752">Альтернативный текст
</h3><div style="text-align: justify" class="hsection3">   С атрибутами, отвечающими за оформление картинки, все понятно, но существуют еще атрибуты, напрямую не влияющие на отображение картинки, но тем не менее сильно облегчающие жизнь посетителям сайта.<br></br>   Иногда получается так, что картинка не загружается, например, когда пользователь отключил загрузку картинок или сервер, на котором она расположена, «упал». Если размеры картинки указаны в явном виде, то посетитель имеет о них представление, однако зачем ему этот размер, если он не может даже предположить, что изображено на рисунке.<br></br>   В таких ситуациях может помочь атрибут alt. Его значение – текст, который будет показан при наведении указателя мыши на картинку или если картинка не загрузится. Это даст возможность пользователям, которые не видят картинок, понять, хотят ли они увидеть их вообще, а тем, кто видит, поможет понять, что именно они видят.<br></br>   В листинге 4.7 приведен пример кода для задания альтернативного текста.<br></br><h5 class="subtitle"><b>Листинг 4.7.</b> Альтернативный текст</h5>   &lt;html&gt;<br></br>   &lt;head&gt;<br></br>   &lt;title&gt;Встраивание изображения&lt;/title&gt;<br></br>   &lt;/head&gt;<br></br>   &lt;body&gt;<br></br>   &lt;img src="image.jpg" width="100" align="right" vspace="50" hspace="50" alt="Фотография карликового вислоухого кролика"/&gt;<br></br>   &lt;/body&gt;<br></br>   &lt;/html&gt;<br></br>   На рис. 4.7 показан результат обработки кода из листинга 4.7 при условии, что изображение загрузилось.<br></br><div class="wrap_pict"><div style="text-align: center;"><img src="i_054.png" alt=""></img></div>   <b>Рис. 4.7.</b> Альтернативный текст при загруженном рисунке<br></br></div><br></br>   Альтернативный текст всплывает при наведении указателя мыши на картинку.<br></br>   На рис. 4.8 показан результат обработки кода из того же листинга, но в случае, когда изображение не загрузилось.<br></br><div class="wrap_pict"><div style="text-align: center;"><img src="i_055.png" alt=""></img></div>   <b>Рис. 4.8.</b> Альтернативный текст при незагруженном рисунке<br></br></div><br></br>   Вместо картинки виден поясняющий текст, и при наведении указателя мыши на рисунок появляется всплывающая подсказка.<br></br></div><h3 id="idm139732208613584">Предварительная загрузка
</h3><div style="text-align: justify" class="hsection3">   Если изображений на сайте много и их загрузка занимает немало времени, можно не испытывать терпение посетителя, а дать ему примерное представление о том, что он увидит.<br></br>   Это делается с помощью атрибута lowsrc, где в качестве значения используется адрес изображения худшего качества, но того же содержания, что и основная картинка. При первом проходе браузером страницы это изображение будет быстро загружено, и у пользователя появится представление о том, что он увидит дальше. При последующем проходе страницы браузер загрузит главное изображение хорошего качества.<br></br><blockquote><div>   <b>Совет</b><br></br>
   Для получения изображения худшего качества нужно использовать специальные программы для работы с изображениями. В них возможно уменьшение размеров изображения за счет уменьшения количества цветов, например.<br></br>
</div></blockquote>   В листинге 4.8 приведен пример кода, который задает изображение с предварительной загрузкой.<br></br><h5 class="subtitle"><b>Листинг 4.8.</b> Изображение с предварительной загрузкой</h5>   &lt;html&gt;<br></br>   &lt;head&gt;<br></br>   &lt;title&gt;Встраивание изображения&lt;/title&gt;<br></br>   &lt;/head&gt;<br></br>   &lt;body&gt;<br></br>   &lt;img src="image.jpg" width="100" vspace="10" hspace="10" lowsrc= "lowimage.jpg"&gt;<br></br>   &lt;/body&gt;<br></br>   &lt;/html&gt;<br></br>   На рис. 4.9 показан результат предварительной загрузки изображения, на следующем проходе браузер загрузит изображение нормального качества.<br></br><div class="wrap_pict"><div style="text-align: center;"><img src="i_056.png" alt=""></img></div>   <b>Рис. 4.9.</b> Предварительное изображение<br></br></div><br></br>   Альтернативный текст и предварительная загрузка изображения делают сайт удобнее.<br></br></div><h3 id="idm139732208622032">Ссылки изображения
</h3><div style="text-align: justify" class="hsection3">   Используя картинки, можно повысить функциональность сайта, создавая изображения-ссылки.<br></br>   Ссылки – главное в Интернете, и, естественно, существует возможность использовать в качестве ссылок изображения.<br></br>   Для создания ссылки из картинки достаточно поместить элемент IMG внутри тегов &lt;А&gt; и &lt;/A&gt;, при этом вокруг картинки появится рамка, которой можно управлять с помощью атрибута border. Синие рамки вокруг рисунков выглядят некрасиво, зато с ними сразу понятно, что можно щелкнуть кнопкой мыши на этой картинке и перейти на другую страницу.<br></br>   В листинге 4.9 приведены примеры создания ссылок-изображений с различными размерами рамок.<br></br><h5 class="subtitle"><b>Листинг 4.9.</b> Создание изображений-ссылок</h5>   &lt;html&gt;<br></br>   &lt;head&gt;<br></br>   &lt;title&gt;Встраивание изображения&lt;/title&gt;<br></br>   &lt;/head&gt;<br></br>   &lt;body&gt;<br></br>   Ссылка без задания атрибута border (рамка ставится по умолчанию)&lt;br/&gt;<br></br>   &lt;a href="image.jpg"&gt;&lt;img src="image.jpg" width="100" vspace="10" hspace="10" alt="Фотография карликового вислоухого кролика" /&gt; &lt;/a&gt;&lt;br /&gt;<br></br>   Ссылка без рамки&lt;br/&gt;<br></br>   &lt;a href="image.jpg"&gt;&lt;img src="image.jpg" width="100" vspace="10" hspace="10" alt="Фотография карликового вислоухого кролика " border="0" /&gt; &lt;/a&gt;&lt;br /&gt;<br></br>   Рамка в 10 пикселов&lt;br/&gt;<br></br>   &lt;a href="image.jpg"&gt;&lt;img src="image.jpg" width="100" vspace="10" hspace="10" alt="Фотография карликового вислоухого кролика " border="10" /&gt; &lt;/a&gt;&lt;br/&gt;<br></br>   &lt;/body&gt;<br></br>   &lt;/html&gt;<br></br>   Результат обработки кода из листинга 4.9 можно увидеть на рис. 4.10.<br></br><div class="wrap_pict"><div style="text-align: center;"><img src="i_057.png" alt=""></img></div>   <b>Рис. 4.10.</b> Изображения-ссылки<br></br></div><br></br>   Возможность делать из рисунков ссылки позволяет удобнее размещать информацию на сайтах, где необходимо использовать много изображений.<br></br></div><h3 id="idm139732202856528">Галереи изображений
</h3><div style="text-align: justify" class="hsection3">   При создании галерей используют возможность менять размер картинок и таким образом создают галереи, в которых пользователь сначала видит миниатюрные варианты изображений, а затем может выбрать необходимую ему картинку для загрузки. Посетитель щелкает кнопкой мыши на картинке, и она открывается в полный размер на новой странице.<br></br>   Примером может служить поиск картинок в поисковых системах. На основе галерей можно делать фотоальбомы и выставки картин, эта технология часто используется при создании каталогов.<br></br>   Теперь вы можете добавлять любые изображения на сайт и делать это наилучшим образом. Вы знаете, как корректировать внешний вид картинки, ее размеры и расположение на странице, а также как добавлять элементы, позволяющие посетителю просматривать ваши рисунки с комфортом. Теперь вы умеете создавать галереи изображений, а надо сказать, что картинки чаще всего структурируют именно в галереи. В общем, создание сайта с графическим наполнением – больше не проблема для вас.<br></br></div></div><h2 id="idm139732202858320">4.2. Добавление мультимедиа
</h2><div style="text-align: justify" class="hsection2"><div style="text-align: justify" class="section3">   Что же делать, если, помимо коллекции картинок, у вас есть коллекция аудио или видео и вы хотите поделиться с посетителями сайта? В этом случае вы можете поместить на страницу ссылку на тот мультимедиа-файл, который желаете сделать доступным, или просто встроить его на страницу вместе с проигрывателем.<br></br>
</div><h3 id="idm139732202859472">Ссылки на мультимедийные файлы
</h3><div style="text-align: justify" class="hsection3">   Ссылки на файлы мультимедиа ничем не отличаются от ссылок на другие страницы. Как видно из листинга 4.10, при щелчке кнопкой мыши на такой ссылке браузер откроет музыкальный файл в новом окне. Для удобства посетителей советую использовать атрибут title элемента A, он работает так же, как альтернативный текст для картинок. При наведении указателя мыши на ссылку всплывает строка с более подробной информацией о файле (рис. 4.11).<br></br><div class="wrap_pict"><div style="text-align: center;"><img src="i_058.png" alt=""></img></div>   <b>Рис. 4.11.</b> Ссылки на мультимедиа<br></br></div><br></br>   В листинге 4.10 приведен пример кода для создания ссылок на мультимедиа.<br></br><h5 class="subtitle"><b>Листинг 4.10.</b> Ссылки на мультимедиа</h5>   &lt;html&gt;<br></br>   &lt;head&gt;<br></br>   &lt;title&gt;Ссылки на мультимедиа&lt;/title&gt;<br></br>   &lt;/head&gt;<br></br>   &lt;body&gt;<br></br>   &lt;a href="test.mp3" title="Test"&gt;Test audio&lt;/a&gt;<br></br>   &lt;/body&gt;<br></br>   &lt;/html&gt;<br></br><br></br>   Указание ссылки на объект – самый простой вариант для реализации доступа к нему. Плюсом этого способа являются маленький объем страницы и простота использования. С помощью ссылки посетитель может сохранить файл у себя на компьютере, а затем проиграть его наиболее подходящим для себя проигрывателем. Для удобства посетителей сайта можно указывать размер мультимедийного файла.<br></br>   Однако этот способ не помогает, если нужно, чтобы пользователь посмотрел Flash-файл. С их помощью обычно «раскрашивают» сам сайт; яркие и динамичные Flash-объекты могут нести смысловую нагрузку и быть неотъемлемой частью страницы, поэтому их удобнее встраивать сразу в страницу, а не передавать по ссылке. Хотя, если ваш Flash-мультик – самостоятельное произведение, можно использовать способ со ссылками.<br></br></div><h3 id="idm139732202866384">Встраивание объектов
</h3><div style="text-align: justify" class="hsection3">   Итак, есть способ загрузить наш мультимедиа-файл на страницу сразу, при этом надо учитывать, с помощью какой программы будет воспроизводиться файл, потому что загружать динамический объект нужно вместе с проигрывателем. Для обращения к этой программе необходимо использовать элемент OBJECT. Он позволит управлять многими параметрами проигрывателя. В предыдущих версиях языка для встраивания объектов использовали элементы EMBED и APPLET, но сейчас рекомендуют к использованию именно OBJECT. Этому элементу необходим закрывающий тег &lt;/OBJECT&gt;.<br></br><blockquote><div>   <b>Примечание</b><br></br>
   В последнем стандарте принято использование элемента OBJECT, но, чтобы избежать проблем у пользователей, которые работают со старыми версиями браузеров, не распознающими этот элемент, рекомендуется внутрь его встраивать элемент EMBED.<br></br>
</div></blockquote>   Этот элемент предоставляет большие возможности для управления встраиваемым объектом. Внутри тегов &lt;OBJECT&gt; и &lt;/OBJECT&gt; могут находиться элементы PARAM, которые не требуют наличия закрывающего тега. С их помощью программам воспроизведения передают параметры, указывающие вид проигрывателя, тип воспроизведения и множество других параметров. С точки зрения управления содержимым и внешним видом сайта это очень удобно. Создатель сайта получает гибкий инструмент для управления воспроизведением мультимедиа на странице. В результате сайт выглядит и работает именно так, как хочется вам.<br></br>   Начнем рассмотрение встраивания объектов с основного элемента, необходимого для этого, – элемента OBJECT.<br></br></div><h3 id="idm139732202869200">Атрибуты элемента OBJECT
</h3><div style="text-align: justify" class="hsection3">   Этот элемент позволяет встроить на сайт любой мультимедиа-объект вместе с программой обработки данного объекта. В этом разделе мы рассмотрим вопросы встраивания музыки, видео и Flash-анимации. Однако возможности элемента OBJECT намного шире: в принципе, вы можете встраивать в страницу любое активное содержимое, главное, чтобы у пользователя была программа для обработки этого объекта.<br></br>   Элемент OBJECT использует программы, находящиеся на компьютере посетителя, и с их помощью воспроизводит активное содержимое. Он может использовать программу проигрывания по умолчанию для конкретного типа файлов, если этот тип файлов знаком браузеру, или использовать конкретную указанную вами программу, если она есть на компьютере пользователя.<br></br>   У этого элемента много атрибутов. Очевидно, что не все они являются обязательными, точнее, у этого элемента нет строго обязательных атрибутов. Однако среди них можно выделить наиболее важные, которые упростят и ускорят обработку вашего объекта браузером.<br></br>   Атрибут classid указывает адрес программы, которая будет работать с объектом. В качестве значения этого атрибута можно указывать полный или относительный путь к файлу программы. Это не всегда удобно, потому что на разных компьютерах программы располагаются в разных местах, а на серверах обычно не бывает программ, необходимых для воспроизведения мультимедиа-файлов. Удобнее второй метод: использование идентификатора зарегистрированного ActiveX-приложения. В этом случае перед самим идентификатором должно стоять ключевое слово clsid, как в листинге 4.11. Чаще всего применяют именно второй вариант, потому что он универсален. Идентификаторы для различных приложений и активных объектов легко найти в Интернете.<br></br>   Атрибут codetype должен принимать значение, содержащее MIME-тип объекта, который указан в атрибуте classid. Браузер использует эту информацию для подготовки ресурсов, необходимых для запуска файла.<br></br><blockquote><div>   <b>Совет</b><br></br>
   MIME-тип (Multipurpose Internet Mail Extensions) – стандарт, используемый в Интернете, для указания типа объекта. Тип, соответствующий вашему объекту, можно посмотреть в реестре. Для этого в папке HKEY_CLASSES_ROOT нужно открыть папку с разрешением, соответствующим вашему объекту, и в строке Content Type будет указан MIME-тип объекта.<br></br>
</div></blockquote>   В листинге 4.11 показано применение атрибутов classid и codetype.<br></br><h5 class="subtitle"><b>Листинг 4.11.</b> Использование атрибутов classid и codetype</h5>   &lt;html&gt;<br></br>   &lt;head&gt;<br></br>   &lt;title&gt;Встраивание объектов&lt;/title&gt;<br></br>   &lt;/head&gt;<br></br>   &lt;body&gt;<br></br>   &lt;object classid="CLSID:22D6F312-B0F6-11D0-94AB-0080C74C7E95" codetype= "audio/mp3"&gt;<br></br>   &lt;/object&gt;<br></br>   &lt;/body&gt;<br></br>   &lt;/html&gt;<br></br>   В примере указан идентификатор для Проигрывателя Windows Media, а тип – для проигрывания МР3-файла. При просмотре страницы вы увидите проигрыватель, готовый к запуску (рис. 4.12).<br></br><div class="wrap_pict"><div style="text-align: center;"><img src="i_059.png" alt=""></img></div>   <b>Рис. 4.12.</b> Вставка Проигрывателя Windows Media<br></br></div><br></br>   Атрибут data в качестве значения принимает адрес файла, который необходимо запустить с помощью проигрывателя. Правда, такой метод определения файла используется не всегда – иногда имя файла для запуска нужно передавать через элемент PARAM. Путь к файлу необходимо указывать относительно папки, заданной атрибутом codebase. Если значение этого атрибута не указано, то путь следует задать относительно текущего документа.<br></br>   Атрибут type задает тип объекта, который указан в параметре data. Здесь нужно указывать MIME-тип объекта. Это позволит браузеру выбрать программу для воспроизведения файла. Если вы не укажете конкретную программу для воспроизведения, то браузер сам выберет приложение для воспроизведения файлов заданного типа. Значение атрибута type браузер использует, когда не указано значение атрибута codetype.<br></br>   В листинге 4.12 приведен код, который запустит файл test. mp3 на проигрывание.<br></br><h5 class="subtitle"><b>Листинг 4.12.</b> Использование атрибутов data и type</h5>   &lt;html&gt;<br></br>   &lt;head&gt;<br></br>   &lt;title&gt;Встраивание объектов&lt;/title&gt;<br></br>   &lt;/head&gt;<br></br>   &lt;body&gt;<br></br>   &lt;object data="test.mp3" type="audio/mp3"&gt;<br></br>   &lt;/object&gt;<br></br>   &lt;/body&gt;<br></br>   &lt;/html&gt;<br></br><br></br>   Если вам понадобилось встроить на страницу Java-апплет, используйте атрибут code и в качестве его значения укажите имя класса вашего Java-апплета. По сути этот атрибут используется вместо элемента APPLET.<br></br>   В листинге 4.13 представлен пример встраивания апплета.<br></br><h5 class="subtitle"><b>Листинг 4.13.</b> Встраивание Java-апплетов</h5>   &lt;html&gt;<br></br>   &lt;head&gt;<br></br>   &lt;meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" /&gt;<br></br>   &lt;title&gt;Встраивание объектов&lt;/title&gt;<br></br>   &lt;/head&gt;<br></br>   &lt;body&gt;<br></br>   &lt;object code="clock.class"&gt;&lt;/object&gt;<br></br>   &lt;/body&gt;<br></br>   &lt;/html&gt;<br></br><br></br>   С атрибутом codebase вы встречались уже несколько раз, он указывает путь к папке, в которой хранятся файлы, используемые этим объектом. Пути ко всем файлам определяются в элементе OBJECT относительно папки, указанной в качестве значения этого атрибута.<br></br>   Помимо атрибутов, отвечающих за основные функции объекта, нас интересуют атрибуты, позволяющие управлять видом объекта на странице. Именно такие атрибуты элемента OBJECT мы рассмотрим далее.<br></br>   Для выравнивания объекта на странице служит атрибут align, его значения аналогичны значениям этого атрибута для элемента IMG, но я их повторю на всякий случай.<br></br>   Горизонтальное выравнивание:<br></br>   • left – по левому краю;<br></br>   • right – по правому краю.<br></br>   Вертикальное выравнивание:<br></br>   • top – выравнивание верхней границы объекта по самому высокому элементу строки;<br></br>   • texttop – выравнивание верхней границы объекта по самому высокому элементу текста;<br></br>   • middle – середина объекта выравнивается по базовой линии строки;<br></br>   • absmiddle – середина объекта выравнивается по середине строки;<br></br>   • baseline – выравнивание нижней границы объекта по базовой линии строки;<br></br>   • bottom – аналогично baseline;<br></br>   • absbottom – нижняя граница объекта выравнивается по нижней границе текущей строки.<br></br>   За размеры объекта отвечают атрибуты height и width, они устанавливают его высоту и ширину соответственно. Эти параметры задают размеры окна приложения, которое будет использовано для воспроизведения файла. Иначе говоря, если вы воспроизводите видеофайл, то заданные высота и ширина будут указывать не только размер экрана, в них будет включен еще и размер панели проигрывателя.<br></br>   Как и для картинок, для объектов можно задавать расстояние до текста с помощью атрибутов hspace и vspace.<br></br>   Благодаря атрибутам элемента OBJECT вы можете менять общие параметры вашего объекта, но есть еще один очень важный элемент, позволяющий задавать параметры самого приложения, в котором происходит воспроизведение.<br></br></div><h3 id="idm139732202830288">Элемент PARAM
</h3><div style="text-align: justify" class="hsection3">   Это главный элемент, предназначенный для управления проигрывателем. С его помощью можно управлять панелями проигрывателя, регулировать начальную громкость воспроизведения и другие параметры приложения; в общем, этот элемент позволяет гибко управлять программой, которая воспроизводит мультимедийное содержимое. Команды для каждой из программ обработчиков свои, и их легко можно найти в Интернете.<br></br>   Элементов PARAM внутри элемента OBJECT может быть много, так как для каждого управляющего параметра нужен свой элемент.<br></br>   Используют два основных атрибута элемента PARAM: name и value. Первый задает имя параметра приложения (переменной), а value – значение этого параметра.<br></br>   Элемент PARAM дает неограниченные возможности для управления воспроизведением мультимедиа на вашей странице.<br></br>   В примере из листинга 4.14 указан параметр AutoStart, в котором можно задать автоматическое начало воспроизведения файла, и параметр URL, в котором задается адрес файла.<br></br><h5 class="subtitle"><b>Листинг 4.14.</b> Использование элемента PARAM</h5>   &lt;html&gt;<br></br>   &lt;head&gt;<br></br>   &lt;title&gt;Встраивание объектов&lt;/title&gt;<br></br>   &lt;/head&gt;<br></br>   &lt;body&gt;<br></br>   &lt;object classid="CLSID:22D6F312-B0F6-11D0-94AB-0080C74C7E95" width="300" height="300" Type="audio/x-mpeg"&gt;<br></br>   &lt;param name="FileName " value="test.mp3"/&gt;<br></br>   &lt;param name="AutoStart" value="false"/&gt;<br></br>   &lt;/object&gt;<br></br>   &lt;/body&gt;<br></br>   &lt;/html&gt;<br></br>   Теперь подробно рассмотрим встраивание основных типов файлов.<br></br></div><h3 id="idm139732202805456">Встраивание аудио
</h3><div style="text-align: justify" class="hsection3">   Для начала возьмем самую распространенную задачу – проигрывание фонового звука. Чтобы разобраться с ней, нужно немного отвлечься от элемента OBJECT, потому что есть способ встроить фоновый звук и без него. Создатели языка HTML предусмотрели для этого специальный элемент BGSOUND. Он должен располагаться в заголовке документа, его основные атрибуты – src (путь к звуковому файлу) и loop (количество повторных воспроизведений файла). Для управления звуком можно задавать параметр volume, который определяет громкость воспроизведения музыки. Пример установки фонового звука с помощью элемента BGSOUND приведен в листинге 4.15.<br></br><h5 class="subtitle"><b>Листинг 4.15.</b> Задание фонового звука с помощью элемента BGSOUND</h5>   &lt;html&gt;<br></br>   &lt;head&gt;<br></br>   &lt;title&gt;Встраивание объектов&lt;/title&gt;<br></br>   &lt;/head&gt;<br></br>   &lt;body&gt;<br></br>   &lt;bgsound src="test.mp3" loop="1" volume="5" /&gt;<br></br>   &lt;/body&gt;<br></br>   &lt;/html&gt;<br></br>   В случае примера из листинга 4.15 музыка из файла test.mp3 будет проиграна один раз с пятой громкостью.<br></br>   Есть и другой способ задать фоновую музыку, например ввести на сайт проигрыватель и задать ему нулевые размеры. Этот способ имеет смысл использовать, когда нужно реализовать нестандартное управление воспроизведением музыки на сайте. В таком случае это можно будет сделать через управляющие команды проигрывателя.<br></br>   В листинге 4.16 приведен пример того, как задать фоновую музыку с использованием элемента OBJECT.<br></br><h5 class="subtitle"><b>Листинг 4.16.</b> Задание фоновой музыки с помощью элемента OBJECT</h5>   &lt;html&gt;<br></br>   &lt;head&gt;<br></br>   &lt;title&gt;Встраивание объектов&lt;/title&gt;<br></br>   &lt;/head&gt;<br></br>   &lt;body&gt;<br></br>   &lt;object classid="CLSID:22D6F312-B0F6-11D0-94AB-0080C74C7E95" width="0" height="0" type="audio/x-mpeg" &gt;<br></br>   &lt;param name="FileName" value=" test.mp3" /&gt;<br></br>   &lt;param name="AutoStart" value="true" /&gt;<br></br>   &lt;param name="Volume" value="10" /&gt;<br></br>   &lt;param name="PlayCount" value="2" /&gt;<br></br>   &lt;/object&gt;<br></br>   &lt;/body&gt;<br></br>   &lt;/html&gt;<br></br>   В листинге 4.16 используются параметры AutoStart и Volume, которые задают автоматическое начало воспроизведения и громкость звука соответственно, а сам файл для воспроизведения указывается с помощью параметра URL. Количество повторов определяет параметр PlayCount. При обработке кода из листинга 4.16 файл test.mp3 будет проигрываться сразу при открытии страницы с десятой громкостью два раза.<br></br><blockquote><div>   <b>Примечание</b><br></br>
   В последних версиях браузеров, перед тем как запустить активное содержимое, запрашивается разрешение пользователя на запуск. Если использовать вариант с элементом BGSOUNG, то подобного запроса не будет, а сразу же начнется воспроизведение звука. При использовании второго варианта для запуска активного содержимого необходимо будет получить согласие пользователя.<br></br>
</div></blockquote>   С фоновым звуком все просто, но его явно недостаточно для создания полноценной мультимедийной галереи, чаще приходится встраивать на страницу музыку вместе с проигрывателем. В таком случае без элемента OBJECT не обойтись, и альтернатив здесь нет.<br></br>   Начнем с того, что приведем проигрыватель к удобному для посетителя виду. При воспроизведении музыки пропадает необходимость в полном окне проигрывателя и поэтому графический дисплей можно «срезать». Это делается очень просто: нужно изменить высоту объекта, то есть просто опустить атрибут height элемента OBJECT, оставляя проигрыватель без высоты.<br></br>   Код для такого отображения проигрывателя представлен в листинге 4.17.<br></br><h5 class="subtitle"><b>Листинг 4.17.</b> Неполное окно проигрывателя</h5>   &lt;html&gt;<br></br>   &lt;head&gt;<br></br>   &lt;title&gt;Встраивание объектов&lt;/title&gt;<br></br>   &lt;/head&gt;<br></br>   &lt;body&gt;<br></br>   &lt;object classid="CLSID:22D6F312-B0F6-11D0-94AB-0080C74C7E95" type="audio/x-mpeg"&gt;<br></br>   &lt;param name="FileName" value="test.mp3" /&gt;<br></br>   &lt;param name="AutoStart" value="1" /&gt;<br></br>   &lt;/object&gt;<br></br>   &lt;/body&gt;<br></br>   &lt;/html&gt;<br></br>   Результат обработки браузером листинга представлен на рис. 4.13.<br></br><div class="wrap_pict"><div style="text-align: center;"><img src="i_060.png" alt=""></img></div>   <b>Рис. 4.13.</b> Аудиопроигрыватель<br></br></div><br></br>   В примере не заданы ни высота, ни ширина. В случае с проигрыванием музыки в этом нет необходимости.<br></br>   Итак, у нас есть удобный для посетителя сайта проигрыватель. Единственное, что хотелось бы добавить в него, это возможность видеть название песни и имя исполнителя данной мелодии. Это очень просто сделать: нужно добавить строку параметров: &lt;PARAM name="ShowDisplay" value="1"/&gt;.<br></br>   Результат добавления такой строки параметров показан на рис. 4.14.<br></br><div class="wrap_pict"><div style="text-align: center;"><img src="i_061.png" alt=""></img></div>   <b>Рис. 4.14.</b> Аудиопроигрыватель с дополнительной информацией<br></br></div><br></br>   Теперь у нас есть удобный и симпатичный проигрыватель музыкальных файлов.<br></br><blockquote><div>   <b>Примечание</b><br></br>
   При использовании Проигрывателя Windows Media версии выше 6. 4 параметры могут отличаться. Например, вместо FileName используется параметр URL. Идентификатор clsid для Проигрывателя Windows Media версий выше 6. 4: 6BF52A52-394A-11D3-B153-00C04F79FAA6.<br></br>
</div></blockquote>   Итак, музыка встроена, но нам не терпится добавить туда еще немного возможностей, например проигрывание видео.<br></br></div><h3 id="idm139732202797392">Встраивание видео
</h3><div style="text-align: justify" class="hsection3">   Сейчас встраивать видео на сайт можно без опасений – нынешних скоростей доступа в Интернет достаточно, чтобы у пользователей не было проблем с просмотром и скачиванием видео. Тем более что сейчас перемещение видеоархивов в сеть становится весьма популярным. Однако надо помнить, что файлы для потокового видео должны быть небольшими, а если вы хотите поделиться большим фильмом, то лучше выложить его для скачивания по ссылке.<br></br><blockquote><div>   <b>Примечание</b><br></br>
   Потоковое видео – это видео, для просмотра которого пользователю нет необходимости дожидаться полной загрузки файла. Иными словами, пока одна часть файла скачивается, другая воспроизводится.<br></br>
</div></blockquote>   Итак, вы определили размер вашего файла и решили, что он подходит для потокового воспроизведения. Теперь нужно выбрать программу для воспроизведения.<br></br>   В этой части мы будем рассматривать воспроизведение в Проигрывателе Windows Media, однако позже рассмотрим и другие проигрыватели.<br></br>   Выбор проигрывателя зависит от типа файла, и хотя большинство проигрывателей может воспроизвести любой файл, иногда встречаются исключения. Возьмем для рассмотрения формат AVI как наиболее универсальный. MIME-тип такого файла – video/x-msvideo.<br></br>   Управление проигрывателем осуществляется с помощью элемента PARAM. Как видно в листинге 4.18, с помощью параметров задаются имя файла для проигрывания, параметры панели проигрывателя. В примере реализован проигрыватель, который после загрузки сразу начинает проигрывание со звуком 20. Вообще не стоит разрешать видеопроигрывателю автоматический старт. Поскольку видео требует много трафика и загружает канал, то лучше решение о старте оставить на усмотрение пользователя.<br></br><h5 class="subtitle"><b>Листинг 4.18.</b> Встраивание видео</h5>   &lt;html&gt;<br></br>   &lt;head&gt;<br></br>   &lt;title&gt;Встраивание объекта&lt;/title&gt;<br></br>   &lt;/head&gt;<br></br>   &lt;body&gt;<br></br>   &lt;object classid="CLSID:22D6F312-B0F6-11D0-94AB-0080C74C7E95" width="300" height="300" type="video/avi"&gt;<br></br>   &lt;param name="Volume" value="20" /&gt;<br></br>   &lt;param name="URL" value="test.avi" /&gt;<br></br>   &lt;param name="AutoStart" value="1" /&gt;<br></br>   &lt;/object&gt;<br></br>   &lt;/body&gt;<br></br>   &lt;/html&gt;<br></br>   Добавить панель с информацией о видео можно так же, как и с аудио, присоединив строку параметров &lt;PARAM name="ShowDisplay" value="1" /&gt;.<br></br>   Таких полезных параметров много, вы их увидите, когда будете знакомиться с возможностями различных проигрывателей.<br></br>   Главное – помните, что на первом месте должно стоять удобство посетителя вашего сайта, и выбирать элементы проигрывателя нужно с этой точки зрения.<br></br>   Помимо видео и аудио, есть еще один распространенный вид мультимедийного содержимого: Flash. Он используется на многих сайтах и, возможно, понадобится вам.<br></br></div><h3 id="idm139732209394128">Встраивание Flash-графики
</h3><div style="text-align: justify" class="hsection3">   Необходимость Flash-графики не всегда очевидна, однако красиво нарисованная заставка может оживить вашу страницу. Не стоит ни пренебрегать Flash-графикой, ни переоценивать ее действие. Переизбыток подобного содержимого может замедлить загрузку страницы. Если же вы создаете сайт только на Flash, то советую предусмотреть возможность просмотра содержимого без графики. Некоторые посетители будут вам благодарны.<br></br>   Рассмотрим особенности встраивания Flash-графики. Для воспроизведения Flash-файла на компьютере пользователя должна быть установлена специальная программа. Чаще всего это Shockwave, ее можно бесплатно скачать с сайта производителя. Идентификатор этой программы clsid:d27cdb6e-ae6d-11cf-96b8-44455354 0000, а MIME-тип для SWF-файла будет application/ x-shockwave-flash.<br></br>   Для управления проигрыванием файла, как обычно, используем элементы PARAM.<br></br>   В листинге 4.19 показано встраивание Flash-объекта. Параметр movie задает имя файла, который надо воспроизвести. Параметр loop отвечает за количество воспроизведений, а play – за автоматическое начало воспроизведения.<br></br><h5 class="subtitle"><b>Листинг 4.19.</b> Встраивание Flash-графики</h5>   &lt;html&gt;<br></br>   &lt;head&gt;<br></br>   &lt;title&gt;Встраивание объекта&lt;/title&gt;<br></br>   &lt;/head&gt;<br></br>   &lt;body&gt;<br></br>   &lt;object classid="CLSID:d27cdb6e-ae6d-11cf-96b8-444553540000" width="300" height="300" type="application/x-shockwave-flash" &gt;<br></br>   &lt;param name="movie" value="test.swf" /&gt;<br></br>   &lt;param name="play" value="false" /&gt;<br></br>   &lt;param name="loop" value="1"&gt;<br></br>   &lt;/object&gt;<br></br>   &lt;/body&gt;<br></br>   &lt;/html&gt;<br></br>   При обработке этого кода браузер воспроизведет файл test.swf только после соответствующего указания пользователя и проиграет его один раз.<br></br>   Теперь, когда вы знаете, как встроить Flash или любой другой активный объект на сайт, рассмотрим подробнее проигрыватели и их параметры.<br></br></div><h3 id="idm139732209402320">Проигрыватели
</h3><div style="text-align: justify" class="hsection3">   Самыми распространенными являются Проигрыватель Windows Media, RealPlayer, QuickTime Player. Каждый из них имеет свой формат файлов, но воспроизводить может практически любые файлы мультимедиа.<br></br>   Рассмотрим подробнее эти проигрыватели и их самые полезные параметры.<br></br>   • Проигрыватель Windows Media – стандартный проигрыватель для Windows, его плюс в универсальности: там, где есть Windows, есть этот проигрыватель.<br></br>   Идентификатор: 22D6F312-B0F6-11D0-94AB-0080C74C7E95.<br></br>   Параметры приведены в табл. 4.1. Если в таблице в графе Значение указано 0/1, то 0 – выключить функцию, 1 – включить.<br></br><h5 class="subtitle"><b>Таблица 4.1.</b> Параметры WMP</h5><div style="text-align: center;"><img src="i_062.png" alt=""></img></div>   • RealPlayer – этот проигрыватель, помимо простого проигрывания файлов, приспособлен для воспроизведения радио или телевидения в режиме online.<br></br>   Идентификатор: CFCDAA03-8BE4-11cf-B8 4B-0 02 0AFBBCCFA.<br></br>   Параметры приведены в табл. 4.2.<br></br><h5 class="subtitle"><b>Таблица 4.2.</b> Параметры RealPlayer</h5><div style="text-align: center;"><img src="i_063.png" alt=""></img></div><br></br><h5 class="subtitle"><b>Таблица 4.3.</b> Значения параметра controls</h5><div style="text-align: center;"><img src="i_064.png" alt=""></img></div><br></br><div style="text-align: center;"><img src="i_065.png" alt=""></img></div>   • QuickTime Player – воспроизводит большинство современных мультимедийных форматов, включая собственные форматы MOV и QT. Если позволяет скорость подключения, с помощью этого проигрывателя можно просматривать потоковое видео из Интернета.<br></br>   Идентификатор: 02BF2 5D5-8C17-4B2 3-BC80-D3488ABDDC6B. Параметры приведены в табл. 4.4.<br></br><h5 class="subtitle"><b>Таблица 4.4.</b> Параметры QuickTime Player</h5><div style="text-align: center;"><img src="i_066.png" alt=""></img></div>   Мы рассмотрели основные виды проигрывателей и их самые востребованные параметры, теперь видео– и аудиосодержимое сайта полностью в вашей власти.<br></br>   Однако возможности элемента OBJECT не ограничиваются добавлением только музыки и фильмов, есть много других способов для использования этого элемента.<br></br></div><h3 id="idm139732209378512">Дополнительные возможности элемента OBJECT
</h3><div style="text-align: justify" class="hsection3">   Посмотрим, что еще можно добавить на сайт с помощью элемента OBJECT.<br></br>   В качестве объекта на сайт можно добавить картинку:<br></br>   &lt;object height="100" width="100"<br></br>   type="image/jpeg" data="test.jpeg"&gt;<br></br>   &lt;/object&gt;<br></br>   Можно добавить другой сайт:<br></br>   &lt;object type="text/html" height="100" width="100"<br></br>   data="http://www.test.test"&gt;<br></br>   &lt;/object&gt;<br></br>   По сути подобные возможности элемента позволяют добавлять абсолютно любые объекты и управлять ими как угодно.<br></br>   Приведу интересный пример: добавление календаря, соответствующий код приведен в листинге 4.20.<br></br><h5 class="subtitle"><b>Листинг 4.20.</b> Добавление календаря</h5>   &lt;html&gt;<br></br>   &lt;head&gt;<br></br>   &lt;title&gt;Встраивание объекта&lt;/title&gt;<br></br>   &lt;/head&gt;<br></br>   &lt;body&gt;<br></br>   &lt;object width="500" height="500" classid="clsid:8E27C92B-1264-101C-8A2F– 040224009C02"&gt;<br></br>   &lt;/object&gt;<br></br>   &lt;/body&gt;<br></br>   &lt;/html&gt;<br></br>   Получившийся календарь изображен на рис. 4.15.<br></br><div class="wrap_pict"><div style="text-align: center;"><img src="i_067.png" alt=""></img></div>   <b>Рис. 4.15.</b> Встроенный календарь<br></br></div><br></br>   Из этих примеров можно понять, что возможности элемента OBJECT очень большие и только от создателя сайта зависит, как они будут использованы.<br></br></div></div><h2 id="idm139732209389648">Резюме
</h2><div style="text-align: justify" class="hsection2">   В этой главе мы рассмотрели возможности улучшения вида сайта с помощью картинок, Flash, аудио и видео. Из примеров видно, что возможности языка HTML в этом плане весьма велики.<br></br>   Однако необходимо проявлять осторожность, чтобы большое количество графики не помешало функциональности сайта, потому что мультимедиа-приложения используют значительные ресурсы для загрузки на компьютер пользователя.<br></br>   В главе приведены примеры, показывающие универсальность элемента OBJECT и демонстрирующие его дополнительные возможности.<br></br>   Теперь вы легко можете добавить на сайт картинку, причем разными методами; вставить видео– или аудиофайл вместе с проигрывателем. Вы знаете, в каком направлении двигаться для получения большей функциональности своей страницы.<br></br></div></div><h1 xmlns="http://www.w3.org/1999/xhtml" id="idm139732209359056" class="master">Глава 5<br></br>
Фреймы
</h1><div xmlns="http://www.w3.org/1999/xhtml" style="text-align: justify" class="hsection1"><div style="text-align: justify" class="section2">   5.1. Создание фреймов<br></br>
   5.2. Границы фрейма<br></br>
   5.3. Полосы прокрутки<br></br>
   5.4. Ссылки внутри фреймов<br></br>
   5.5. Изменение размеров фреймов<br></br>
   5.6. Плавающие фреймы<br></br>
   5.7. Управление пространством внутри фрейма<br></br>
   5.8. Достоинства и недостатки фреймов<br></br>
   Фреймы (frames) – это HTML-элементы, позволяющие разделить страницу на несколько независимых окон. В каждое окно можно поместить собственную независимую HTML-страницу, в которой может находиться ссылка из одного окна в другое. Фреймы поддерживаются в браузерах версий 3.0 и более. Они применяются в основном для организации постоянно находящихся на экране меню, в то время как в другом окне располагается непосредственно сама информация.<br></br>
   Фреймы чаще всего используют для создания следующих элементов.<br></br>
   • Оглавление – обычно создают в виде вертикального столбца. Пользователи могут обращаться к нему в любой момент, и им не нужно возвращаться к предыдущей странице, чтобы выбрать другой пункт оглавления.<br></br>
   • Неподвижные элементы интерфейса – использование фреймов позволит вам «закрепить» на экране графику, логотипы и другие неподвижные по замыслу элементы, в то время как остальная часть страницы будет прокручиваться во фрейме.<br></br>
   • Формы и результаты – можно в одном фрейме создать форму, а в другом отобразить результаты запроса.<br></br>
</div><h2 id="idm139732209365456">5.1. Создание фреймов
</h2><div style="text-align: justify" class="hsection2">   Чтобы HTML-страница содержала фреймы, а экран был разделен на области, необходимо заменить пару тегов &lt;BODY&gt;..&lt;/BODY&gt; в коде HTML-страницы парой тегов &lt;FRAMESET&gt;…&lt;/FRAMESET&gt;. Необходимо также указать хотя бы один из атрибутов cols или rows. С помощью этих атрибутов задают размеры фреймов и количество строк и столбцов в разбиении страницы. Атрибут cols определяет количество строк, а атрибут rows – количество столбцов. Области, полученные в результате разбиения, и будут являться фреймами. Отсутствие этих атрибутов определяет один фрейм величиной во все окно браузера. В значении атрибутов необходимо указывать не количество строк или столбцов, а значение ширины каждого фрейма через запятую, если рассматривать атрибут cols (например, cols = «13,31,34»). Атрибут rows определяет высоту каждого фрейма соответственно. Размеры фреймов могут задаваться как в абсолютных, так и в относительных величинах.<br></br>   • Простое числовое значение определяет фиксированную высоту или ширину фрейма в пикселах (например, cols = "20, 100, 20" rows = "30, 100"). Это далеко не самый лучший способ описания размеров фрейма, поскольку различные браузеры имеют различный размер рабочего поля, не говоря уже о различных экранных разрешениях у пользователя. Если вы все же используете данный способ описания размера, то настоятельно рекомендуется сочетать его с каким-либо другим, чтобы в результате вы точно получили стопроцентное заполнение окна браузера пользователя.<br></br>   • Значение величины фрейма, заданное в процентах от 1 до 100 (например, cols = "20 %, 50 %, 3 0 %" rows = "30 %, 70 %"). Если общая сумма процентов, описывающих фрейм, превышает 100, то размеры всех фреймов пропорционально уменьшаются до суммы 100 %. Если, соответственно, сумма меньше 100, то размеры пропорционально увеличиваются.<br></br>   • В значении указывается число со звездочкой (например, 5*). Однако числовое значение в данном описании является необязательным. Символ * указывает на то, что все оставшееся место будет принадлежать данному фрейму. Если указывается два или более фрейма с описанием * (например, cols = "*, *, *"), то оставшееся пространство делится поровну между этими фреймами. Если перед звездочкой стоит цифра, то она указывает пропорцию для данного фрейма (во сколько раз он будет больше аналогично описанного просто звездочкой). Например, описание rows = "2*,*,*" говорит, что будет создано три фрейма с размерами 2/3 свободного пространства для первого фрейма и по 1/3 для двух других.<br></br>   Чтобы в каждой из областей отображалась информация, необходимо использовать элемент FRAME, обязательный атрибут src которого укажет адрес документа, отображаемого внутри фрейма. Если адрес отсутствует, то будет отображен пустой фрейм. Рассмотрим создание фреймов на примере, описанном в листинге 5.1.<br></br><h5 class="subtitle"><b>Листинг 5.1.</b> Пример создания фреймов</h5>   &lt;html&gt;<br></br>   &lt;head&gt;<br></br>   &lt;title&gt;Эта страница содержит 4 фрейма&lt;/title&gt;<br></br>   &lt;/head&gt;<br></br>   &lt;frameset cols="45%,*"rows="30%,*"&gt;<br></br>   &lt;frame src=frame1.HTML&gt;<br></br>   &lt;frame src=frame2.HTML&gt;<br></br>   &lt;frame src=frame3.HTML&gt;<br></br>   &lt;frame src=frame4.HTML&gt;<br></br>   &lt;/frameset&gt;<br></br>   &lt;/html&gt;<br></br>   На рис. 5.1 изображено, как будет отображаться HTML-документ, описанный в листинге 5.1. Страница содержит четыре области соответствующих пропорций, в каждую из которых первоначально загружаются HTML-документы Frame 1. html, Frame2.html, Frame3.html и Frame4.html.<br></br><div class="wrap_pict"><div style="text-align: center;"><img src="i_068.png" alt=""></img></div>   <b>Рис. 5.1.</b> Пример страницы, содержащей четыре фрейма<br></br></div><br></br>   Помимо HTML-документов, фрейм может содержать и изображение. Для этого необходимо указать адрес соответствующей картинки в атрибуте src, например src="pic. gif". Обратите внимание, что элемент FRAME используется без закрывающего тега.<br></br></div><h2 id="idm139732209325520">5.2. Границы фрейма
</h2><div style="text-align: justify" class="hsection2">   Обращаю ваше внимание на то, что в описанном выше примере каждый фрейм имеет границу (см. рис. 5.1). Границей фрейма можно управлять, как и любыми другими элементами фрейма. Для этого существует несколько атрибутов элемента FRAMESET, позволяющих настраивать границы фреймов. Ширина границы определяется атрибутом border. По умолчанию значение ширины границы равно пяти. Чтобы граница фрейма отсутствовала, необходимо либо указать значение ширины границы равным нулю, либо присвоить значение no или 0 атрибуту frameborder. Данный атрибут может принимать только два противоположных значения. Если значение атрибута frameborder равно yes или 1, то граница фреймов будет отображаться, если 0 или no, то нет. Возможны конфликтные ситуации, так как значения атрибута frameborder различаются для разных браузеров. Однако эту проблему можно решить. Просто используйте дважды атрибут frameborder (&lt;FRAMESET frameborder="no" frameborder="0"&gt;), чтобы браузер выбрал себе значение по вкусу.<br></br>   С помощью атрибута bordercolor определяется цвет границы фрейма, необходимо только указать код или соответствующее зарезервированное имя цвета.<br></br>   В листинге 5.2 приведен пример HTML-страницы, которая содержит описанные выше атрибуты управления границей фрейма.<br></br><h5 class="subtitle"><b>Листинг 5.2.</b> Пример управления границей фреймов</h5>   &lt;html&gt;<br></br>   &lt;head&gt;<br></br>   &lt;title&gt;Эта страница содержит 4 фрейма&lt;/title&gt;<br></br>   &lt;/head&gt;<br></br>   &lt;frameset cols="45%,*"rows="30%,*" border="10" bordercolor="#000000" frameborder="1" frameborder="yes"&gt;<br></br>   &lt;frame src=frame1.HTML&gt;<br></br>   &lt;frame src=frame2.HTML&gt;<br></br>   &lt;frame src=frame3.HTML&gt;<br></br>   &lt;frame src=frame4.HTML&gt;<br></br>   &lt;/frameset&gt;<br></br>   &lt;/html&gt;<br></br>   На рис. 5.2 показано, как будет отображаться страница, описанная в листинге 5.2, в окне браузера Internet Explorer. Страница разделена на четыре области линиями черного цвета, за что отвечает атрибут bordercolor="#000000".<br></br><div class="wrap_pict"><div style="text-align: center;"><img src="i_069.png" alt=""></img></div>   <b>Рис. 5.2.</b> Пример управления границами фреймов<br></br></div><br></br>   Стоит отметить, что изменять границу одного из фреймов нельзя. Если же указать атрибуты, управляющие границей фреймов, в элементе FRAME (например, &lt;FRAME src=frame1.HTML border="10" bordercolor="#000000" frameborder="1" frameborder="yes"&gt;), то браузер не проигнорирует это сообщение, а границы каждого фрейма непредсказуемо изменятся (рис. 5.3).<br></br><div style="text-align: center;"><img src="i_070.png" alt=""></img></div>   <b>Рис. 5.3.</b> Попытка изменить границы отдельного фрейма<br></br></div><h2 id="idm139732209334864">5.3. Полосы прокрутки
</h2><div style="text-align: justify" class="hsection2">   В некоторых случаях полосы прокрутки нарушают дизайн HTML-страницы. Если содержимое фрейма не помещается в отведенную область, то автоматически появляются полосы прокрутки для просмотра информации. Для управления отображением полос прокрутки используется атрибут scrolling, принимающий три основных значения:<br></br>   • yes – всегда вызывает появление полос прокрутки, независимо от объема информации;<br></br>   • no – запрещает появление полос прокрутки;<br></br>   • auto – полосы прокрутки отображаются при необходимости (по умолчанию).<br></br>   &lt;frameset cols="45%,*"rows="30%,*"&gt;<br></br>   &lt;frame src=frame1.HTML <b>scrolling=</b>" <b>yes</b>" &gt;<br></br>   &lt;frame src=fon.jpg&gt;<br></br>   &lt;frame src=fon.jpg <b>scrolling=</b>" <b>no</b>"&gt;<br></br>   &lt;frame src=frame4.HTML&gt;<br></br>   &lt;/frameset&gt;<br></br>   Рассмотрим пример страницы, в которой использована конструкция, описанная выше (рис. 5.4).<br></br><div class="wrap_pict"><div style="text-align: center;"><img src="i_071.png" alt=""></img></div>   <b>Рис. 5.4.</b> Пример управления полосами прокрутки<br></br></div><br></br>   В данном примере второй и третий фреймы содержат изображение. Рассмотрим каждый фрейм по отдельности. Полосы прокрутки первого фрейма всегда, независимо от содержимого, будут отображаться, в данном случае они неактивны, так как содержимое фрейма меньше отведенного для него места. У второго фрейма полосы прокрутки появились автоматически, так как изображение не поместилось в отведенную область. Используя полосы прокрутки, вы все же можете просмотреть изображение. Изображение, которое содержит третий фрейм, просмотреть сложно, так как у него отключены полосы прокрутки. Таким образом, атрибут scrolling="no" следует использовать осторожно. Информация, содержащаяся в четвертом фрейме, поместилась в отведенное для фрейма место, поэтому полосы прокрутки не отображаются.<br></br></div><h2 id="idm139732202518864">5.4. Ссылки внутри фреймов
</h2><div style="text-align: justify" class="hsection2">   В большинстве случаев при переходе по ссылке в окне браузера текущий документ заменяется новым. При использовании фреймов схема загрузки документов отличается от стандартной. Главное отличие – возможность загружать документ в выбранный фрейм из другого. Для этого применяется атрибут target элемента А. В качестве значения используется имя фрейма, в который будет загружаться документ, указанный атрибутом name.<br></br>   В листинге 5.3 приведен пример HTML-документа, где некоторым фреймам присвоены имена.<br></br><h5 class="subtitle"><b>Листинг 5.3.</b> Код главной страницы</h5>   &lt;html&gt;<br></br>   &lt;head&gt;<br></br>   &lt;title&gt;Эта страница содержит 4 фрейма&lt;/title&gt;<br></br>   &lt;/head&gt;<br></br>   &lt;frameset cols="45%,*"rows="30%,*"&gt;<br></br>   &lt;frame src=frame1.HTML <b>scrolling=</b>" <b>yes</b>"&gt;<br></br>   &lt;frame src=frame2.HTML name="frame2"&gt;<br></br>   &lt;frame src=frame3.HTML <b>scrolling=</b>" <b>no</b>"&gt;<br></br>   &lt;frame src=frame4.HTML name="frame4"&gt;<br></br>   &lt;/frameset&gt;<br></br>   &lt;/html&gt;<br></br>   На рис. 5.5 изображен HTML-документ (листинг 5.3), в четвертый фрейм которого загружается страница, содержащая ссылку на другой документ: &lt;a href=page.HTML target="frame2"&gt;Другая страница&lt;/а&gt;.<br></br><div class="wrap_pict"><div style="text-align: center;"><img src="i_072.png" alt=""></img></div>   <b>Рис. 5.5.</b> Четвертый фрейм содержит ссылку на другой документ<br></br></div><br></br>   Если пользователь щелкнет кнопкой мыши на данной ссылке, то новый документ загрузится во втором фрейме, на что указывает атрибут target = «frame2» (рис. 5.6).<br></br><div class="wrap_pict"><div style="text-align: center;"><img src="i_073.png" alt=""></img></div>   <b>Рис. 5.6.</b> Во второй фрейм загрузился новый документ<br></br></div><br></br>   Стоит также отметить, что имя фрейма должно начинаться с цифры или латинской буквы. Следующие имена используются в качестве зарезервированных:<br></br>   • target="_blank" – документ загрузится в новом окне;<br></br>   • target="_self" – документ загрузится в текущий фрейм;<br></br>   • target="_parent" – если документ с гиперссылкой находится во вложенном наборе фреймов, то документ загружается в родительское окно или набор фреймов;<br></br>   • target="_top" – отменяет все фреймы и загружает документ в полное окно браузера.<br></br>   Используя фреймы, не стоит забывать и об особенностях гиперссылок. Если атрибут target не указан, то целевой документ загружается по умолчанию в тот же фрейм. Если указано несуществующее имя фрейма, то открывается новое окно браузера, получая при этом заданное имя. Для внешних ссылок следует задавать значения атрибута target либо _top, либо _blank, чтобы чужие сайты не отображались в ваших фреймах, а занимали полное окно.<br></br><blockquote><div>   <b>Совет</b><br></br>
   Не стоит злоупотреблять именем «_blank», потому что часто пользователи не замечают, что открылось новое окно. Незакрытые окна копятся, и пользователь может запутаться в них.<br></br>
</div></blockquote></div><h2 id="idm139732202532816">5.5. Изменение размеров фреймов
</h2><div style="text-align: justify" class="hsection2">   По умолчанию размеры фреймов можно изменять с помощью указателя мыши. Необходимо просто навести указатель на границу между фреймами и, зажав левую кнопку мыши, переместить границу влево или вправо, вверх или вниз (рис. 5.7).<br></br><div class="wrap_pict"><div style="text-align: center;"><img src="i_074.png" alt=""></img></div>   <b>Рис. 5.7.</b> Изменение размеров фрейма указателем мыши<br></br></div><br></br>   Для того чтобы заблокировать возможность изменения пользователем размеров фреймов, следует воспользоваться атрибутом noresize элемента FRAME.<br></br>   &lt;frameset cols=20%,*&gt;<br></br>   &lt;frame src=frame1.HTML noresize&gt;<br></br>   &lt;frame src=frame2.HTML&gt;<br></br>   &lt;/frameset&gt;<br></br><br></br>   Атрибут noresize не требует никаких значений. Для страницы с двумя фреймами этот параметр можно указать лишь в одном месте. Естественно, если у одного фрейма нельзя изменять размеры, то у близлежащего к нему размеры также не будут меняться.<br></br></div><h2 id="idm139732202504528">5.6. Плавающие фреймы
</h2><div style="text-align: justify" class="hsection2">   Браузеры последних версий позволяют использовать плавающие фреймы, добавляемые с помощью элемента IFRAME. Плавающий фрейм находится внутри обычного<br></br>   документа, не содержащего тегов &lt;FRAMESET&gt;. &lt;/FRAMESET&gt;, и позволяет добавлять на страницу любые другие независимые документы. В элементе I FRAME можно указывать те же атрибуты, что и в элементах, описывающих обычные фреймы. Кроме того, можно использовать следующие атрибуты: width, height, hspace, vspace, align, значения которых совпадают со значениями соответствующих атрибутов элемента IMG.<br></br>   &lt;iframe src=page.HTML width="50%" height="300" hspace="5" vspace="5" align="left"&gt;<br></br>   Ваш браузер не поддерживает плавающие фреймы!<br></br>   &lt;/iframe&gt;<br></br>   На рис. 5.8 изображено окно браузера, содержащее плавающий фрейм.<br></br><div class="wrap_pict"><div style="text-align: center;"><img src="i_075.png" alt=""></img></div>   <b>Рис. 5.8.</b> Пример плавающего фрейма<br></br></div><br></br>   Если браузер не поддерживает плавающие фреймы, то элемент IFRAME будет проигнорирован. Для таких браузеров можно указать альтернативный текст, расположенный между парой тегов &lt;IFRAME&gt; и &lt;/IFRAME&gt;.<br></br></div><h2 id="idm139732202509008">5.7. Управление пространством внутри фрейма
</h2><div style="text-align: justify" class="hsection2">   По умолчанию браузер отображает фреймы с полосой чистого пространства (полями) между содержимым и границей фрейма, равной 10 пикселов. Управлять этим пространством фрейма можно с помощью атрибутов marginheight и marginwidth. Атрибут marginwidth определяет высоту свободного пространства слева и справа от содержимого фрейма, а marginheight – сверху и снизу соответственно. Задавая величины полей, надо использовать оба атрибута, так как браузер может автоматически сократить размеры тех полей, которые вы не указали, до наименьшего значения. Значения этих атрибутов всегда должны указываться в абсолютных значениях (пикселах), а минимальное значение равняется одному пикселу.<br></br>   &lt;frame marginheight=45 marginwidth=1&gt;<br></br>   Рассмотрим пример HTML-документа, который содержит всего два фрейма (листинг 5.4). Изменим поля первого фрейма, а поля второго оставим по умолчанию. Чтобы разница была заметна невооруженным взглядом, в каждый фрейм загрузим изображения.<br></br><h5 class="subtitle"><b>Листинг 5.4.</b> Изменение полей фрейма</h5>   &lt;html&gt;<br></br>   &lt;head&gt;<br></br>   &lt;title&gt;Эта страница содержит 2 фрейма&lt;/title&gt;<br></br>   &lt;head&gt;<br></br>   &lt;frameset cols="45%,*"&gt;<br></br>   &lt;frame src="1.gif" marginheight=45 marginwidth=1&gt;<br></br>   &lt;frame src="2.gif"&gt;<br></br>   &lt;/frameset&gt;<br></br>   &lt;/html&gt;<br></br>   HTML-страница, описанная выше, изображена на рис. 5.9. В соответствии с кодом страницы поля первого фрейма значительно отличаются от полей второго, которые мы оставили по умолчанию.<br></br><div class="wrap_pict"><div style="text-align: center;"><img src="i_076.png" alt=""></img></div>   <b>Рис. 5.9.</b> Пример управления полями фрейма<br></br></div><br></br>   Стоит также отметить, что значения полей необходимо указывать для каждого фрейма в отдельности. Если использовать запись frameset marginheight=45 marginwidth =1&gt;, то браузер просто проигнорирует значения атрибутов, а не определит их для всех фреймов.<br></br></div><h2 id="idm139732202516816">5.8. Достоинства и недостатки фреймов
</h2><div style="text-align: justify" class="hsection2">   Поскольку вокруг фреймов существует много разговоров об их необходимости, рассмотрим их достоинства и недостатки, чтобы можно было самостоятельно решить, стоит ли использовать их на своем сайте.<br></br>   Достоинства фреймов следующие.<br></br>   • <b>Простота</b> – с помощью фреймов HTML-страница разграничивается на две области, которые содержат навигацию по сайту и его контент. Механизм фреймов позволяет открывать документ в одном фрейме по ссылке, нажатой в совершенно другом фрейме. Такое разделение HTML-страницы на составляющие интуитивно понятно и логически обусловлено.<br></br>   • <b>Быстрота</b> – для верстки без фреймов характерно размещение на одной странице и навигации, и содержания. Это увеличивает объем каждой страницы и в сумме может существенно повлиять на объем загружаемой с сайта информации. Поскольку фреймы используют разделение информации на части, страницы с ними будут загружаться быстрее.<br></br>   • <b>Размещение</b> – фреймы предоставляют уникальную возможность – размещение информации точно в нужном месте окна браузера. Так, можно поместить фрейм внизу браузера, и, независимо от прокручивания содержимого, эта область не изменит своего положения.<br></br>   • <b>Изменение размеров областей</b> – можно изменять размеры фреймов «на лету», чего не позволяет сделать традиционная верстка HTML.<br></br>   • <b>Загрузка</b> – загрузка HTML-страницы происходит только в указанное окно, остальные остаются неизменными. С помощью языка JavaScript можно осуществить одновременную загрузку двух и более страниц во фреймы.<br></br>   Недостатки фреймов такие.<br></br>   • <b>Навигация</b> – пользователь зачастую оказывается на сайте, совершенно не представляя, куда он попал, потому что всего лишь щелкнул кнопкой мыши на ссылке, полученной в поисковой системе. Чтобы посетителю сайта было проще разобраться, где он находится, на каждую страницу помещают название сайта, заголовок страницы и навигацию. Фреймы, как правило, нарушают данный принцип, отделяя заголовок сайта от содержания, а навигацию от контента. Представьте, что вы нашли подходящую ссылку в поисковой системе, щелкаете на ней кнопкой мыши, а в итоге открывается документ без названия и навигации. Чтобы понять, где вы находитесь, или посмотреть другие материалы, придется редактировать путь в адресной строке, что в любом случае доставляет неудобство.<br></br>   • <b>Плохая индексация поисковыми системами</b> – поисковые системы плохо работают с фреймовой структурой, поскольку на страницах, которые содержат контент, нет ссылок на другие документы. Если вы хотите получать посетителей с поисковых систем, забудьте о фреймах.<br></br>   • <b>Внутренние страницы нельзя добавить в Избранное</b> – фреймы скрывают адрес страницы, на которой находится посетитель, и всегда показывают только адрес сайта. По этой причине понравившуюся страницу невозможно поместить в раздел Избранное браузера.<br></br>   • <b>Несовместимость с разными браузерами</b> – параметры фреймов обладают свойством совершенно по-разному отображаться в различных браузерах. Причем противоречие между ними настолько явное, что одни и те же параметры интерпретируются браузерами совершенно по-своему.<br></br>   • <b>Непрестижность</b> – весьма странный недостаток, который не имеет никакого отношения к техническим особенностям создания сайта, а носит скорее идеологический характер. Сайты с фреймами считаются несолидными, а их авторы сразу выпадают из разряда профессионалов, которые никогда не используют фреймы в своих работах. Исключение составляют чаты, где без фреймов обойтись просто невозможно.<br></br></div><h2 id="idm139732202477136">Резюме
</h2><div style="text-align: justify" class="hsection2">   В этой главе вы познакомились с фреймами, которые являются одними из основных объектов HTML. Вы научились создавать их и управлять отдельными их элементами. Кроме того, вы узнали, в каких целях эффективно использовать фреймы и какие они имеют достоинства и недостатки в своем использовании.<br></br>   Однако в среде веб-мастеров использование фреймов традиционно считается дурным тоном. На то есть много серьезных оснований, о которых говорилось выше. Хотя в некоторых случаях использование фреймов дает такие преимущества, что отказываться от них просто неразумно. У фреймов наряду с недостатками есть и достоинства, которые не позволяют отбросить эту технологию как бесперспективную. Использовать или не использовать фреймы на сайте – решать именно вам.<br></br></div></div><h1 xmlns="http://www.w3.org/1999/xhtml" id="idm139732202478544" class="master">Глава 6<br></br>
Конструирование форм
</h1><div xmlns="http://www.w3.org/1999/xhtml" style="text-align: justify" class="hsection1"><div style="text-align: justify" class="section2">   6.1. Элемент FORM<br></br>
   6.2. Создание полей формы<br></br>
   Что главное в Интернете? Его интерактивность. Можно общаться с посетителями сайта и получать от них отзывы о работе – такое взаимодействие всегда полезно и интересно. Создатели сайта узнают, насколько он интересен посетителям, и могут изменить его в лучшую сторону, а посетители получают возможность участвовать в жизни сайта, общаться друг с другом и с его создателями.<br></br>
   В этой главе мы рассмотрим объект, который помогает организовать взаимодействие пользователя с авторами сайта, – формы. Формы позволяют получать информацию о посетителях – любая информация, введенная в форму, может быть отправлена создателю сайта.<br></br>
   Формы напоминают анкеты, в них есть возможность создавать поля, в которые пользователь сам может ввести любую информацию, и поля-списки, где ему нужно выбрать ответ из вариантов, предложенных автором. Возможности форм по группировке и представлению информации позволяют разместить ее наилучшим образом. В умелых руках это мощный и полезный инструмент.<br></br>
   Главное при создании форм – следить за тем, чтобы предложенные вами поля были удобны для посетителей и приемлемы для ответов на ваши вопросы.<br></br>
   Технически формы передают данные от пользователя удаленному серверу. Это позволяет создавать системы регистрации пользователей, форумы, гостевые книги. Для получения и обработки данных форм используются языки веб-программирования (PHP, Perl), но мы не касаемся их в этой книге. Хотя и придется рассмотреть моменты, имеющие отношение к программированию, сконцентрируемся на тех особенностях и возможностях форм, которые пригодятся дизайнеру, чтобы грамотно и удобно расставлять их на странице.<br></br>
</div><h2 id="idm139732202482512">6.1. Элемент FORM
</h2><div style="text-align: justify" class="hsection2">   Основой любой формы служит элемент FORM, требующий наличия закрывающего тега. Атрибуты этого элемента содержат информацию, общую для всех полей формы. На самом деле в одну форму надо включать поля, объединенные логически, потому что в один момент на сервер можно отправить только одну форму.<br></br>   Большинство атрибутов этого элемента влияют на обработку формы, а не на ее внешний вид. Однако необходимо знать, для чего они предназначены, чтобы понимать, как связать форму с кодом.<br></br>   Главным для рассматриваемого элемента является атрибут action, указывающий обработчик данных для формы. Обработчик – это файл, в котором описано, что нужно делать с данными формы. Создать этот файл – дело программиста, однако переменные, которые будут туда передаваться (их имена и возможные значения), зависят от тех, кто описывает форму. Сам обработчик может быть написан на любом языке, например это может быть файл test.php, как в примере из листинга 6.1. Если значение атрибута action не будет указано, то страница перезагрузится, а все элементы формы примут значения, заданные по умолчанию, то есть в этом случае форма окажется абсолютно бесполезной. В качестве значения данного атрибута надо указать URL-путь к файлу-обработчику на сервере.<br></br>   Рассмотрим пример из листинга 6.1. Файл обработки находится по адресу test. php, именно ему и будут переданы все данные, введенные в форму.<br></br><h5 class="subtitle"><b>Листинг 6.1.</b> Атрибут action элемента FORM</h5>   &lt;html&gt;<br></br>   &lt;head&gt;<br></br>   &lt;title&gt;Конструирование форм&lt;/title&gt;<br></br>   &lt;/head&gt;<br></br>   &lt;body&gt;<br></br>   &lt;form action="test.php"&gt;<br></br>   &lt;/form&gt;<br></br>   &lt;/body&gt;<br></br>   &lt;/html&gt;<br></br>   Сам файл test.php может делать с данными что угодно, например занести их в базу или отправить вам по почте. В общем, в том, что касается обработки данных, возможностей много, а реализуются они очень просто: дайте команду вашему программисту. Никаких усилий с вашей стороны.<br></br>   Что же делать, если программиста нет, а получить данные от пользователя нужно? Можно сделать так, чтобы заполненная посетителем форма приходила вам на почту. Для этого надо в качестве значения атрибута action указать электронный адрес, на который должна приходить форма, начав с ключевого слова mailto. Для корректной обработки данных в этом случае необходимо указать значение атрибута enctype="text/plain".<br></br>   В листинге 6.2 приведен пример того, как можно отправить данные по электронной почте. При отправке формы откроется почтовый клиент, установленный на компьютере пользователя, и появится предложение отправить данные формы в письме.<br></br><h5 class="subtitle"><b>Листинг 6.2.</b> Отправка данных формы по почте</h5>   &lt;html&gt;<br></br>   &lt;head&gt;<br></br>   &lt;title&gt;Конструирование форм&lt;/title&gt;<br></br>   &lt;/head&gt;<br></br>   &lt;body&gt;<br></br>   &lt;form action="mailto:test@test.ru" enctype="text/plain"&gt;<br></br>   &lt;/form&gt;<br></br>   &lt;/body&gt;<br></br>   &lt;/html&gt;<br></br>   В письме будет отправлен текстовый файл, в котором названиям полей формы будут присвоены значения, которые ввел посетитель. Иначе говоря, вам придет текст такого вида:<br></br>   название_поля=значение_введенное_посетителем<br></br>   Вообще атрибут enctype используют для указания MIME-типа данных, отправляемых вместе с формой. Использовать этот атрибут обязательно только в случае отправки файла через форму, тогда значение атрибута должно быть multipart/ form-data.<br></br>   В листинге 6.3 показан вариант задания атрибута enctype, когда через форму будет отправляться файл.<br></br><h5 class="subtitle"><b>Листинг 6.3.</b> Атрибут enctype элемента FORM</h5>   &lt;html&gt;<br></br>   &lt;head&gt;<br></br>   &lt;title&gt;Конструирование форм&lt;/title&gt;<br></br>   &lt;/head&gt;<br></br>   &lt;body&gt;<br></br>   &lt;form action="test.php" enctype="multipart/form-data"&gt;<br></br>   &lt;/form&gt;<br></br>   &lt;/body&gt;<br></br>   &lt;/html&gt;<br></br>   Отправка файлов – важная возможность форм, потому что вместо ввода информации вручную пользователь может просто отправить вам файл, в котором будет содержаться необходимая информация.<br></br>   Еще одним обязательным атрибутом является атрибут method, который задает то, как будет передаваться форма. При выборе метода отправки формы нужно ориентироваться на данные, которые необходимо отправить вместе с ней. Основную роль играет объем данных.<br></br>   Существуют два основных метода: GET и POST. Рассмотрим применение каждого из них.<br></br>   • GET – это наиболее распространенный метод, который применяется для получения данных с сервера. В методе GET данные на сервер передаются через адресную строку браузера. Он же вызывается, когда вы вводите адрес сайта в адресной строке или щелкаете кнопкой мыши на ссылке. В этом методе при формировании запроса к серверу все переменные и их значения формируют последовательность вида <a href="http://www.mytestserver.ru/form.php?var1=1&amp;var2=2">www.mytestserver.ru/form.php?var1=1&amp;var2=2</a>. Иными словами, имена и значения переменных присоединяются к адресу сервера после знака? и разделяются знаком &amp;.<br></br>   Этот метод нужно использовать, если вы не передаете больших объемов информации. Если же вместе с формой вы хотите переслать на сервер файл, этот метод не подойдет.<br></br>   • POST – применяется для отправки данных на сервер. Данные, отправляемые с помощью этого метода, не видны в заголовке URL, поскольку они содержатся в теле сообщения. Именно поэтому метод POST подходит для отправки больших объемов информации.<br></br>   В листинге 6.4 для отправки формы выбран метод POST, потому что вместе с формой нужно передать файлы.<br></br><h5 class="subtitle"><b>Листинг 6.4.</b> Атрибут method элемента FORM</h5>   &lt;html&gt;<br></br>   &lt;head&gt;<br></br>   &lt;title&gt;Конструирование форм&lt;/title&gt;<br></br>   &lt;/head&gt;<br></br>   &lt;body&gt;<br></br>   &lt;form action="test.php" enctype="multipart/form-data" method="post"&gt;<br></br>   &lt;/form&gt;<br></br>   &lt;/body&gt;<br></br>   &lt;/html&gt;<br></br>   Форма готова для передачи файлов и больших объемов информации.<br></br>   Теперь, чтобы позволить программисту управлять формой, надо задать ее имя. Для этого нужно использовать атрибут name. С его помощью можно указать уникальное имя формы, которое будет использоваться для доступа к элементам формы через сценарии.<br></br>   В листинге 6.5 показан пример задания имени формы. Теперь открыт доступ к форме через сценарии.<br></br><h5 class="subtitle"><b>Листинг 6.5.</b> Атрибут name элемента FORM</h5>   &lt;html&gt;<br></br>   &lt;head&gt;<br></br>   &lt;title&gt;Конструирование форм&lt;/title&gt;<br></br>   &lt;/head&gt;<br></br>   &lt;body&gt;<br></br>   &lt;form action="test.php" enctype="multipart/form-data" method="get" name="test"&gt;<br></br>   &lt;/form&gt;<br></br>   &lt;/body&gt;<br></br>   &lt;/html&gt;<br></br>   Было задано логичное и понятное имя для формы.<br></br><blockquote><div>   <b>Совет</b><br></br>
   Старайтесь делать логичными имена форм и всех полей. Учтите, что программисту, который будет писать вам обработчик, придется использовать их многократно. Согласуйте с программистом правила создания имен, что сэкономит и ваше, и его время.<br></br>
</div></blockquote>   Вот мы добрались до единственного атрибута, который не заинтересует программистов, зато пригодится нам. Это атрибут target. Именно он указывает на то, в каком окне выводить результат обработки формы. Над этим стоит задуматься, потому что не всегда будет удобно выводить результат обработки формы в то же окно, где была сама форма.<br></br>   Рассмотрим значения параметра target.<br></br>   • _blank – загружает страницу в новое окно браузера.<br></br>   • _self – загружает страницу в текущее окно.<br></br>   • _parent – загружает страницу во фрейм-родитель. Если фреймов нет, то работает как _self.<br></br>   • _top – отменяет все фреймы и загружает страницу в полном окне браузера. Если фреймов нет, то работает как _self.<br></br>   В листинге 6.6 представлен пример кода, который после обработки страницы будет загружать результат в новом окне браузера.<br></br><h5 class="subtitle"><b>Листинг 6.6.</b> Атрибут target элемента FORM</h5>   &lt;html&gt;<br></br>   &lt;head&gt;<br></br>   &lt;title&gt;Конструирование форм&lt;/title&gt;<br></br>   &lt;/head&gt;<br></br>   &lt;body&gt;<br></br>   &lt;form action="test.php" enctype="multipart/form-data" method="get" name="test" target="_blank"&gt;<br></br>   &lt;/form&gt;<br></br>   &lt;/body&gt;<br></br>   &lt;/html&gt;<br></br>   Открывать результаты в новом окне удобно, например, когда создается форма для поиска.<br></br>   С элементом FORM мы разобрались: рассмотрели его основные атрибуты. Большинство атрибутов отвечают за параметры обработки формы и за ее общие настройки.<br></br>   Кстати, если вы пробовали вывести код любого листинга из представленных выше и посмотреть, как он выглядит в браузере, то наверняка удивились, что увидели только белую страницу. Как говорилось выше, элемент FORM логически объединяет поля таблицы, сами же поля создаются с помощью других элементов, которые мы и рассмотрим дальше.<br></br></div><h2 id="idm139732169303248">6.2. Создание полей формы
</h2><div style="text-align: justify" class="hsection2"><div style="text-align: justify" class="section3">   Теперь приступим к самому интересному – к созданию полей для форм. Полей, из которых можно составить форму, очень много, поэтому надо внимательно следить за выбором поля для представления конкретной информации. Говоря о каждом из видов, мы будем рассматривать, в каких случаях его можно использовать. Ведь есть поля с похожими функциями, разница будет только в удобстве применения конкретного поля в конкретной ситуации.<br></br>
</div><h3 id="idm139732169304400">Общие атрибуты элемента INPUT
</h3><div style="text-align: justify" class="hsection3">   Большинство полей для формы создается с помощью элемента INPUT. Атрибуты элемента отличаются в зависимости от поля, для создания которого используется этот элемент. Тем не менее есть атрибуты, которые можно, а некоторые даже нужно применять вне зависимости от типа поля.<br></br>   Начнем с главного атрибута, который, собственно, и задает поле, – с атрибута type. Он принимает значение, указывающее на тип поля. В табл. 6.1 описано, какое значение может принимать атрибут и какому полю оно соответствует. Дальше мы подробно рассмотрим каждый тип поля и атрибуты, которые могут применяться вместе с ним.<br></br><h5 class="subtitle"><b>Таблица 6.1.</b> Значения атрибута type</h5><div style="text-align: center;"><img src="i_077.png" alt=""></img></div>   В таблице поля описаны кратко, подробно мы их рассмотрим позже, но теперь у вас есть некоторое представление о возможностях элемента INPUT.<br></br>   Следующий атрибут, который мы рассмотрим, является обязательным и называется name. Его значение задает уникальное имя поля. Введенная пользователем информация будет передаваться обработчику в качестве значения переменной с именем поля. Этот атрибут имеет значение для программистов, поэтому имя должно быть логичным.<br></br>   Иногда бывает нужно запретить пользователю изменение данных поля, например, чтобы он не смог поменять уже введенную информацию. Чтобы запретить изменение данных, в любое поле можно добавить атрибут disabled. При этом поле не просто нельзя будет поменять, его невозможно даже взять в фокус.<br></br>   Атрибут value задает значение, которое будет передано обработчику. По сути, он определяет данные, введенные в поле. Для текстовых полей с помощью этого атрибута можно установить значение по умолчанию. Введя в поле значение по умолчанию, можно пояснить пользователю, какие данные и в каком формате вы хотите здесь видеть. Это как образец: гораздо удобнее заполнять форму, видя перед собой пример.<br></br>   Для полей, предоставляющих возможность выбора, атрибут value определяет, какое значение будет передано обработчику при выборе конкретного пункта. В таком случае важно, чтобы значения этого параметра логически соответствовали пунктам, из которых можно выбирать. Помните о том, что с этими данными придется работать другим людям.<br></br>   Рассмотренные выше атрибуты можно применять в любых полях, они всегда будут действовать. Теперь пора разобраться с самими полями. Начнем с текстового поля.<br></br></div><h3 id="idm139732169308880">Текстовые поля
</h3><div style="text-align: justify" class="hsection3">   Без ввода текста никак не обойтись, потому что без него потеряется смысл создания формы. Рассмотрим поля для ввода текста в одну строку, для многострочного ввода служат другие элементы, которые мы разберем позже. Однострочное поле удобно для ввода имени, пароля и любой другой короткой информации.<br></br>   Для создания текстового поля указываем значение атрибута TYPE="text". Вместе с этим атрибутом можно использовать атрибут maxlenght, значение которого определяет максимальное количество символов, которые можно ввести в данную строку. Этот атрибут имеет смысл применять, например, чтобы злоумышленник не смог засорить базу бессмысленными строками большой длины. Однако выбирать значение этого атрибута надо осторожно, чтобы у честного пользователя не возникло проблем с вводом информации.<br></br>   Можно также задать длину поля ввода, используя атрибут size. Следить за длиной поля важно, потому что при вводе строки большой длины пользователю удобно видеть ее целиком. И наоборот, нет необходимости оставлять большое поле, если надо ввести один или два символа, – это будет неудобно. Таким образом, над размерами поля для ввода текста нужно подумать.<br></br><blockquote><div>   <b>Внимание!</b><br></br>
   Ширина текстового поля определяется количеством символов моноширинного шрифта, то есть она задается количеством стоящих рядом букв одинаковой ширины. Если размер шрифта изменяется с помощью стилей, то ширина также соответственно меняется. Это справедливо для всех текстовых полей в формах.<br></br>
</div></blockquote>   В листинге 6.7 приведен пример полей для ввода основной информации о посетителе. Для поля Введите логин мы использовали атрибут maxlenght и ограничили его по количеству знаков, для других полей ограничений нет. Атрибут size нет необходимости использовать, так как все поля имеют размер, адекватный информации, которую в них нужно ввести. Для всех полей заданы значения по умолчанию, которые поясняют, какую информацию требуется ввести.<br></br><h5 class="subtitle"><b>Листинг 6.7.</b> Создание поля для ввода текста</h5>   &lt;html&gt;<br></br>   &lt;head&gt;<br></br>   &lt;title&gt;Конструирование форм&lt;/title&gt;<br></br>   &lt;/head&gt;<br></br>   &lt;body&gt;<br></br>   &lt;form action="test.php" enctype="multipart/form-data" method="post" name= "test" target="_blank"&gt;<br></br>   Имя: &lt;input type="text" name="Reg_name" value="Ваше имя" /&gt;&lt;br /&gt;<br></br>   Фамилия: &lt;input type="text" name="Reg_surname" value="Ваша фамилия" /&gt;&lt;br /&gt;<br></br>   Отчество: &lt;input type="text" name="Reg_patronymic" value="Ваше отчество" /&gt;&lt;br /&gt;<br></br>   Введите логин: &lt;input type="text" name="Reg_login" maxlength="12" value= "&lt; 10 знаков" size="14" /&gt;&lt;br/&gt;<br></br>   &lt;/form&gt;<br></br>   &lt;/body&gt;<br></br>   &lt;/html&gt;<br></br>   Результат обработки листинга 6.7 показан на рис. 6.1.<br></br><div class="wrap_pict"><div style="text-align: center;"><img src="i_078.png" alt=""></img></div>   <b>Рис. 6.1.</b> Текстовые поля для ввода данных о пользователе<br></br></div><br></br>   Теперь у вас есть первые четыре поля для ввода данных о посетителе. Пользователю нужно придумать имя для входа и, соответственно, пароль.<br></br></div><h3 id="idm139732169270608">Поле для ввода пароля
</h3><div style="text-align: justify" class="hsection3">   Чтобы создать поле для ввода пароля, задаем значение атрибута type="password". Особенность этого поля в том, что все введенные буквы закрываются звездочками (или точками, в зависимости от системы) и увидеть вводимый пароль невозможно.<br></br>   Вместе с этим полем можно использовать те же атрибуты, что и для строки ввода текста, то есть maxlenght и size.<br></br>   В листинге 6.8 представлен пример создания поля для ввода пароля.<br></br><h5 class="subtitle"><b>Листинг 6.8.</b> Создание поля для ввода пароля</h5>   &lt;html&gt;<br></br>   &lt;head&gt;<br></br>   &lt;title&gt;Конструирование форм&lt;/title&gt;<br></br>   &lt;/head&gt;<br></br>   &lt;body&gt;<br></br>   &lt;form action="test.php" enctype="multipart/form-data" method="post" name="test" target="_blank"&gt;<br></br>   Введите пароль: &lt;input type="password" name="Reg_password" value= "Пароль" /&gt;&lt;br/&gt;<br></br>   &lt;/form&gt;&lt;/body&gt;<br></br>   &lt;/html&gt;<br></br>   Результат обработки браузером кода из листинга 6.8 представлен на рис. 6.2.<br></br><div class="wrap_pict"><div style="text-align: center;"><img src="i_079.png" alt=""></img></div>   <b>Рис. 6.2.</b> Поле для ввода пароля<br></br></div><br></br>   На рис. 6.2 видно, что вместо текста в поле ввода видны точки – теперь пароль нельзя узнать.<br></br>   После ввода личной информации пользователь должен отправить ее на сервер. Для этого служит инструмент, который мы рассмотрим дальше.<br></br></div><h3 id="idm139732169278928">Кнопки
</h3><div style="text-align: justify" class="hsection3">   При создании формы без кнопок не обойтись: с их помощью можно отправить, очистить или отредактировать форму. В общем, кнопки необходимы. Мы можем создавать разные кнопки, в зависимости от того, что нужно сделать с формой.<br></br>   Чтобы создать обычную кнопку, присваиваем атрибуту type значение «button». Если надо создать кнопку, которая будет отправлять форму обработчику, устанавливаем type="submit", а если создаем кнопку, очищающую форму, то type="reset".<br></br>   Думаю, необходимость наличия в любой форме кнопок очевидна, без них элементарно невозможно будет отправить данные обработчику. Чаще всего создаются две кнопки: для отправки данных и для очистки формы. Для большинства форм такого набора достаточно.<br></br>   Значение атрибута value задает надпись на кнопке, что очень полезно, потому что надписи по умолчанию очень скучные.<br></br>   В примере из листинга 6.9 описано создание кнопок с разными надписями.<br></br><h5 class="subtitle"><b>Листинг 6.9.</b> Создание кнопок</h5>   &lt;html&gt;<br></br>   &lt;head&gt;<br></br>   &lt;title&gt;Конструирование форм&lt;/title&gt;<br></br>   &lt;/head&gt;<br></br>   &lt;body&gt;<br></br>   &lt;form action="test.php" enctype="multipart/form-data" method="post" name= "test" target="_blank"&gt;<br></br>   Надпись по умолчанию:&lt;br /&gt;<br></br>   &lt;input name="submit" type="submit"/&gt;&lt;input name="reset" type="reset"/&gt;&lt;br&gt;<br></br>   Заданные надписи:&lt;br /&gt;<br></br>   &lt;input name="submit" type="submit" value="Отправить"/&gt;&lt;input name="reset" type="reset" value="Очистить"/&gt;&lt;br /&gt;<br></br>   &lt;input name="submit" type="submit" value="Отправить заполненную форму"/&gt; &lt;input name="reset" type="reset" value="Стереть все введенные данные"/&gt;&lt;br/&gt;<br></br>   &lt;/form&gt;<br></br>   &lt;/body&gt;<br></br>   &lt;/html&gt;<br></br>   Результат обработки кода из листинга 6.9 показан на рис. 6.3.<br></br><div class="wrap_pict"><div style="text-align: center;"><img src="i_080.png" alt=""></img></div>   <b>Рис. 6.3.</b> Кнопки с разными надписями<br></br></div><br></br>   Видно, что надписи по умолчанию могут быть не очень понятны посетителю сайта, причем они могут различаться в зависимости от системы пользователя. Для нашей формы выберем второй вариант кнопок, так как он самый понятный и лаконичный.<br></br>   У нас есть готовая маленькая форма, но, думаю, можно получить еще немного информации о пользователе. Для этого добавим еще поля.<br></br></div><h3 id="idm139732169150544">Переключатели
</h3><div style="text-align: justify" class="hsection3">   Если вы задаете посетителю вопрос и уверены, что знаете все возможные варианты ответа на него, а также хотите, чтобы посетитель выбрал только один из предложенных вами вариантов, используйте переключатель. Только убедитесь, что действительно предоставили пользователю все возможные варианты ответов.<br></br><blockquote><div>   <b>Совет</b><br></br>
   Даже если вам кажется, что вы придумали все возможные ответы, учтите: посетители сайта хитры и могут придумать то, что не пришло в голову вам. Поэтому предусматривайте поле с вариантом ответа Другое. А еще посетитель может не захотеть отвечать на ваш вопрос, для такого случая надо добавить пункт Не хочу отвечать.<br></br>
</div></blockquote>   Для создания переключателя устанавливаем type="radio" и получаем симпатичный кружочек. Текст пункта вводится рядом с тегом &lt;INPUT&gt;. Особенность переключателя в том, что можно выбрать только одно положение из всех возможных. Для всех переключателей, которые принадлежат к одной группе, должно быть установлено одинаковое значение атрибута name. Атрибут value в этом случае содержит значение, которое будет передано обработчику, если пользователь выберет указанное положение.<br></br>   Вместе с переключателями можно использовать атрибут checked, который задает положение, выбранное по умолчанию. Это удобно, если вы знаете самый частый вариант ответа на заданный вопрос. В таком случае, установив этот вариант по умол – чанию, вы упростите процесс заполнения формы для посетителей вашего сайта.<br></br>   В листинге 6.10 представлен пример создания различных вариантов переключателей.<br></br><h5 class="subtitle"><b>Листинг 6.10.</b> Создание переключателей</h5>   &lt;html&gt;<br></br>   &lt;head&gt;<br></br>   &lt;title&gt;Конструирование форм&lt;/title&gt;<br></br>   &lt;/head&gt;<br></br>   &lt;body&gt;<br></br>   &lt;form action="test.php" enctype="multipart/form-data" method="post" name="test" target="_blank"&gt;<br></br>   Ваш пол: &lt;input name="Reg_Gender" type="radio" value="man" /&gt;Мужской<br></br>   &lt;input name="Reg_Gender" type="radio" value="woman" /&gt;Женский<br></br>   &lt;input name="Reg_Gender" type="radio" value="dontanswer" checked /&gt;Не хочу отвечать&lt;br /&gt;<br></br>   Ваш возраст: &lt;input name="Reg_Age" type="radio" value="before18" /&gt;до 18<br></br>   &lt;input name="Reg_Age" type="radio" value="1825" /&gt;18-25<br></br>   &lt;input name="Reg_Age" type="radio" value="2535" /&gt;25-35&lt;br /&gt;<br></br>   &lt;input name="Reg_Age" type="radio" value="3550" /&gt;35-50<br></br>   &lt;input name="Reg_Age" type="radio" value="after50" /&gt;старше 50&lt;br /&gt;<br></br>   &lt;/form&gt;<br></br>   &lt;/body&gt;<br></br>   &lt;/html&gt;<br></br>   Результат обработки кода из листинга 6.10 представлен на рис. 6.4.<br></br><div class="wrap_pict"><div style="text-align: center;"><img src="i_081.png" alt=""></img></div>   <b>Рис. 6.4.</b> Переключатели<br></br></div><br></br>   Для создания опроса с переключателями мы выбрали вопросы, ответы на которые можно предположить. Один из вариантов ответа мы назначили выбранным по умолчанию, что видно на рис. 6.4.<br></br>   Следующий элемент поможет вам, когда можно позволить посетителю выбрать несколько вариантов ответов из всех предложенных.<br></br></div><h3 id="idm139732169130448">Флажки
</h3><div style="text-align: justify" class="hsection3">   Флажки напоминают переключатели тем, что дают пользователю возможность выбирать из предложенных вами вариантов. Главным отличием является то, что посетитель может выбрать сразу несколько пунктов, а сами пункты обозначаются квадратиками, а не кружочками.<br></br>   В группы эти элементы объединяются также присваиванием одинакового имени всем полям. Получать значения от таких полей труднее, потому что в одной группе может быть много выбранных пунктов.<br></br><blockquote><div>   <b>Примечание</b><br></br>
   Для получения значений из полей форм, в которых возможен множественный выбор, в качестве имени поля используют массив.<br></br>
</div></blockquote>   Для флажков можно использовать атрибут checked, который здесь можно установить для нескольких пунктов.<br></br>   В листинге 6.11 приведен пример создания опроса с флажками. Заданы несколько выбранных по умолчанию вариантов ответа.<br></br><h5 class="subtitle"><b>Листинг 6.11.</b> Создание флажков</h5>   &lt;html&gt;<br></br>   &lt;head&gt;<br></br>   &lt;title&gt;Конструирование форм&lt;/title&gt;<br></br>   &lt;/head&gt;<br></br>   &lt;body&gt;<br></br>   &lt;form action="test.php" enctype="multipart/form-data" method="post" name="test" target="_blank"&gt;<br></br>   Увлечения: &lt;input name="Reg_hobby[]" type="checkbox" value="sing" /&gt;Петь<br></br>   &lt;input name="Reg_hobby[]" type="checkbox" value="float" /&gt;Плавать<br></br>   &lt;input name="Reg_hobby[]" type="checkbox" value="walk" /&gt;Гулять<br></br>   &lt;input name="Reg_hobby[]" type="checkbox" value="work" checked /&gt;Работать&lt;br /&gt;<br></br>   &lt;input name="Reg_hobby[]" type="checkbox" value="drive" checked /&gt;Кататься на машине<br></br>   &lt;input name="Reg_hobby[]" type="checkbox" value="cook" /&gt;Готовить<br></br>   &lt;input name="Reg_hobby[]" type="checkbox" value="dance" /&gt;Танцевать<br></br>   &lt;input name="Reg_hobby[]" type="checkbox" value="read" checked /&gt; Читать&lt;br /&gt;<br></br>   &lt;/form&gt;<br></br>   &lt;/body&gt;<br></br>   &lt;/html&gt;<br></br>   Результат обработки браузером кода из листинга 6.11 приведен на рис. 6.5.<br></br><div class="wrap_pict"><div style="text-align: center;"><img src="i_082.png" alt=""></img></div>   <b>Рис. 6.5.</b> Флажки<br></br></div><br></br>   Теперь у вас достаточно данных о посетителе. Можно дать ему возможность отправить вам свое фото.<br></br></div><h3 id="idm139732169143120">Поле для ввода файла
</h3><div style="text-align: justify" class="hsection3">   Возможность отправлять файлы на сервер очень помогает в работе. Посетители могут загрузить свои фотографии, рисунки или видео. Это помогает создателю сайта взаимодействовать с посетителями, а посетителям взаимодействовать друг с другом.<br></br>   Для создания поля отправки файла надо установить значение атрибута type= «file». Особенность этого поля в том, что справа появляется кнопка, при нажатии которой пользователь сможет выбрать загружаемый файл через Проводник, что гораздо удобнее, чем вводить путь до файла вручную.<br></br>   Вместе с этим полем можно использовать атрибут size, что весьма актуально. При длинном пути к файлу посетителю удобнее видеть весь адрес целиком, поэтому длину строки можно установить достаточно большой.<br></br>   В листинге 6.12 показан пример создания поля размером 35 символов для ввода файла.<br></br><h5 class="subtitle"><b>Листинг 6.12.</b> Создание поля для загрузки файла</h5>   &lt;html&gt;<br></br>   &lt;head&gt;<br></br>   &lt;title&gt;Конструирование форм&lt;/title&gt;<br></br>   &lt;/head&gt;<br></br>   &lt;body&gt;<br></br>   &lt;form action="test.php" enctype="multipart/form-data" method="post" name= "test" target="_blank"&gt;<br></br>   Добавьте свое фото: &lt;input name="Reg_foto" type="file" size="55" /&gt;&lt;br/&gt;<br></br>   &lt;/form&gt;<br></br>   &lt;/body&gt;<br></br>   &lt;/html&gt;<br></br>   Результат обработки кода из листинга 6.12 показан на рис. 6.6 – создано поле выбора и отправки файла.<br></br><div class="wrap_pict"><div style="text-align: center;"><img src="i_083.png" alt=""></img></div>   <b>Рис. 6.6.</b> Поле для выбора файла<br></br></div><br></br>   У вас уже достаточно полная форма, теперь можно подумать о том, как сделать ее красочнее.<br></br></div><h3 id="idm139732169102544">Создание картинок
</h3><div style="text-align: justify" class="hsection3">   С помощью картинок можно украсить форму. Их можно использовать в качестве кнопок. Для задания кнопки-картинки указываем type="image". При этом необходимо задать атрибут src. Его значение – адрес картинки на сервере.<br></br>   Получается очень симпатичный вид формы, но надо следить за размером картинки, чтобы графические кнопки не оказались больше самой формы.<br></br>   Для полей картинок можно использовать атрибут alt, который задает альтернативный текст, всплывающий при наведении указателя мыши на изображение. Обязательно используйте этот атрибут, потому что, если у посетителя отключена загрузка картинок, это будет единственная возможность сообщить ему, куда надо нажать для отправки формы.<br></br>   Можно задать положение картинки на странице относительно текста с помощью атрибута align. Множество значений этого атрибута позволит вам выровнять изображение как угодно.<br></br>   Значения атрибута align:<br></br>   • left – по левому краю;<br></br>   • right – по правому краю;<br></br>   • top – выравнивание верхней границы картинки по самому высокому элементу строки;<br></br>   • texttop – выравнивание верхней границы картинки по самому высокому элементу текста;<br></br>   • middle – середина изображения выравнивается по базовой линии строки;<br></br>   • absmiddle – середина изображения выравнивается по середине строки;<br></br>   • baseline – выравнивание нижней границы изображения по базовой линии строки;<br></br>   • bottom – выравнивание нижней границы изображения по окружающему тексту.<br></br>   В листинге 6.13 представлен пример создания кнопок-картинок, которые предварительно нарисованы в графическом редакторе. Для них задано выравнивание и альтернативный текст.<br></br><h5 class="subtitle"><b>Листинг 6.13.</b> Создание графических кнопок</h5>   &lt;html&gt;<br></br>   &lt;head&gt;<br></br>   &lt;title&gt;Конструирование форм&lt;/title&gt;<br></br>   &lt;/head&gt;<br></br>   &lt;body&gt;<br></br>   &lt;form action="test.php" enctype="multipart/form-data" method="post" name= "test" target="_blank"&gt;<br></br>   &lt;input name="submit" type="image" src="Send.jpg" alt="Нажмите, чтобы отправить" align="left" border="5" /&gt;&lt;input name="reset" type="image" src= "Clear.jpg" alt="Нажмите для очистки формы" align="right" /&gt;<br></br>   &lt;/form&gt;<br></br>   &lt;/body&gt;<br></br>   &lt;/html&gt;<br></br>   Результат обработки браузером кода из листинга 6.13 показан на рис. 6.7.<br></br><div class="wrap_pict"><div style="text-align: center;"><img src="i_084.png" alt=""></img></div>   <b>Рис. 6.7.</b> Графические кнопки<br></br></div><br></br>   Нарисованные кнопки оживят вид вашей формы.<br></br></div><h3 id="idm139732169082448">Скрытые поля
</h3><div style="text-align: justify" class="hsection3">   Вместе с формой можно передавать дополнительную информацию, которая не должна быть видна пользователю.<br></br>   Для передачи служебной информации используются скрытые поля. Они не видны пользователю, однако информация из них передается обработчику. Такая информация часто носит служебный характер и не связана с данными, вводимыми пользователем. Это может быть, например, идентификатор посетителя в базе данных.<br></br>   Для создания скрытого поля указывается значение атрибута type="hidden". Для него нужны только атрибуты name и value – имя и значение переменной, передаваемые обработчику.<br></br>   В листинге 6.14 представлен пример создания скрытого поля, в котором вы можете передавать идентификатор пользователя.<br></br><h5 class="subtitle"><b>Листинг 6.14.</b> Скрытые поля</h5>   &lt;html&gt;<br></br>   &lt;head&gt;<br></br>   &lt;title&gt;Конструирование форм&lt;/title&gt;<br></br>   &lt;/head&gt;<br></br>   &lt;body&gt;<br></br>   &lt;form action="test.php" enctype="multipart/form-data" method="post" name= "test" target="_blank"&gt;<br></br>   &lt;input name="id_user" type="hidden" value="27" /&gt;<br></br>   &lt;/form&gt;<br></br>   &lt;/body&gt;<br></br>   &lt;/html&gt;<br></br>   Мы разобрались со всеми возможностями элемента INPUT. Дальше рассмотрим поля, которые входят в форму, но создаются с помощью других элементов.<br></br></div><h3 id="idm139732169089488">Списки
</h3><div style="text-align: justify" class="hsection3">   Списки дают возможность расположить большое количество пунктов компактно. При создании списков вы сами можете определить количество видимых элементов. Можно настроить возможность выбора одного или нескольких пунктов. По функциям списки напоминают переключатели и флажки, однако их плюс в компактности. С другой стороны, поиск по спискам занимает больше времени, хотя можно задать элементы, выбранные по умолчанию. В общем, советую использовать списки там, где много перечисляемых пунктов, или ориентироваться относительно дизайна и выбирать тот вариант, который лучше впишется в вашу страницу.<br></br>   Для создания списков используется элемент SELECT, у которого два атрибута, отвечающих за общее отображение списка. Атрибут size устанавливает количество видимых элементов из списка. Если size="1" и при этом количество элементов списка больше одного, то появится раскрывающийся список выбора. Если size больше единицы, то при количестве пунктов списка, превышающем его размер, появится полоса прокрутки, а если пунктов меньше, то в поле останется пустое место. Атрибут multiple дает возможность выбирать несколько элементов из списка, для этого при выборе надо нажать и удерживать нажатой клавишу Ctrl.<br></br>   Если же добавить на страницу элемент &lt;SELECT&gt; просто так, то вы увидите пустой список. Для добавления в список пунктов используются элементы OPTION, которые располагаются внутри элемента SELECT. Атрибут value задает значение, которое будет передано обработчику в случае выбора соответствующего пункта. Атрибут selected задает пункт, выбранный по умолчанию. Название элемента списка находится внутри элемента OPTION. Закрывающий тег не обязателен, но советую его использовать для обеспечения корректной работы.<br></br>   В листинге 6.15 представлены примеры раскрывающегося списка и списка с полосой прокрутки. Для списка с полосой прокрутки установлена возможность множественного выбора.<br></br><h5 class="subtitle"><b>Листинг 6.15.</b> Создание списков</h5>   &lt;html&gt;<br></br>   &lt;head&gt;<br></br>   &lt;title&gt;Конструирование форм&lt;/title&gt;<br></br>   &lt;/head&gt;<br></br>   &lt;body&gt;<br></br>   &lt;form action="test.php" enctype="multipart/form-data" method="post" name="test" target="_blank"&gt;<br></br>   Место проживания:<br></br>   &lt;select name="Reg_Place" size="1" &gt;<br></br>   &lt;option value="SPb"&gt;Санкт-Петербург&lt;/option&gt;<br></br>   &lt;option value="Mos" selected &gt;Москва&lt;/option&gt;<br></br>   &lt;option value="Ebr"&gt;Екатеринбург&lt;/option&gt;<br></br>   &lt;/select&gt;&lt;br /&gt;<br></br>   Области работы (можно выбрать несколько):&lt;br /&gt;<br></br>   &lt;select name="Reg_Work[]" size="4" multiple="multiple" &gt;<br></br>   &lt;option value="journ"&gt;Журналистика&lt;/option&gt;<br></br>   &lt;option value="progr"&gt;Программирование&lt;/option&gt;<br></br>   &lt;option value="site"&gt;Создание сайтов&lt;/option&gt;<br></br>   &lt;option value="HR"&gt;Управление персоналом&lt;/option&gt;<br></br>   &lt;option value="sale"&gt;Продажи&lt;/option&gt;<br></br>   &lt;option value="admin"&gt;Администрирование&lt;/option&gt;<br></br>   &lt;option value="trans"&gt;Перевод&lt;/option&gt;<br></br>   &lt;option value="PR"&gt;Реклама&lt;/option&gt;<br></br>   &lt;/select&gt;&lt;br /&gt;<br></br>   &lt;/form&gt;<br></br>   &lt;/body&gt;<br></br>   &lt;/html&gt;<br></br>   Результат обработки листинга 6.15 представлен на рис. 6.8.<br></br><div class="wrap_pict"><div style="text-align: center;"><img src="i_085.png" alt=""></img></div>   <b>Рис. 6.8.</b> Списки<br></br></div><br></br>   Теперь попробуем систематизировать и уточнить наши списки, чтобы посетителю было проще найти нужный пункт. В этом нам поможет элемент OPTGROUP, который создает заголовки в списках. У него есть единственный атрибут label, в котором указывается текст заголовка.<br></br>   В листинге 6.16 показан пример создания списка с заголовками.<br></br><h5 class="subtitle"><b>Листинг 6.16.</b> Использование элемента OPTGROUP</h5>   &lt;html&gt;<br></br>   &lt;head&gt;<br></br>   &lt;title&gt;Конструирование форм&lt;/title&gt;<br></br>   &lt;/head&gt;<br></br>   &lt;body&gt;<br></br>   &lt;form action="test.php" enctype="multipart/form-data" method="post" name="test" target="_blank"&gt;<br></br>   Место проживания:<br></br>   &lt;select name="R_Place" size="1" &gt;<br></br>   &lt;optgroup label="Россия"&gt;<br></br>   &lt;option value="SPb"&gt;Санкт-Петербург&lt;/option&gt;<br></br>   &lt;option value="Mos" selected &gt;Москва&lt;/option&gt;<br></br>   &lt;option value="Ebr"&gt;Екатеринбург&lt;/option&gt;<br></br>   &lt;optgroup label="Америка"&gt;<br></br>   &lt;option value="LA"&gt;Лос-Анджелес&lt;/option&gt;<br></br>   &lt;option value="Va"&gt;Вашингтон&lt;/option&gt;<br></br>   &lt;option value="NY"&gt;Нью-Йорк&lt;/option&gt;<br></br>   &lt;optgroup label="Франция"&gt;<br></br>   &lt;option value="Par"&gt;Париж&lt;/option&gt;<br></br>   &lt;option value="Lion"&gt;Лион&lt;/option&gt;<br></br>   &lt;/select&gt;&lt;br /&gt;<br></br>   Области работы (можно выбрать несколько):&lt;br /&gt;<br></br>   &lt;select name="R_Job" size="8" multiple="multiple" &gt;<br></br>   &lt;optgroup label="Журналистика"&gt;<br></br>   &lt;option value="biz"&gt;Бизнес&lt;/option&gt;<br></br>   &lt;option value="ecol"&gt;Экология&lt;/option&gt;<br></br>   &lt;option value="tur"&gt;Туризм&lt;/option&gt;<br></br>   &lt;optgroup label="Программирование"&gt;<br></br>   &lt;option value="web"&gt;Web-программирование&lt;/option&gt;<br></br>   &lt;option value="CPP"&gt;С/С++&lt;/option&gt;<br></br>   &lt;option value="Del"&gt;Delphi&lt;/option&gt;<br></br>   &lt;optgroup label="Создание сайтов"&gt;<br></br>   &lt;option value="Diz"&gt;Дизайн&lt;/option&gt;<br></br>   &lt;option value="Html"&gt;Верстка&lt;/option&gt;<br></br>   &lt;optgroup label="Перевод"&gt;<br></br>   &lt;option value="Eng"&gt;Английский&lt;/option&gt;<br></br>   &lt;option value="Fr"&gt;Французский&lt;/option&gt;<br></br>   &lt;option value="Ger"&gt;Немецкий&lt;/option&gt;<br></br>   &lt;optgroup label="Другое"&gt;<br></br>   &lt;option value="HR"&gt;Управление персоналом&lt;/option&gt;<br></br>   &lt;option value="sale"&gt;Продажи&lt;/option&gt;<br></br>   &lt;option value="admin"&gt;Администрирование&lt;/option&gt;<br></br>   &lt;option value="PR"&gt;Реклама&lt;/option&gt;<br></br>   &lt;/select&gt;&lt;br /&gt;<br></br>   &lt;/form&gt;<br></br>   &lt;/body&gt;<br></br>   &lt;/html&gt;<br></br><br></br>   Результат обработки браузером кода из листинга 6.16 представлен на рис. 6.9.<br></br><div class="wrap_pict"><div style="text-align: center;"><img src="i_086.png" alt=""></img></div>   <b>Рис. 6.9.</b> Группы в списках<br></br></div><br></br>   На рис. 6.9 видно, что списки стали гораздо удобнее, теперь посетителю проще найти нужный пункт.<br></br>   Подобные элементы, конечно, не являются обязательными, но надо заботиться о тех, кто заполняет форму. Деление списков на группы поможет пользователям сэкономить время и с легкостью найти нужный пункт.<br></br>   Есть только один недостаток – все эти списки и маленькие поля ограничивают простор фантазии посетителя, но это можно исправить.<br></br></div><h3 id="idm139732227100880">Большие текстовые поля
</h3><div style="text-align: justify" class="hsection3">   Большие текстовые поля дадут посетителю возможность проявить свое творческое начало. В них можно писать что угодно в любых количествах. Такая конструкция совершенно необходима, размеров обычного текстового поля не хватит для ввода текста большого объема. В больших полях можно вводить комментарии, сообщения и многое другое.<br></br>   Для создания таких полей применяется элемент TEXTAREA, который обязательно должен иметь закрывающий тег. Текст, вводимый по умолчанию, находится между открывающим и закрывающим тегами этого элемента. Размеры поля устанавливаются с помощью атрибутов cols и rows. Первый задает размеры по горизонтали, второй – по вертикали. Помните, что все размеры в формах считаются исходя из размера одного символа моноширинного шрифта.<br></br>   Можно запретить пользователю изменять текст в текстовом поле, что пригодится, если поле используется, например, для представления договора. Запрет вводится путем установки атрибута readonly.<br></br>   Еще один атрибут элемента TEXTAREA – wrap, указывающий браузеру, как осуществляется перенос текста и в каком виде текст отправляется на сервер. Этот атрибут может принимать три значения:<br></br>   • hard – автоматически переносит строку, когда она доходит до границы окна ввода, и передает на сервер с такой расстановкой переносов;<br></br>   • soft – переносит строку автоматически, но на сервер знак переноса передает только в том месте, где была нажата клавиша Enter;<br></br>   • off – переносит слова только при нажатии клавиши Enter, и, если строка превышает горизонтальный размер окна, появляется полоса прокрутки.<br></br>   В листинге 6.17 представлен пример создания больших текстовых полей. Первое поле с горизонтальной полосой прокрутки, второе – только для чтения.<br></br><h5 class="subtitle"><b>Листинг 6.17.</b> Создание больших текстовых полей</h5>   &lt;html&gt;<br></br>   &lt;head&gt;<br></br>   &lt;title&gt;Конструирование форм&lt;/title&gt;<br></br>   &lt;/head&gt;<br></br>   &lt;body&gt;<br></br>   &lt;form action="test.php" enctype="multipart/form-data" method="post" name= "test" target="_blank"&gt;<br></br>   Расскажите немного о себе:&lt;br /&gt;<br></br>   &lt;textarea cols="24" rows="10" name="about" wrap="off" &gt;Я самый лучший, лучше меня нет никого.&lt;/textarea&gt;&lt;br /&gt;<br></br>   Соглашение:&lt;br /&gt;<br></br>   &lt;textarea cols="24" rows="3" name="about" readonly &gt;Условия нашего соглашения&lt;/textarea&gt;&lt;br /&gt;<br></br>   &lt;/form&gt;&lt;/body&gt;<br></br>   &lt;/html&gt;<br></br>   Результат обработки кода из листинга 6.17 приведен на рис. 6.10.<br></br><div class="wrap_pict"><div style="text-align: center;"><img src="i_087.png" alt=""></img></div>   <b>Рис. 6.10.</b> Большие текстовые поля<br></br></div><br></br>   Очевидно, что такие поля – единственная возможность для ввода больших объемов текста, поэтому от их использования в форме никуда не деться.<br></br>   Все возможные поля для формы готовы, осталось добавить несколько мелочей. Возможности, которые мы рассмотрим дальше, необязательно использовать, но с ними формы становятся намного удобнее.<br></br></div><h3 id="idm139732227079376">Дополнительные удобства
</h3><div style="text-align: justify" class="hsection3">   Есть элементы, которые не очень сильно влияют на вид формы, но при этом делают работу с ней намного удобнее. Примером может служить элемент LABEL, который применяется при реализации выбора с помощью переключателей и флажков. Он необходим, чтобы вы могли выбрать нужный пункт, просто щелкая кнопкой мыши на тексте, связанном с ним. Без использования этого элемента посетителю приходится щелкать кнопкой мыши на кружочке или квадратике, хотя просто щелкнуть кнопкой мыши на тексте намного удобнее. Тем более становится неважно, где находится текст – при щелчке на нем кнопкой мыши будет выбран связанный с ним пункт меню.<br></br>   Использование этого элемента при работе с переключателями и флажками – самый распространенный вариант, однако это не ограничение. С таким же успехом можно связать текст с любым элементом формы, и при щелчке кнопкой мыши на тексте связанный элемент автоматически берется в фокус.<br></br>   Связывание текста с элементом формы осуществляется просто: вы устанавливаете атрибут id элемента INPUT, а затем берете в элемент LABEL нужный текст и присваиваете атрибуту for этого элемента значение, совпадающее со значением id для элемента INPUT того поля, с которым хотите связать текст.<br></br>   У элемента LABEL есть еще один замечательный атрибут – accesskey. Его значение устанавливает горячую клавишу для соответствующего элемента формы. Надо нажимать эту клавишу вместе с клавишей Alt, и фокус автоматически переместится на нужное поле.<br></br>   В листинге 6.18 показан пример использования элемента LABEL.<br></br><h5 class="subtitle"><b>Листинг 6.18.</b> Использование элемента LABEL</h5>   &lt;html&gt;<br></br>   &lt;head&gt;<br></br>   &lt;title&gt;Конструирование форм&lt;/title&gt;<br></br>   &lt;/head&gt;<br></br>   &lt;body&gt;<br></br>   &lt;form action="test.php" enctype="multipart/form-data" method="post" name="test" target="_blank"&gt;<br></br>   Ваш пол: &lt;input name="Reg_Gender" type="radio" value="man" /&gt;Мужской<br></br>   &lt;input name="Reg_Gender" type="radio" value="woman" /&gt;Женский<br></br>   &lt;input name="Reg_Gender" type="radio" value="dontanswer" checked /&gt;Не хочу отвечать&lt;br /&gt;<br></br>   Ваш возраст: &lt;input name="Reg_Age" type="radio" value="before18" id="ab18"/&gt;&lt;label for="ab18"&gt;до 18&lt;/label&gt;<br></br>   &lt;input name="Reg_Age" type="radio" value="1825" id="a1825" /&gt;&lt;label for="a1825"&gt;18-25&lt;/label&gt;<br></br>   &lt;input name="Reg_Age" type="radio" value="2535" id="a2535"/&gt;&lt;label for="a2535"&gt;25-35&lt;/label&gt;&lt;br /&gt;<br></br>   &lt;input name="Reg_Age" type="radio" value="3550" id="a3530"/&gt;&lt;label for="a3530"&gt;35-50&lt;/label&gt;<br></br>   &lt;input name="Reg_Age" type="radio" value="after50" id="aa50"/&gt;&lt;label for="aa50"&gt;старше 50&lt;/label&gt;&lt;br /&gt;<br></br>   &lt;/form&gt;<br></br>   &lt;/body&gt;<br></br>   &lt;/html&gt;<br></br>   Как видно, использование элемента LABEL может сильно упростить работу посетителей сайта.<br></br>   Осталось совсем немного: для большей наглядности сгруппируем вопросы из нашей формы по темам и составим наконец общую форму. В этом нам поможет элемент FIELDSET, который объединит поля формы, находящиеся внутри его контейнера, рамкой. У этого элемента есть атрибут title, который задает всплывающую подсказку для группы.<br></br>   Чтобы добавить заголовок для каждой группы, понадобится элемент LEGENG, который задает встраиваемый в рамку текст заголовка группы. У элемента LEGEND два атрибута: align задает выравнивание заголовка, а title – всплывающую подсказку к тексту заголовка. Возможностей выравнивания немного, но достаточно.<br></br>   Значения параметра align:<br></br>   • right – по правому краю;<br></br>   • left – по левому краю;<br></br>   • center – по центру.<br></br>   В листинге 6.19 показан итоговый код формы регистрации. В нем объединены все рассмотренные элементы.<br></br><h5 class="subtitle"><b>Листинг 6.19.</b> Форма регистрации</h5>   &lt;html&gt;<br></br>   &lt;head&gt;<br></br>   &lt;title&gt;Конструирование форм&lt;/title&gt;<br></br>   &lt;/head&gt;<br></br>   &lt;body&gt;<br></br>   &lt;form action="test.php" enctype="multipart/form-data" method="post" name= "test" target="_blank"&gt;<br></br>   &lt;fieldset title="Регистрационная информация"&gt;<br></br>   &lt;legend title="Регистрационная информация" align="left"&gt;Регистрационная информация&lt;/legend&gt;<br></br>   &lt;input name="id_user" type="hidden" value="27" /&gt;<br></br>   Введите логин: &lt;input type="text" name="Reg_login" maxlength="12" value= "&lt; 10 знаков" size="14" /&gt;&lt;br /&gt;<br></br>   Введите пароль: &lt;input type="password" name="Reg_password" value= "Пароль" /&gt;&lt;br /&gt;<br></br>   &lt;/fieldset&gt;<br></br>   &lt;fieldset title="Личная информация"&gt;<br></br>   &lt;legend title="Личная информация" align="center"&gt;Личная информация&lt;/legend&gt;<br></br>   Имя: &lt;input type="text" name="Reg_name" value="Ваше имя" /&gt;&lt;br /&gt;<br></br>   Фамилия: &lt;input type="text" name="Reg_surname" value="Ваша фамилия" /&gt;&lt;br /&gt;<br></br>   Отчество: &lt;input type="text" name="Reg_patronymic" value="Ваше отчество" /&gt;&lt;br /&gt;<br></br>   Ваш пол: &lt;input name="Reg_Gender" type="radio" value="man" /&gt;Мужской<br></br>   &lt;input name="Reg_Gender" type="radio" value="woman" /&gt;Женский<br></br>   &lt;input name="Reg_Gender" type="radio" value="dontanswer" checked /&gt;Не хочу отвечать&lt;br /&gt;<br></br>   Ваш возраст: &lt;input name="Reg_Age" type="radio" value="before18" id="ab18"/&gt;&lt;label for="ab18"&gt;до 18&lt;/label&gt;<br></br>   &lt;input name="Reg_Age" type="radio" value="1825" id="a1825" /&gt;&lt;label for="a1825"&gt;18-25&lt;/label&gt;<br></br>   &lt;input name="Reg_Age" type="radio" value="2535" id="a2535"/&gt;&lt;label for="a2535"&gt;25-35&lt;/label&gt;&lt;br /&gt;<br></br>   &lt;input name="Reg_Age" type="radio" value="3550" id="a3530"/&gt;&lt;label for="a3530"&gt;35-50&lt;/label&gt;<br></br>   &lt;input name="Reg_Age" type="radio" value="after50" id="aa50"/&gt;&lt;label for="aa50"&gt;старше 50&lt;/label&gt;&lt;br /&gt;<br></br>   &lt;/fieldset&gt;<br></br>   &lt;fieldset title="Дополнительная информация"&gt;<br></br>   &lt;legend title="Дополнительная информация" align="right"&gt;Дополнительная информация&lt;/legend&gt;<br></br>   Место проживания:<br></br>   &lt;select name="R_Place" size="1" &gt;<br></br>   &lt;optgroup label="Россия"&gt;<br></br>   &lt;option value="SPb"&gt;Санкт-Петербург&lt;/option&gt;<br></br>   &lt;option value="Mos" selected &gt;Москва&lt;/option&gt;<br></br>   &lt;option value="Ebr"&gt;Екатеринбург&lt;/option&gt;<br></br>   &lt;/optgroup&gt;<br></br>   &lt;optgroup label="Америка"&gt;<br></br>   &lt;option value="LA"&gt;Лос-Анджелес&lt;/option&gt;<br></br>   &lt;option value="Va"&gt;Вашингтон&lt;/option&gt;<br></br>   &lt;option value="NY"&gt;Нью-Йорк&lt;/option&gt;<br></br>   &lt;/optgroup&gt;<br></br>   &lt;optgroup label="Франция"&gt;<br></br>   &lt;option value="Par"&gt;Париж&lt;/option&gt;<br></br>   &lt;option value="Lion"&gt;Лион&lt;/option&gt;<br></br>   &lt;/optgroup&gt;<br></br>   &lt;/select&gt;&lt;br /&gt;<br></br>   Области работы (можно выбрать несколько):&lt;br /&gt;<br></br>   &lt;select name="R_Job" size="8" multiple="multiple" &gt;<br></br>   &lt;optgroup label="Журналистика"&gt;<br></br>   &lt;option value="biz"&gt;Бизнес&lt;/option&gt;<br></br>   &lt;option value="ecol"&gt;Экология&lt;/option&gt;<br></br>   &lt;option value="tur"&gt;Туризм&lt;/option&gt;<br></br>   &lt;/optgroup&gt;<br></br>   &lt;optgroup label="Программирование"&gt;<br></br>   &lt;option value="web"&gt;Web-программирование&lt;/option&gt;<br></br>   &lt;option value="CPP"&gt;С/С++&lt;/option&gt;<br></br>   &lt;option value="Del"&gt;Delphi&lt;/option&gt;<br></br>   &lt;/optgroup&gt;<br></br>   &lt;optgroup label="Создание сайтов"&gt;<br></br>   &lt;option value="Diz"&gt;Дизайн&lt;/option&gt;<br></br>   &lt;option value="Html"&gt;Верстка&lt;/option&gt;<br></br>   &lt;/optgroup&gt;<br></br>   &lt;optgroup label="Перевод"&gt;<br></br>   &lt;option value="Eng"&gt;Английский&lt;/option&gt;<br></br>   &lt;option value="Fr"&gt;Французский&lt;/option&gt;<br></br>   &lt;option value="Ger"&gt;Немецкий&lt;/option&gt;<br></br>   &lt;/optgroup&gt;<br></br>   &lt;optgroup label="Другое"&gt;<br></br>   &lt;option value="HR"&gt;Управление персоналом&lt;/option&gt;<br></br>   &lt;option value="sale"&gt;Продажи&lt;/option&gt;<br></br>   &lt;option value="admin"&gt;Администрирование&lt;/option&gt;<br></br>   &lt;option value="PR"&gt;Реклама&lt;/option&gt;<br></br>   &lt;/optgroup&gt;<br></br>   &lt;/select&gt;&lt;br /&gt;<br></br>   Увлечения: &lt;input name="Reg_hobby[]" type="checkbox" value="sing" /&gt;Петь<br></br>   &lt;input name="Reg_hobby[]" type="checkbox" value="float" /&gt;Плавать<br></br>   &lt;input name="Reg_hobby[]" type="checkbox" value="walk" /&gt;Гулять<br></br>   &lt;input name="Reg_hobby[]" type="checkbox" value="work" checked /&gt;Работать&lt;br /&gt;<br></br>   &lt;input name="Reg_hobby[]" type="checkbox" value="drive" checked /&gt;Кататься на машине<br></br>   &lt;input name="Reg_hobby[]" type="checkbox" value="cook" /&gt;Готовить<br></br>   &lt;input name="Reg_hobby[]" type="checkbox" value="dance" /&gt;Танцевать<br></br>   &lt;input name="Reg_hobby[]" type="checkbox" value="read" checked /&gt; Читать&lt;br /&gt;<br></br>   Добавьте свое фото: &lt;input name="Reg_foto" type="file" size="55" /&gt;&lt;br /&gt;<br></br>   Расскажите немного о себе:&lt;br /&gt;<br></br>   &lt;textarea cols="24" rows="10" name="about" wrap="off" &gt;Я самый лучший, лучше меня нет никого.&lt;/textarea&gt;&lt;br /&gt;<br></br>   &lt;/fieldset&gt;<br></br>   &lt;fieldset title="Информация о нас"&gt;<br></br>   &lt;legend title="Информация о нас" align="center"&gt;Информация о нас&lt;/legend&gt;<br></br>   Соглашение:&lt;br /&gt;<br></br>   &lt;textarea cols="24" rows="3" name="about" readonly &gt;Условия нашего соглашения&lt;/textarea&gt;&lt;br /&gt;<br></br>   &lt;/fieldset&gt;<br></br>   &lt;input name="submit" type="image" src="Send.jpg" alt="Нажмите, чтобы отправить" align="left" border="5" /&gt;&lt;input name="reset" type="image" src="Clear.jpg" alt="Нажмите для очистки формы" align="right" /&gt;<br></br>   &lt;/form&gt;<br></br>   &lt;/body&gt;<br></br>   &lt;/html&gt;<br></br>   Фрагмент формы регистрации с объединением полей в группы показан на рис. 6.11.<br></br><div class="wrap_pict"><div style="text-align: center;"><img src="i_088.png" alt=""></img></div>   <b>Рис. 6.11.</b> Фрагмент итоговой формы<br></br></div><br></br>   На рис. 6.11 видно, что после объединения полей в группы форма стала намного удобнее и логичнее.<br></br></div></div><h2 id="idm139732227034704">Резюме
</h2><div style="text-align: justify" class="hsection2">   Мы рассмотрели все возможности построения форм и создали достаточно большую форму регистрации. Возможности, которые предоставляют формы, очень велики. Это главный инструмент общения пользователей в Интернете. Использование форм на сайте позволяет иметь обратную связь с посетителями, а также расширить функциональность сайта.<br></br></div></div><h1 xmlns="http://www.w3.org/1999/xhtml" id="idm139732227035728" class="master">Глава 7<br></br>
Введение в таблицы стилей и язык CSS
</h1><div xmlns="http://www.w3.org/1999/xhtml" style="text-align: justify" class="hsection1"><div style="text-align: justify" class="section2">   7.1. Встраивание CSS в HTML<br></br>
   7.2. Синтаксис CSS<br></br>
   7.3. Селекторы<br></br>
   7.4. Псевдоэлементы и псевдоклассы<br></br>
   7.5. Правило @media<br></br>
   7.6. Правила!important<br></br>
   7.7. Правило @impor<br></br>
   В этой главе вы изучите основы языка CSS. Вы увидите, насколько легко разрабатываются таблицы стилей. Для этого достаточно лишь иметь общие представления о языке HTML, который мы подробно разобрали в предыдущих главах. Язык CSS в настоящее время считается основным средством оформления веб-страниц, пришедшим на смену тегов и атрибутов форматирования. Язык HTML 4 пока еще поддерживает эти средства, но они относятся к числу устаревших и нежелательных. В языке же XHTML оформление веб-страниц допускается только средствами CSS, поэтому если вы хотите, чтобы ваш сайт служил долгие годы, с самого начала создавайте его средствами CSS.<br></br>
</div><h2 id="idm139732203561936">7.1. Встраивание CSS в HTML
</h2><div style="text-align: justify" class="hsection2">   Начнем разбирать таблицы стилей с небольшого HTML-документа (листинг 7.1).<br></br><h5 class="subtitle"><b>Листинг 7.1.</b> Простой HTML-документ</h5>   &lt;html&gt;<br></br>   &lt;head&gt;<br></br>   &lt;title&gt;Моя домашняя страница&lt;/title&gt;<br></br>   &lt;/head&gt;<br></br>   &lt;body&gt;<br></br>   &lt;h1&gt;Моя домашняя страница&lt;/h1&gt;<br></br>   &lt;p&gt;На этой странице вы найдете информацию обо мне и моих друзьях.<br></br>   &lt;/body&gt;<br></br>   &lt;/html&gt;<br></br>   Чтобы сделать текст из элемента H1 синим, вместо обычного атрибута color элемента FONT нужно использовать следующее CSS-правило:<br></br>   h1 { color: blue }<br></br>   Собственно правило в CSS состоит из двух частей: селектора H1 и описания color: blue. Описание, в свою очередь, также имеет две части: свойство color и значение blue. В последующих разделах мы подробно разберем, что такое селектор, и, двигаясь дальше, узнаем, какие бывают свойства CSS и их значения.<br></br>   В спецификации языка HTML 4 описано два правила описания таблиц стилей для HTML-документов. Первый – это вставка CSS-кода непосредственно внутрь HTML-документа. Второй – это запись таблицы стилей во внешнем файле и установка ссылки на этот файл в HTML-документе.<br></br>   Чтобы добавить CSS непосредственно внутрь HTML, используется элемент STYLE, который должен располагаться внутри заголовка документа, то есть внутри элемента HEAD. В листинге 7.2 приведен пример простой HTML-страницы с записанной таблицей стилей внутри документа.<br></br><h5 class="subtitle"><b>Листинг 7.2.</b> CSS внутри HTML-документа</h5>   &lt;html&gt;<br></br>   &lt;head&gt;<br></br>   &lt;title&gt;Моя домашняя страница&lt;/title&gt;<br></br>   &lt;style type="text/css"&gt;<br></br>   h1 { color: blue }<br></br>   &lt;/style&gt;<br></br>   &lt;/head&gt;<br></br>   &lt;body&gt;<br></br>   &lt;h1&gt;Моя домашняя страница&lt;/h1&gt;<br></br>   &lt;p&gt;На этой странице вы найдете информацию обо мне и моих друзьях.<br></br>   &lt;/body&gt;<br></br>   &lt;/html&gt;<br></br>   Для максимальной гибкости имеется возможность создавать внешние таблицы стилей. Если код таблицы стилей находится во внешнем файле, то вы имеете возможность использовать его во всех страницах сайта. Представьте, что ваш сайт насчитывает более 1000 страниц. Если вы захотите внести какие-то изменения, то вам придется изменять код на каждой странице. Используя внешние таблицы стилей, вы лишь один раз внесете изменения в CSS-файл таблицы стилей.<br></br>   Для соединения HTML-документа с внешней таблицей стиля используется элемент LINK, который, как и элемент STYLE, рассмотренный выше, должен располагаться в заголовке документа внутри элемента HEAD. Код страницы со ссылкой на внешний файл таблицы стилей представлен в листинге 7.3.<br></br><h5 class="subtitle"><b>Листинг 7.3.</b> Таблица стилей во внешнем файле</h5>   &lt;html&gt;<br></br>   &lt;head&gt;<br></br>   &lt;title&gt;Моя домашняя страница&lt;/title&gt;<br></br>   &lt;link rel="stylesheet" href="my_style.css" type="text/css"&gt;<br></br>   &lt;/head&gt;<br></br>   &lt;body&gt;<br></br>   &lt;h1&gt;Моя домашняя страница&lt;/h1&gt;<br></br>   &lt;p&gt;На этой странице вы найдете информацию обо мне и моих друзьях.<br></br>   &lt;/body&gt;<br></br>   &lt;/html&gt;<br></br>   Как вы заметили, элемент LINK имеет несколько атрибутов. Рассмотрим их названия и подробное описание:<br></br>   • rel – тип соединения, который для таблиц стилей задается как stylesheet;<br></br>   • href – местонахождение таблицы стилей, то есть адрес и имя файла. В нашем примере в листинге 7.3 это my_style.css;<br></br>   • type – тип присоединяемой таблицы стилей. Поскольку элемент LINK может использоваться для присоединения и других файлов в HTML-документ, то желательно указать тип присоединяемого файла. Для таблиц стиля это значение text/css.<br></br>   Чтобы показать тесную связь между таблицей стилей и структурной разметкой документа, добавим в наш пример больше цветов (листинг 7.4), используя элемент STYLE.<br></br><h5 class="subtitle"><b>Листинг 7.4.</b> Оформление документа</h5>   &lt;html&gt;<br></br>   &lt;head&gt;<br></br>   &lt;title&gt;Моя домашняя страница&lt;/title&gt;<br></br>   &lt;style type="text/css"&gt;<br></br>   body { color: red }<br></br>   h1 { color: blue }<br></br>   &lt;/style&gt;<br></br>   &lt;/head&gt;<br></br>   &lt;body&gt;<br></br>   &lt;h1&gt;Моя домашняя страница&lt;/h1&gt;<br></br>   &lt;p&gt;На этой странице вы найдете информацию обо мне и моих друзьях.<br></br>   &lt;/body&gt;<br></br>   &lt;/html&gt;<br></br>   Таблица стилей теперь содержит два правила: первое предопределяет отображение элементов основного текста красным цветом red, в то время как второе – отображение текста, находящегося внутри элемента H1, синим цветом blue. Поскольку для элемента P значение цвета не было задано, то он унаследует цвет от родительского элемента, а именно от основного текста: элемента BODY. Элемент H1 также является дочерним элементом основного текста, но второе правило переопределяет унаследованное им значение.<br></br>   В CSS существует более 100 различных свойств, одним из которых и является свойство color. Рассмотрим некоторые другие свойства на примере из листинга 7.5.<br></br><h5 class="subtitle"><b>Листинг 7.5.</b> Различные свойства CSS</h5>   &lt;html&gt;<br></br>   &lt;head&gt;<br></br>   &lt;title&gt;Моя домашняя страница&lt;/title&gt;<br></br>   &lt;style type="text/css"&gt;<br></br>   body {<br></br>   font-family: "Some Type", sans-serif;<br></br>   font-size: 12pt;<br></br>   margin: 3em;<br></br>   }<br></br>   &lt;/style&gt;<br></br>   &lt;/head&gt;<br></br>   &lt;body&gt;<br></br>   &lt;h1&gt;Моя домашняя страница&lt;/h1&gt;<br></br>   &lt;p&gt;На этой странице вы найдете информацию обо мне и моих друзьях.<br></br>   &lt;/body&gt;<br></br>   &lt;/html&gt;<br></br>   Первой бросается в глаза группа строк, разделенных точкой с запятой и заключенных в фигурные скобки {}. За последней строкой в этой группе можно не ставить точку с запятой, это никак не повлияет на отображение документа.<br></br>   Разберем каждую строку отдельно.<br></br>   • Первая строка для элемента BODY устанавливает семейство шрифтов Some Type. Если этот тип шрифтов недоступен, то браузер будет использовать шрифт SansSerif, который является одним из пяти шрифтов, распознаваемых всеми браузерами. Все дочерние элементы наследуют значение font-fami l y элемента BODY. В последующих главах мы подробно разберем работу со шрифтами.<br></br>   • Вторая строка устанавливает размер шрифта элемента BODY равным 12 пунктам. Далее мы подробно рассмотрим единицы измерения, которые могут использоваться в CSS, и их различия.<br></br>   • Третья строка задает размер полей вокруг документа, хотя в ней используется уже другая единица измерения: em.<br></br></div><h2 id="idm139732203514960">7.2. Синтаксис CSS
</h2><div style="text-align: justify" class="hsection2"><div style="text-align: justify" class="section3">   Теперь, когда вы имеете представление о том, как можно добавить таблицу стилей в HTML-документ, разберем синтаксис языка CSS.<br></br>
</div><h3 id="idm139732203516112">Ключевые слова
</h3><div style="text-align: justify" class="hsection3">   В CSS, как и в других языках программирования, есть ключевые слова. Помните, что в CSS они не должны заключаться в кавычки («…» или …). Так, например, red – это ключевое слово, а «red» – нет. Для большего понимания приведу еще примеры <b>недопустимого</b> написания:<br></br>   width: «auto»;<br></br>   background: "green";<br></br>   border: "none";<br></br>   Рассмотрим каждую строку отдельно. Итак, в первой строке ширина должна задаваться автоматически. Для автоматической задачи ширины нужно использовать ключевое слово auto без кавычек. Во второй строке используется ключевое слово green, которое означает название цвета «зеленый», а в третьей – ключевое слово none, означающее, что рамка не будет видна вообще. Как и в предыдущих строках, оно не должно заключаться в кавычки.<br></br></div><h3 id="idm139732203519312">Комментарии
</h3><div style="text-align: justify" class="hsection3">   Комментарии в CSS начинаются с символов /* и заканчиваются символами */. Они могут находиться в любом месте таблицы. Использование комментариев очень удобно. Впоследствии вам может понадобиться много времени, чтобы сообразить, за какую часть документа отвечает тот или иной CSS-код. В то же время наличие комментариев поможет быстро в этом разобраться.<br></br>   Приведем пример CSS-кода с комментарием:<br></br>   /* Цвет основного заголовка – синий */<br></br>   h1 { color: blue }<br></br>   Из записи в комментарии понятно, что делает данное CSS-правило.<br></br></div><h3 id="idm139732203522256">Правила@
</h3><div style="text-align: justify" class="hsection3">   Правила @ начинаются с ключевого слова @, непосредственно за которым следует идентификатор (например, @import, @page). Каждый из этих идентификаторов далее рассмотрим подробнее.<br></br>   Все же надо отметить, что браузер с поддержкой CSS будет игнорировать все правила @import, которые находятся внутри блока CSS либо не предшествуют ни одному набору правил. Лучше всего это понять из примера. Рассмотрим <b>неверную </b>таблицу стилей:<br></br>   @import «subs.css»;<br></br>   h1 { color: blue }<br></br>   @import "list.css";<br></br>   Второе правило @import недопустимо. Браузер полностью проигнорирует второе правило @ целиком. Иными словами, в реальности он отобразит HTML-документ, используя такую таблицу стилей:<br></br>   @import «subs.css»;<br></br>   h1 { color: blue }<br></br>   Приведем еще один пример <b>недопустимого</b> использования правила @:<br></br>   @import «subs.css»;<br></br>   @media print {<br></br>   @import "print-main.css";<br></br>   body { font-size: 10pt }<br></br>   }<br></br>   h1 {color: blue }<br></br>   В этом примере второе правило @import недопустимо, так как оно находится в пределах другого блока @media.<br></br>   В последующих разделах мы подробно разберем каждое правило @.<br></br></div></div><h2 id="idm139732203498320">7.3. Селекторы
</h2><div style="text-align: justify" class="hsection2"><div style="text-align: justify" class="section3">   Селектором в CSS для простоты понимания будем считать название элемента, для которого задаются свойства. Теперь рассмотрим, как можно задать одни и те же свойства разным элементам документа.<br></br>
</div><h3 id="idm139732203499472">Группировка
</h3><div style="text-align: justify" class="hsection3">   Для задания разным элементам документа одних и тех же свойств в CSS существует группировка. Селекторы, то есть элементы, можно сгруппировать в список, разделив запятыми.<br></br>   Приведу пример, в котором разным элементам задается одно и то же свойство:<br></br>   h1 { color: red }<br></br>   h2 { color: red }<br></br>   h3 { color: red }<br></br>   Вышеприведенный пример можно значительно упростить, используя правило группировки:<br></br>   h1, h2, h3 { color: red }<br></br>   Как отмечалось выше, при группировке селекторы разделяются запятыми.<br></br></div><h3 id="idm139732203503824">Селекторы потомков
</h3><div style="text-align: justify" class="hsection3">   Иногда необходимо задать свойства элементу, который располагается непосредственно внутри какого-то другого элемента, то есть является так называемым потомком. Селектор потомков состоит из двух и более селекторов, разделенных пробелом.<br></br>   Допустим, внутри HTML-документа есть такой код:<br></br>   &lt;h1&gt;Очень &lt;em&gt;важный&lt;/em&gt; заголовок&lt;/h1&gt;<br></br>   Теперь предположим, что мы хотим изменить свойства элемента H1 и слова важный внутри строки. Если мы используем CSS-код, описанный ниже, то повлияем на все элементы EM на странице, а этого делать не нужно:<br></br>   h1 { color: red }<br></br>   em { color: blue }<br></br>   Чтобы повлиять на свойства слова важный, которое в нашем примере находится внутри элемента EM, а тот, в свою очередь, внутри элемента H1, надо использовать следующий CSS-код:<br></br>   h1 em { color: blue }<br></br>   Обратите внимание, что в отличие от группировки при обращении к потомкам запятые не ставятся. Количество элементов, которые можно записать потомками, не ограничено. Например:<br></br>   body div p span { color: green }<br></br>   Если в документе встретится элемент SPAN, находящийся внутри элемента P, который, в свою очередь, находится внутри элемента DIV, то текст в элементе SPAN будет зеленым. В столь длинных описаниях элемент BODY можно опускать, так как все элементы находятся внутри него.<br></br>   Если при разработке таблицы стилей вы еще точно не знаете, какой элемент будет размещаться внутри какого, можете воспользоваться символом *. Учтите, что с обеих сторон этого символа обязательно должны находиться пробелы.<br></br>   Пример, представленный выше, можно переписать так:<br></br>   body * span { color: green }<br></br>   Нужно помнить, что текст будет зеленым, даже если элемент SPAN будет просто находиться внутри элемента DIV. Иными словами, звездочкой считается любой набор селекторов и их потомков.<br></br></div><h3 id="idm139732203814608">Сестринские селекторы
</h3><div style="text-align: justify" class="hsection3">   Сестринскими называют элементы, которые идут друг за другом. Предположим, есть абзац, который имеет параметр class, заданный как first. Тогда, если за ним следует еще какой-то абзац, размер вертикального пространства между ними можно уменьшить, используя такой код:<br></br>   p.first + p { margin-top: -5mm }<br></br>   Создайте простую страницу и поэкспериментируйте с данным свойством, и вы быстро освоите, что такое сестринские селекторы в CSS.<br></br></div><h3 id="idm139732203816656">Селекторы атрибутов
</h3><div style="text-align: justify" class="hsection3">   CSS позволяет создавать правила, сопоставляемые элементам с атрибутами, определенными в исходном коде HTML-документа. Селекторы атрибутов могут сопоставляться в следующих четырех случаях.<br></br>   • [att] – если для элемента установлен атрибут att независимо от значения этого атрибута.<br></br>   • [att=val] – когда значение атрибута att данного элемента в точности равно val.<br></br>   • [att~=val] – если значением атрибута att данного элемента является список слов, разделенных пробелами, одно из которых в точности равно val.<br></br>   • [att|=val] – когда значением атрибута att элемента является начинающийся со слова val список разделенных дефисом слов. Сопоставление всегда начинается с начала значения атрибута.<br></br>   Чтобы хорошо разобраться с данным свойством, рассмотрите ряд примеров и подробных комментариев к ним.<br></br>   Итак, следующее правило CSS сопоставляется всем элементам P, для которых описан атрибут align, независимо от его значения:<br></br>   p[align] { color: blue; }<br></br>   В следующем примере селектор, то есть правило CSS, сопоставляется всем элементам SPAN, у которых значение атрибута class в точности равно example:<br></br>   span[class=example] { color: blue; }<br></br>   Для обращения к нескольким атрибутам элемента или многократного обращения к одному и тому же атрибуту можно использовать несколько селекторов атрибутов. В следующем примере селектор сопоставляется всем элементам TABLE, у которых значение атрибута width в точности равно 90 %, а значение атрибута height в точности равно 50 %:<br></br>   table[width="90%"][height="50%"] { color: blue; }<br></br>   Следующие селекторы иллюстрируют различия между знаками = и ~=. Первый селектор будет сопоставляться, например, значению copyright copyleft copyall атрибута rel. Второй селектор будет сопоставляться только в том случае, если значение атрибута href равно <a href="http://www.yoursite.com/">http://www.yoursite.com/</a>:<br></br>   a[rel~="copyright"]<br></br>   a[href="http://www.yoursite.com/"]<br></br>   Следующее правило скрывает все элементы, атрибут lang которых имеет значение fr, то есть элементы с текстом на французском языке:<br></br>   *[lang=fr] { display : none }<br></br>   Следующее правило будет сопоставляться тем значениям атрибута lang, которые начинаются с ru, включая ru, ru-RU и ru-UA:<br></br>   *[lang|="ru"] { color : red }<br></br></div><h3 id="idm139732203826512">Селекторы классов
</h3><div style="text-align: justify" class="hsection3">   В таблицах стилей, используемых с HTML-документами, при сопоставлении атрибуту class вы можете использовать точку (.) как альтернативу условному обозначению ~=. Таким образом, два выражения HTML DIV. value и DIV [class ~=value] имеют одинаковый смысл. Значение атрибута должно находиться непосредственно после точки (.).<br></br>   Например, для всех элементов с class~=test информацию о стиле можно определить следующим образом:<br></br>   *.test { color: red } /* все элементы с class~=test */<br></br>   или просто<br></br>   .test { color: red } /* все элементы с class~=test */<br></br>   Рассмотрим еще один пример. Следующее правило назначает стиль только элементу H1с class~=test:<br></br>   h1.test { color: green } /* элемент H1 с class~=test */<br></br>   Благодаря этому правилу в следующем примере при первом появлении элемент H1 не будет отображаться красным цветом, а при втором – будет:<br></br>   &lt;h1&gt;Не зеленый цвет&lt;/h1&gt;<br></br>   &lt;h1 class="test"&gt;Настоящий зеленый цвет&lt;/h1&gt;<br></br>   Для сопоставления подмножеству значений атрибута class перед каждым из них, записанных в произвольном порядке, следует поставить точку (.).<br></br>   Например, следующее правило сопоставляется любому элементу P, атрибуту class которого в качестве значения назначен список разделенных пробелами значений, включающий слова test и marine:<br></br>   p.test.marine { color: green }<br></br>   Это правило сопоставляется, если, например, для элемента P задано class = «Test blue aqua marine», и не сопоставляется, если задано class = «test blue».<br></br></div><h3 id="idm139732203784784">ID-селекторы
</h3><div style="text-align: justify" class="hsection3">   Атрибут ID языка документа позволяет назначать идентификатор одному экземпляру элемента в дереве HTML-документа. В CSS ID-селекторы сопоставляются экземпляру элемента в зависимости от его идентификатора. В CSS ID-селектор содержит символ #, непосредственно за которым следует значение атрибута ID.<br></br>   Например, следующий ID-селектор сопоставляется элементу H1, значение атрибута ID которого равно chapter7:<br></br>   h1#chapter7 { text-align: center }<br></br>   В листинге 7.6 правило стиля сопоставляется элементу, у которого значение атрибута ID равно z98y. Иначе говоря, это правило будет сопоставляться элементу P.<br></br><h5 class="subtitle"><b>Листинг 7.6.</b> ID-селекторы</h5>   &lt;head&gt;<br></br>   &lt;title&gt;Глава 7&lt;/title&gt;<br></br>   &lt;style type="text/css"&gt;<br></br>   *#z98y { letter-spacing: 0.3em }<br></br>   &lt;/style&gt;<br></br>   &lt;/head&gt;<br></br>   &lt;body&gt;<br></br>   &lt;p id=z98y&gt;Текст абзаца&lt;/p&gt;<br></br>   &lt;/body&gt;<br></br>   Однако в примере из листинга 7.7 это правило стиля будет сопоставляться только элементу H1, значение атрибута ID которого равно z98y. В этом примере данное правило не сопоставляется элементу P.<br></br><h5 class="subtitle"><b>Листинг 7.7.</b> ID-селекторы</h5>   &lt;head&gt;<br></br>   &lt;title&gt;Глава 7&lt;/TITLE&gt;<br></br>   &lt;style type="text/css"&gt;<br></br>   h1#z98y { letter-spacing: 0.5em }<br></br>   &lt;/style&gt;<br></br>   &lt;/head&gt;<br></br>   &lt;body&gt;<br></br>   &lt;p id=z98y&gt;Текст абзаца&lt;/p&gt;<br></br>   &lt;/body&gt;<br></br>   Надо отметить, что ID-селекторы имеют более высокий приоритет, чем селекторы атрибутов. Например, в HTML-документе селектор #p123 более специфичен, чем [ID=p123].<br></br></div></div><h2 id="idm139732203763408">7.4. Псевдоэлементы и псевдоклассы
</h2><div style="text-align: justify" class="hsection2"><div style="text-align: justify" class="section3">   В языке CSS стиль обычно прикрепляется к элементу в зависимости от его местонахождения в дереве HTML-документа. В большинстве случаев эта простая модель оказывается приемлемой, но все же иногда из-за структуры дерева документа она не позволяет реализовать некоторые желаемые результаты. Например, в HTML нет элемента, который бы указывал на первую строку абзаца, и поэтому нет простого селектора CSS, который бы мог указывать на нее.<br></br>
   В CSS вводится представление о псевдоэлементах и псевдоклассах, позволяющих осуществлять форматирование на основании информации, не включенной в дерево HTML-документа.<br></br>
   Сразу отмечу, что имена псевдоклассов и псевдоэлементов учитывают регистр.<br></br>
   Начнем изучение с псевдокласса: first-child.<br></br>
</div><h3 id="idm139732203765840">Псевдокласс :first-child
</h3><div style="text-align: justify" class="hsection3">   Псевдокласс: first-child сопоставляется элементу, который является первым дочерним элементом другого элемента.<br></br>   Со слов это тяжело понять, поэтому рассмотрите примеры, представленные в данном разделе, и вам все станет ясно.<br></br>   В следующем примере селектор сопоставляется каждому элементу P, который является первым дочерним по отношению к элементу DIV. Проще говоря, это правило запрещает отступ для первого абзаца элемента DIV:<br></br>   div &gt; p:first-child { text-indent: 0 }<br></br>   Данный селектор сопоставляется элементу P внутри DIV в следующем фрагменте:<br></br>   &lt;p&gt;Последний P перед примечанием.<br></br>   &lt;div class="note"&gt;<br></br>   &lt;p&gt;Первый P внутри примечания.<br></br>   &lt;/div&gt;<br></br>   Он не сопоставляется элементу P в следующем фрагменте, так как он второй, а первый дочерний элемент DIV теперь – H2:<br></br>   &lt;p&gt;Последний P перед примечанием.<br></br>   &lt;div class="note"&gt;<br></br>   &lt;h2&gt;Примечание&lt;/H2&gt;<br></br>   &lt;p&gt;Первый P внутри примечания.<br></br>   &lt;/div&gt;<br></br>   В следующем примере устанавливается ширина шрифта bold для каждого элемента EM, являющегося одним из потомков первого дочернего элемента P:<br></br>   p:first-child em { font-weight : bold }<br></br>   Обратите внимание, что, поскольку безымянные блоки не являются частью дерева документа, они не учитываются во время определения первого дочернего элемента. Например, EM в этом примере является первым дочерним элементом по отношению к P:<br></br>   &lt;p&gt;Это &lt;em&gt;полужирный&lt;/em&gt; текст.&lt;/p&gt;<br></br>   Чтобы лучше разобраться, создайте простую страницу и поэкспериментируйте с ее стилем, используя псевдоклассы. Например, изменяя размер шрифта следующим правилом:<br></br>   font-weight : bold<br></br></div><h3 id="idm139732203776208">Псевдоклассы ссылок
</h3><div style="text-align: justify" class="hsection3">   Обычно браузеры пользователей по-разному отображают просмотренные и непросмотренные ссылки. В CSS предусмотрены псевдоклассы: link и: visited для различения этих типов ссылок и задания им своего стиля:<br></br>   •:link – применяется, если ссылка не была просмотрена;<br></br>   •:visited – используется, если ссылка была просмотрена посетителем.<br></br>   Язык HTML определяет элементы, которые служат точками привязки гиперссылки. В HTML 4 псевдоклассы ссылок применяются к элементам A с атрибутом href. Таким образом, следующие два объявления CSS эквивалентны:<br></br>   a:link { color: red }<br></br>   :link { color: red }<br></br>   Если ссылка &lt;a class="external" href=http://yoursite.com/&gt;перейти&lt;/a&gt; была просмотрена, то согласно правилу a.external:visited { color: blue } она будет представляться синим цветом.<br></br></div><h3 id="idm139732203730768">Динамические псевдоклассы
</h3><div style="text-align: justify" class="hsection3">   Иногда браузеры пользователей изменяют вид элементов HTML-документа после выполнения пользователем некоторых действий. В CSS предусмотрены три псевдокласса для наиболее часто встречающихся действий.<br></br>   •:hover – применяется, когда пользователь с помощью некоторого указывающего устройства (как правило, мыши) выделяет элемент, но не активизирует его. Например, браузер пользователя может применять этот псевдокласс, когда указатель мыши находится поверх поля, генерируемого данным элементом.<br></br>   •:active – используется, когда элемент активизируется посетителем. Например, между моментами, когда он нажимает кнопку мыши и отпускает ее.<br></br>   •:focus – применяется, когда элемент находится в центре некоторых событий. Например, обрабатывает события клавиатуры или другие типы ввода текста.<br></br>   Надо отметить, что эти псевдоклассы не являются взаимоисключающими. Элемент может сопоставляться одновременно нескольким псевдоклассам. Например:<br></br>   a:link { color: red } /* непросмотренные ссылки */<br></br>   a:visited { color: blue } /* просмотренные ссылки */<br></br>   a:hover { color: yellow } /* ссылка, над которой в данный момент находится указатель */<br></br>   a:active { color: white } /* активные ссылки */<br></br>   Обратите внимание, что правило a: hover должно располагаться после правил a: link и a: visited, так как в противном случае правила каскадирования скроют свойство color правила a: hover. Аналогичным образом благодаря тому, что a: active находится после a: hover, активная ссылка отображается белым цветом, когда пользователь устанавливает указатель поверх элемента А и одновременно активизирует его.<br></br>   Рассмотрим пример сочетания динамических псевдоклассов:<br></br>   a:focus { background: yellow }<br></br>   a:focus:hover { background: white }<br></br>   Во второй строке правило CSS сопоставляется элементам A, которые находятся в псевдоклассах focus и: hover.<br></br></div><h3 id="idm139732203737424">Псевдокласс :lang
</h3><div style="text-align: justify" class="hsection3">   Если в языке HTML-документа определен разговорный язык элемента, то CSS позволяет создавать селекторы, сопоставляемые элементу, использующему данный разговорный язык. Например, в HTML язык определяется сочетанием атрибута lang, элемента META и, возможно, информацией из протокола (такой, как заголовки HTTP).<br></br>   Псевдокласс: lang (ru) сопоставляется элементу, использующему язык ru. Здесь ru – код языка. Он сопоставляется аналогично оператору |=. Приведу для примера несколько языков и коды:<br></br>   • ru – русский;<br></br>   • en – английский;<br></br>   • fr – французский;<br></br>   • de – немецкий;<br></br>   • jp – японский.<br></br>   Например, следующие правила расставляют кавычки в HTML-документе, написанном на французском либо немецком языке:<br></br>   html:lang(fr) { quotes: " " }<br></br>   html:lang(de) { quotes: " " \2039 \203A }<br></br>   :lang(fr) &gt; Q { quotes: " " }<br></br>   :lang(de) &gt; Q { quotes: " " \2039 \203A }<br></br>   Вторая пара правил фактически задает свойство quotes для элементов Q в соответствии с языком их родительских элементов. Это сделано потому, что выбор кавычек обычно зависит от языка элементов вокруг кавычек, а не от самих кавычек, как это имеет место во фрагменте французского текста «а limproviste», расположенного в английском тексте и использующего английские кавычки.<br></br></div><h3 id="idm139732203743312">Псевдоэлемент first-line
</h3><div style="text-align: justify" class="hsection3">   Псевдоэлемент: first-line используется для применения стилей к первой строке абзаца. Например:<br></br>   p:first-line { text-transform: uppercase }<br></br>   Представленное выше правило указывает сделать буквы первой строки каждого абзаца заглавными. Однако селектор p: first-line не соответствует ни одному реальному HTML-элементу. Он сопоставляется псевдоэлементу, который браузеры пользователей будут помещать в начало каждого абзаца.<br></br>   Обратите внимание, что длина первой строки зависит от множества таких факторов, как ширина страницы, размер шрифта и др.<br></br>   Типичный абзац HTML-документа, как этот:<br></br>   &lt;p&gt;Это довольно длинный абзац<br></br>   HTML-документа, который будет разбит на несколько строк. Первая строка будет отмечена последовательностью функциональных тегов. Другие строки будут обрабатываться как обычные строки абзаца.&lt;/P&gt;<br></br>   претерпит следующую реорганизацию строк:<br></br>   !!!<br></br>   ЭТО ДОВОЛЬНО ДЛИННЫЙ АБЗАЦ HTML-ДОКУМЕНТА,<br></br>   который будет разбит на несколько строк.<br></br>   Первая строка будет отмечена последовательностью<br></br>   функциональных тегов. Другие строки<br></br>   будут обрабатываться как обычные строки абзаца.<br></br>   Он будет «переписан» браузерами пользователей так, чтобы включить последовательность функциональных тегов для: first-line. Эта фиктивная последовательность помогает показать, как наследуются свойства:<br></br>   &lt;p&gt;&lt;p:first-line&gt; Это довольно длинный абзац HTML-документа,<br></br>   &lt;/p:first-line&gt; который будет разбит на несколько строк.<br></br>   Первая строка будет отмечена последовательностью функциональных тегов. Другие строки будут обрабатываться как обычные строки абзаца. &lt;/p&gt;<br></br>   Если псевдоэлемент разрывает реальный элемент, то желаемый эффект зачастую может быть достигнут с помощью последовательности функциональных тегов, которая закрывает и повторно открывает этот элемент. Таким образом, если вы используете в предыдущем абзаце элемент SPAN, то получите следующее:<br></br>   &lt;p&gt;&lt;span class="test"&gt; Это довольно длинный абзац HTML-документа, который будет разбит на несколько строк.&lt;/span&gt; Первая строка будет отмечена<br></br>   последовательностью функциональных тегов. Другие строки будут обрабатываться как обычные строки абзаца.&lt;/p&gt;<br></br>   Теперь браузер пользователя сможет сгенерировать соответствующие начальные и конечные теги для SPAN во время вставки последовательности функциональных тегов для: first-line. Получится следующее:<br></br>   &lt;p&gt;&lt;p:first-line&gt;&lt;SPAN class="test"&gt; Это<br></br>   довольно длинный абзац HTML-документа, &lt;/span&gt;&lt;/p:first-line&gt;&lt;span class="test"&gt; который будет разбит на несколько строк. &lt;/span&gt; Первая строка будет отмечена последовательностью функциональных тегов. Другие строки будут обрабатываться как обычные строки абзаца.&lt;/p&gt;<br></br>   Псевдоэлемент: first-line может прикрепляться только к элементам уровня блока. Он подобен строковому элементу, но с некоторыми ограничениями. К псевдоэлементу: first-line применяются следующие свойства: свойства шрифтов, цветов, фона, word-spacing, letter-spacing, text-decoration, vertical-align, text-transform, line-height, text-shadow и clear.<br></br></div><h3 id="idm139732192679504">Псевдоэлемент first-letter
</h3><div style="text-align: justify" class="hsection3">   Псевдоэлемент: first-letter может использоваться для создания таких простых типографических эффектов, как заглавные буквы и буквицы. Тип начальной буквы аналогичен строковому элементу, если его свойству float присвоено значение none, в противном случае он аналогичен перемещаемому объекту.<br></br>   К псевдоэлементам: first-letter применяются следующие свойства: свойства шрифтов, цветов, фона, text-decoration, vertical-align (если для свойства float установлено значение none), text-transform, line-height, свойства полей, полей в ячейке таблицы, рамок, float, text-shadow и clear.<br></br>   В следующем примере из листинга 7.8 высота буквицы устанавливается равной высоте двух строк.<br></br><h5 class="subtitle"><b>Листинг 7.8.</b> Стиль заглавной буквы</h5>   &lt;!DOCTYPE HTML PUBLIC «-//W3C//DTD HTML 4.0//EN»&gt;<br></br>   &lt;html&gt;<br></br>   &lt;head&gt;<br></br>   &lt;title&gt;Глава 7. Стиль заглавной буквы&lt;/title&gt;<br></br>   &lt;style type="text/css"&gt;<br></br>   p { font-size: 12pt; line-height: 12pt }<br></br>   p:first-letter { font-size: 200%; font-style: italic;<br></br>   font-weight: bold; float: left }<br></br>   span { text-transform: uppercase }<br></br>   &lt;/style&gt;<br></br>   &lt;/head&gt;<br></br>   &lt;body&gt;<br></br>   &lt;p&gt;&lt;span&gt;Первые&lt;/span&gt; несколько слов из книги<br></br>   "Самоучитель по HTML и CSS".&lt;/p&gt;<br></br>   &lt;/body&gt;<br></br>   &lt;/html&gt;<br></br>   Пример из листинга 7.8 может быть отформатирован, как показано на рис. 7.1.<br></br><div class="wrap_pict"><div style="text-align: center;"><img src="i_089.png" alt=""></img></div>   <b>Рис. 7.1.</b> Стиль заглавной буквы<br></br></div><br></br>   Приведу последовательность функциональных тегов:<br></br><br></br>   &lt;p&gt;<br></br>   &lt;span&gt;<br></br>   &lt;p:first-letter&gt;<br></br>   П<br></br>   &lt;/p:first-letter&gt;ервые<br></br>   &lt;/span&gt;<br></br>   несколько слов из статьи в журнале "Экономист".<br></br>   &lt;/p&gt;<br></br><br></br>   Обратите внимание, что теги псевдоэлементов: first-letter примыкают к содержимому (например, к начальному символу), а открывающий тег псевдоэлемента: first-line вставляется сразу после открывающего тега элемента, к которому он прикрепляется.<br></br>   Учтите, что в некоторых языках могут существовать специальные правила обращения с определенными сочетаниями букв. Например, в голландском языке, если сочетание букв «ij» находится в начале слова, то они обе находятся в псевдоэлементе: first-letter.<br></br>   В следующем примере показано, как могут повлиять друг на друга налагающиеся псевдоэлементы. Первая буква каждого элемента P выделяется зеленым цветом, а размер шрифта установлен 24 пункта. Остальные буквы первой форматируемой строки будут представлены синим цветом, а все оставшиеся буквы абзаца – красным. CSS-код примера будет выглядеть следующим образом:<br></br><br></br>   p { color: red; font-size: 12pt }<br></br>   p:first-letter { color: green; font-size: 200% }<br></br>   p:first-line { color: blue }<br></br><br></br>   Например, рассмотрим этот CSS код применительно к такому абзацу:<br></br><br></br>   &lt;p&gt;Некоторый текст, разделенный на две строки&lt;/p&gt;<br></br><br></br>   Допустим, что разрыв строки произойдет до слова «разделенный», тогда последовательность функциональных тегов для данного фрагмента может быть следующей:<br></br><br></br>   &lt;p&gt;<br></br>   &lt;p:first-line&gt;<br></br>   &lt;p:first-letter&gt;<br></br>   Не<br></br>   &lt;/p:first-letter&gt;который текст,<br></br>   &lt;/p:first-line&gt;<br></br>   разделенный на две строки<br></br>   &lt;/p&gt;<br></br><br></br>   Обратите внимание, что элемент: first-letter находится внутри элемента: first-line. Свойства, установленные для элемента: first-line, наследуются: first-letter, но могут быть переназначены, если в элементе: first-letter этому же свойству присваивается значение.<br></br></div><h3 id="idm139732192635600">Псевдоэлементы :before и: after
</h3><div style="text-align: justify" class="hsection3">   Псевдоэлементы: before и: after можно использовать для вставки генерируемого содержимого до или после содержимого элемента.<br></br>   h1:before {content: counter(chapno, upper-roman) ". "}<br></br>   Когда псевдоэлементы: first-letter и: first-line сочетаются с псевдоэлементами: before и: after, они применяются к первой букве или строке элемента, включая вставляемый текст.<br></br>   p.special:before {content: "Важно! "}<br></br>   p.special:first-letter {color: gold}<br></br>   Буква В слова Важно! будет представлена золотистым цветом.<br></br></div></div><h2 id="idm139732202715216">7.5. Правило @media
</h2><div style="text-align: justify" class="hsection2">   Правило @media позволяет задавать правила CSS для различных устройств в пределах одной таблицы стилей, разделенных запятыми. Иными словами, вы можете задать для одного и того же элемента один размер шрифта для печати, а другой для просмотра на экране.<br></br>   Например:<br></br>   @media print {<br></br>   body { font-size: 10pt }<br></br>   }<br></br>   @media screen {<br></br>   body { font-size: 12pt }<br></br>   }<br></br>   В примере при просмотре документа на экране размер шрифта будет 10 пунктов, а при печати 12 пунктов.<br></br>   Рассмотрим еще один пример:<br></br>   @media screen, print {<br></br>   body { font-size: 14pt }<br></br>   }<br></br>   В этом примере и при печати, и при просмотре размер шрифта будет одинаковый – 14 пунктов.<br></br>   Рассмотрим список всех устройств, поддерживаемых CSS. Значение указывает, что документ предназначен:<br></br>   • all – для всех устройств;<br></br>   • aural – речевых синтезаторов;<br></br>   • braille – устройств чтения азбуки Брайля;<br></br>   • embossed – печати азбуки Брайля;<br></br>   • handheld – переносимых портативных устройств (небольшие монохромные экраны с ограниченной полосой частот);<br></br>   • print – страничных непрозрачных материалов и для документов, просматриваемых на экране в режиме предварительного просмотра печати;<br></br>   • projection – настенных презентаций, например для проекторов или для печати плакатов;<br></br>   • screen – цветных дисплеев;<br></br>   • tty – устройств, использующих набор символов с фиксированной шириной, например телетайпов, терминалов или портативных устройств с ограниченными возможностями отображения; для устройств типа tty не следует использовать пикселы;<br></br>   • tv – устройств типа телевизора, для которых характерны низкое разрешение, цветное изображение, ограниченная прокрутка на экране и возможность передачи звука.<br></br>   Следует отметить, что названия типов устройств не зависят от регистра.<br></br>   Как правило, для схожих устройств задаются схожие правила CSS, поэтому все устройства в CSS разбиты по типам. В табл. 7.1 представлены взаимоотношения между группами и типами устройств.<br></br><h5 class="subtitle"><b>Таблица 7.1.</b> Группы устройств</h5><div style="text-align: center;"><img src="i_090.png" alt=""></img></div>   Значение both в таблице означает, что используются устройства всей группы.<br></br>   Приведу перевод названий типов устройств:<br></br>   • без разбивки – continuous;<br></br>   • с разбивкой – paged;<br></br>   • визуальные – visual;<br></br>   • звуковые – aural;<br></br>   • тактильные – tactile;<br></br>   • сеточные – grid;<br></br>   • растровые – bitmap;<br></br>   • интерактивные – interactive;<br></br>   • статичные – static.<br></br>   Попробуйте в качестве эксперимента создать простую страницу с различными свойствами и значениями для устройств screen и print и посмотреть ее на экране и в окне предварительного просмотра.<br></br></div><h2 id="idm139732202699344">7.6. Правила !important
</h2><div style="text-align: justify" class="hsection2">   В CSS предпринята попытка установить баланс между возможностями таблиц стилей разработчика и пользователя. По умолчанию правила в таблице стилей разработчика имеют приоритет над правилами пользовательской таблицы стилей.<br></br>   Однако для соблюдения баланса объявление!important наделяется преимуществом перед обычным объявлением. Таблицы стилей как разработчика, так и пользователя могут содержать объявления!important, но пользовательские правила!important имеют приоритет над правилами!important разработчика. Эта особенность CSS улучшает возможность доступа к документам, предоставляя пользователям со специальными требованиями (большие размеры шрифтов, сочетания цветов и т. д.) более гибкий контроль над представлением.<br></br>   Надо отметить, что объявление свойства стенографического типа (например, background) как !important равнозначно объявлению всех содержащихся в нем свойств как !important.<br></br>   В следующем примере первое правило пользовательской таблицы стилей содержит объявление!important, которое имеет приоритет над соответствующим объявлением в таблице стилей разработчика. Второе объявление также имеет больший приоритет, так как оно помечено !important. Однако третье правило в пользовательской таблице стилей не является правилом!important, и поэтому более высокий приоритет будет иметь второе правило в таблице стилей разработчика (которое устанавливает стиль в свойстве стенографического типа). Кроме того, третье правило разработчика имеет меньший приоритет, чем второе, так как последнее является!important. Это говорит о том, что объявления!important работают и в таблицах стилей разработчика.<br></br>   /* Из пользовательской таблицы стилей */<br></br>   p { text-indent: 1em ! important }<br></br>   p { font-style: italic ! important }<br></br>   p { font-size: 18pt }<br></br>   /* Из таблицы стилей разработчика */<br></br>   p { text-indent: 1.5em !important }<br></br>   p { font: 12pt sans-serif !important }<br></br>   p { font-size: 24pt }<br></br></div><h2 id="idm139732202704976">7.7. Правило @import
</h2><div style="text-align: justify" class="hsection2">   Правило @import позволяет импортировать правила стилей из других таблиц стилей. Массив правил @import должен предшествовать всем другим правилам в таблице стилей. После ключевого слова @import должен следовать URL-адрес таблицы стилей, которую необходимо импортировать. Допускается использование строки. В этом случае подразумевается, что она заключена в url(…).<br></br>   Следующие строки эквивалентны по значению и представляют два варианта синтаксиса правила @import (один с использованием url(…) и один с открытой строкой):<br></br>   @import «mystyle.css»;<br></br>   @import url("mystyle.css");<br></br>   Вы также можете задать правила @import, зависящие от устройств. Тогда в этих правилах импортирования после URL задается список типов устройств, разделенных запятыми.<br></br>   Действие приведенных ниже правил происходит так, как если бы импортируемая таблица стилей при прочих равных условиях присоединялась посредством правила @media, с той лишь разницей, что они позволяют пользовательскому агенту не выполнять бесполезную загрузку.<br></br>   @import url(«fineprint.css») print;<br></br>   @import url("bluish.css") projection, tv;<br></br>   При отсутствии каких-либо типов устройств импорт не зависит ни от каких условий. Если при этом использовать значение all для импортируемых аппаратных средств, то будет достигнут аналогичный эффект.<br></br></div><h2 id="idm139732202709584">Резюме
</h2><div style="text-align: justify" class="hsection2">   В данной главе мы разобрали основные понятия языка CSS. В последующих главах мы разберем все остальные свойства CSS. А пока, если вы внимательно читали, с уверенностью можно сказать, что, открыв любую таблицу стилей, вы с легкостью в ней разберетесь.<br></br></div></div><h1 xmlns="http://www.w3.org/1999/xhtml" id="idm139732202710608" class="master">Глава 8<br></br>
Форматирование текста средствами CSS
</h1><div xmlns="http://www.w3.org/1999/xhtml" style="text-align: justify" class="hsection1"><div style="text-align: justify" class="section2">   8.1. Выделение текста цветом<br></br>
   8.2. Шрифты<br></br>
   8.3. Форматирование текста<br></br>
   В этой главе мы разберем основные приемы работы с текстом средствами CSS. Форматирование и установка стиля, выбор шрифта и задание цвета – все это с легкостью решается средствами CSS.<br></br>
   Изначально язык CSS был разработан для управления видом текста, поэтому он предоставляет веб-разработчику впечатляющие средства по работе с текстом. Как правило, обычного набора элементов HTML недостаточно, чтобы оформить текст на странице. Здесь на помощь и приходит CSS.<br></br>
   Чтобы понять всю мощь CSS по работе с текстом и в то же время освоить основные приемы создания таблиц стилей, создадим простую HTML-страницу, которая и будет служить примером (листинг 8.1, рис. 8.1).<br></br>
<h5 class="subtitle"><b>Листинг 8.1.</b> Тестовая HTML-страница</h5>   &lt;html&gt;<br></br>
   &lt;head&gt;<br></br>
   &lt;title&gt;Глава 8. Форматирование текста средствами CSS&lt;/title&gt;<br></br>
   &lt;link href="my_style.css" rel="stylesheet"&gt;<br></br>
   &lt;/link&gt;<br></br>
   &lt;/head&gt;<br></br>
   &lt;body&gt;<br></br>
   &lt;h1&gt;Форматирование текста средствами CSS&lt;/h1&gt;<br></br>
   &lt;p class="namek"&gt;Намек: добивается успеха только тот, кто старается.&lt;/p&gt;<br></br>
   &lt;h2&gt;Предисловие&lt;/h2&gt;<br></br>
   &lt;p&gt;В CSS нет ничего сложного, к концу данной главы вы научитесь изменять<br></br>
   цвет текста, шрифт, размер. Научитесь управлять его положением на<br></br>
   странице и выучите еще много других приемов форматирования,<br></br>
   которые сделают вас настоящим профессионалом веб-дизайна.&lt;/p&gt;<br></br>
   &lt;p&gt;Вам будет под силу отформатировать любой текст. И вы сделаете это<br></br>
   так же просто, как в обычном текстовом редакторе.<br></br>
   Вы сможете заставить читать посетителя по буквам.&lt;/p&gt;<br></br>
   &lt;p class="w_600"&gt;К примеру, задать "жирность" в 600 для данного абзаца<br></br>
   средствами HTML просто невозможно.<br></br>
   Так же, как и &lt;span class="bg_test"&gt;выделить&lt;/span&gt; данный текст.&lt;/p&gt;<br></br>
   &lt;p&gt;Если из примера вам все понятно, то вы можете сразу перепрыгнуть<br></br>
   далее к &lt;a href="#"&gt;главе 9.&lt;/a&gt;&lt;/p&gt;<br></br>
   &lt;/body&gt;<br></br>
   &lt;/html&gt;<br></br>
<div class="wrap_pict"><div style="text-align: center;"><img src="i_091.png" alt=""></img></div>   <b>Рис. 8.1.</b> Тестовая HTML-страница<br></br>
</div><br></br>   Страница, которую вы создадите, используя код листинга 8.1, может незначительно отличаться от приведенной в книге. К примеру, у вас может быть другой шрифт. По ходу изучения главы мы отформатируем страницу так, чтобы ваша тестовая страница и страницы из дальнейших примеров выглядели одинаково. Собственно, это и есть одна из самых сложных задач веб-дизайна.<br></br>
   После создания страницы первое, что бросается в глаза, – неудачно отформатированный текст. Точнее, он вообще не отформатирован. Постепенно мы будем совершенствовать наш CSS-код и к концу главы получим отформатированную страницу.<br></br>
   CSS-код можно добавлять в HTML-страницы двумя путями. Первый – вписать код таблицы стилей непосредственно в саму HTML-страницу. Второй, который мы и будем использовать в примере, – вынести содержание CSS во внешний файл таблицы стилей, а в HTML-странице оставить ссылку на него. В нашем примере файл таблицы стилей располагается во внешнем файле с именем my_style.css в той же папке, что и наша страница.<br></br>
   Следует добавить, что каждый раз дописывать новое свойство для одного и того же элемента, указывая его название, нерационально. К примеру, задать цвет текста красным и выровнять его по правому краю для абзацев можно, определив для элемента P такой CSS-код:<br></br>
<br></br>   p {<br></br>
   color: red;<br></br>
   text-align: right;<br></br>
   }<br></br>
<br></br>   Данный прием был подробно рассмотрен в подразд. «Группировка» разд. 7.3.<br></br>
   По ходу изучения главы вы будете встречаться с одиночными примерами. Однако в таблицу стилей можете дописывать свойства так же, как показано выше.<br></br>
   Сразу оговорюсь, что при работе со шрифтами надо учитывать, что выбранный вами шрифт должен быть установлен на компьютере клиента, иначе он увидит страницу в шрифте, который задан по умолчанию настройками его браузера. Про это подробно будет рассказано в разд. 8.2, посвященном выбору и заданию шрифтов.<br></br>
   Итак, приступим к изучению форматирования текста и начнем с рассмотрения работы с цветами.<br></br>
</div><h2 id="idm139732202680784">8.1. Выделение текста цветом
</h2><div style="text-align: justify" class="hsection2"><div style="text-align: justify" class="section3">   Выбор цветовой схемы страницы – одна из главных и сложных задач, которые стоят перед веб-дизайнером. Поэтому в последующих двух разделах разберемся со способами задания цвета в CSS, научимся менять цвет текста и выделять его.<br></br>
   Надо отметить, что все свойства CSS по работе с цветами наследуемы. Для понимания, что это такое, приведу следующий пример. Представьте, что мы задали красный цвет текста для элемента BODY. Как это сделать, мы разберем дальше, сейчас сконцентрируйтесь только на «наследовании». Представьте, что весь текст на странице стал красным. Если теперь мы зададим синий цвет для таблиц с именем класса blue_text, то весь текст во всех таблицах с классом blue_text будет синим. Если же мы зададим красный цвет для элементов P, а синий – для BODY, то цвет текста в таблицах останется синим, так как в таблицах мы редко используем элемент абзаца P. Если же внутри какой-то ячейки мы используем элемент P, то цвет текста в этой ячейке, то есть внутри элемента P, будет красным. Если из этого текстового примера вам еще что-то непонятно, не расстраивайтесь, по ходу главы мы разберем все подробнее.<br></br>
</div><h3 id="idm139732168431568">Цвет текста
</h3><div style="text-align: justify" class="hsection3">   Для изменения цвета текста используется свойство color, в качестве параметра которого задается значение или название цвета. Сделаем для примера все заголовки первого уровня тестовой страницы красными. Заголовки первого уровня в HTML обозначаются элементом H1, поэтому добавим в файл my_style.css такой код:<br></br>   h1 {<br></br>   color: red;<br></br>   }<br></br>   Значение цвета можно задать тремя способами.<br></br>   1. Вы можете использовать название цвета, как в примере выше. Например, если вы захотите изменить цвет заголовков в примере на синий. Тогда вместо указанного названия цвета red используйте blue.<br></br>   2. Цвет может быть задан и с помощью шестнадцатеричного значения, например #ff0000. Вы можете поменять в нашем примере red на #ff0000, но вид страницы от этого не изменится.<br></br>   3. Допускается задание цвета с помощью RGB-значения: rgb(255, 0, 0). Оно также задаст тексту красный цвет.<br></br>   Свойство color тоже полезно использовать для задания цвета ссылкам в документе. Если ваша страница представляет, например, некую статью и вы решили оставить цвет текста черным, то ссылки можно сделать синими или серыми, тогда они не будут сильно бросаться в глаза и в то же время будут выделяться в основном тексте. Задание свойств для ссылок ничем не отличается от задания свойств для основного текста, только надо знать, что в CSS выделяют четыре типа ссылок:<br></br>   • link – все ссылки на странице, которые пользователь еще не посетил;<br></br>   • visited – все ссылки на странице, которые пользователь посетил;<br></br>   • active – все активные ссылки;<br></br>   • hover – ссылка, над которой находится указатель мыши.<br></br>   Чтобы задать тип ссылки, к которому вы хотите применить свойства форматирования, укажите без пробелов символ: и название типа ссылки. Например, чтобы цвет ссылки на странице менялся на серый, когда пользователь наводит на нее указатель мыши, используем следующий код:<br></br>   a:hover {<br></br>   color: grey;<br></br>   }<br></br>   Добавим данный код в нашу таблицу стилей. Результат всех изменений, сделанных в этом разделе, изображен на рис. 8.2.<br></br><div class="wrap_pict"><div style="text-align: center;"><img src="i_092.png" alt=""></img></div>   <b>Рис. 8.2.</b> Задание цвета<br></br></div><br></br>   Поэкспериментируйте с заданием цвета другими способами и другим элементам документа, и вы быстро освоите данный прием форматирования.<br></br></div><h3 id="idm139732168441296">Цвет фона
</h3><div style="text-align: justify" class="hsection3">   Цвет фона задается с помощью свойства background-color. Его можно использовать, чтобы сделать в документе текст, похожий на выделенный маркером. Значение цвета задается, как и в предыдущей главе, одним из трех способов: названием цвета, шестнадцатеричным значением или RGB-значением.<br></br>   Теперь поработаем с тестовой страницей. Для примера выделим заголовки первого уровня, то есть элементы H1, синим цветом. Для этого, как и в предыдущей главе, добавим в файл таблицы стилей такой код:<br></br>   h1 {<br></br>   background-color: blue;<br></br>   }<br></br>   Следует отметить, что если задать один и тот же цвет фона и текста, то текст просто-напросто сольется с фоном и не будет виден. Результат работы примера можно увидеть на рис. 8.3.<br></br><div class="wrap_pict"><div style="text-align: center;"><img src="i_093.png" alt=""></img></div>   <b>Рис. 8.3.</b> Выделение заголовка фоновым цветом<br></br></div><br></br>   Наверное, вы уже обратили внимание, что на рис. 8.3 цветом выделена вся строка. Это потому, что браузер отводит место под элемент H1 до конца строки. То же самое будет и с элементом P. Если вы хотите, чтобы был выделен только текст без пустого пространства справа, надо внутрь H1 вложить элемент SPAN и записать таблицу стилей следующим образом:<br></br><br></br>   h1 span {<br></br>   background-color: blue;<br></br>   }<br></br><br></br>   В этом случае стиль будет применяться только к последовательности элементов hi span.<br></br>   В элемент H1 включаем элемент SPAN:<br></br><br></br>   &lt;h1&gt;&lt;span&gt;Форматирование текста средствами CSS&lt;/span&gt;&lt;/h1&gt;<br></br><br></br>   В результате синим цветом будет выделена только строка заголовка.<br></br><br></br>   Теперь, когда вы научились работать с цветами, перейдем к следующему важному разделу, где вы научитесь придавать тексту нужный вид и размер.<br></br></div></div><h2 id="idm139732168416976">8.2. Шрифты
</h2><div style="text-align: justify" class="hsection2"><div style="text-align: justify" class="section3">   Шрифт – это лицо текста, поэтому для начала научимся задавать нашему тексту нужный шрифт. Двигаясь дальше, подробно рассмотрим все возможные варианты работы со шрифтом текста. Итак, начнем с семейства шрифта.<br></br>
</div><h3 id="idm139732168418128">Семейство шрифта
</h3><div style="text-align: justify" class="hsection3">   Свойство font-family указывает браузеру шрифт или список шрифтов, которыми должен отображаться текст. Не надо забывать, что заданный вами шрифт может быть не установлен на машине клиента. Тогда браузер отобразит текст на экране первым шрифтом, который найдет установленным при просмотре списка слева направо. Если не будет найден ни один из перечисленных шрифтов, то браузер клиента отобразит текст шрифтом по умолчанию. Вы также можете задать семейство шрифта.<br></br>   Семейство – это группа шрифтов, созданных с использованием сходных принципов дизайна и внешнего вида. В CSS есть пять основных групп: serif, sans-serif, monospace, fantasy, cursive.<br></br><blockquote><div>   <b>Примечание</b><br></br>
   После задания шрифтов последним в списке лучше указывать название семейства, к которому относится шрифт. Тогда, если не будет найден ни один из шрифтов, браузер отобразит текст шрифтом из заданного семейства, что позволит сохранить стиль оформления.<br></br>
</div></blockquote>   Для примера зададим шрифт текста абзацев Trebuchet MS и группу, к которой относится данный шрифт, sans-serif (рис. 8.4):<br></br>   p {<br></br>   font-family: "Trebuchet MS", sans-serif;<br></br>   }<br></br>   В примере, изображенном на рис. 8.4, показано окно браузера в системе, где установлен шрифт Trebuchet MS.<br></br><div class="wrap_pict"><div style="text-align: center;"><img src="i_094.png" alt=""></img></div>   <b>Рис. 8.4.</b> Установка шрифта<br></br></div><br></br><blockquote><div>   <b>Внимание!</b><br></br>
   Необходимо помнить, что если название шрифта содержит пробелы, то его необходимо заключить в кавычки.<br></br>
</div></blockquote>   Вы можете попробовать работать и с другими шрифтами и группами. Ниже приведены несколько групп и их основные шрифты, которые доступны для большинства пользователей с разными браузерами и операционными системами:<br></br>   • serif – Times New Roman, Garamond, Georgia;<br></br>   • sans-serif – Trebuchet, Arial, Verdana;<br></br>   • monospace – Courier, Courier New, Andale Mono.<br></br>   Старайтесь не использовать экзотических шрифтов, и тогда вы сможете быть уверенными, что страница у клиента будет отображена так, как вы задумали.<br></br></div><h3 id="idm139732168426704">Стиль шрифта
</h3><div style="text-align: justify" class="hsection3">   Стиль шрифта задается свойством font-style, которое может принимать одно из трех значений: normal, oblique или italic. Эти значения имеют следующий смысл.<br></br>   • normal – определяет шрифт, который классифицируется как Normal. При отображении на экране он выглядит как обычный текст.<br></br>   • oblique – задает шрифт, который классифицируется как Oblique. К нему, как правило, относятся шрифты со словами Oblique, Slanted или Incline в названиях. Такой текст может в действительности генерироваться электронным наклоном нормального шрифта.<br></br>   • italic – определяет шрифт, который классифицируется как Italic и, если это недоступно, шрифт, помеченный как Oblique. К Italic, как правило, относятся шрифты со словами Italic, Cursive или Kursiv в названиях.<br></br>   Для примера изменим стиль элементов P класса namek в нашем примере на курсив:<br></br>   p.namek {<br></br>   font-style: italic;<br></br>   }<br></br>   На рис. 8.5. видно что текст Намек: добивается успеха только тот, кто старается теперь записан курсивом.<br></br><div class="wrap_pict"><div style="text-align: center;"><img src="i_095.png" alt=""></img></div>   <b>Рис. 8.5.</b> Стиль шрифта<br></br></div><br></br>   Вы также можете сделать весь текст на странице курсивом, используя такой код:<br></br><br></br>   body {<br></br>   font-style: oblique;<br></br>   }<br></br></div><h3 id="idm139732168400976">Вид шрифта
</h3><div style="text-align: justify" class="hsection3">   Свойство font-variant может принимать одно из двух значений: normal или small-caps. Если задано значение small-caps, то текст будет выведен шрифтом из малых прописных букв. Если задано значение normal, то текст отображается, как обычно.<br></br>   Лучше всего это понятно на примере. Применим свойство small-caps для наших заголовков второго уровня:<br></br>   h2 {<br></br>   font-variant: small-caps;<br></br>   }<br></br>   Результат просмотра страницы браузером Internet Explorer 6 показан на рис. 8.6.<br></br><div class="wrap_pict"><div style="text-align: center;"><img src="i_096.png" alt=""></img></div>   <b>Рис. 8.6.</b> Вариант шрифта<br></br></div><br></br><blockquote><div>   <b>Примечание</b><br></br>
   Следует отметить, что если font-variant имеет значение small-caps, а шрифт недоступен, то браузер будет симулировать такой шрифт, например, замещением букв нижнего регистра обычного шрифта пересчитанными символами верхнего регистра. В крайнем случае весь текст будет воспроизведен буквами верхнего регистра.<br></br>
</div></blockquote></div><h3 id="idm139732168406352">Ширина шрифта
</h3><div style="text-align: justify" class="hsection3">   Свойство font-weight определяет ширину шрифта. Значение может быть задано числом от 100 до 900 (в сотнях), где каждый номер обозначает шрифт, который темнее своего предшественника. В других случаях значение может быть следующим.<br></br>   • normal – текст будет отображен обычным шрифтом. В числовом выражении соответствует значению 4 0 0.<br></br>   • bold – текст будет отображен более широким шрифтом, чем обычно. Численно оно равно значению 7 0 0.<br></br>   • bolder – определяет более темный вес шрифта, чем наследуемый. Если наследуемое значение равно 9 0 0, то результат будет также 9 0 0.<br></br>   • lighter – задает вес шрифта, который светлее, чем наследуемый. Если наследуемое значение равно 10 0, то результат будет также 10 0.<br></br>   Для примера установим значение свойства font-weight для класса w_600 элемента P, равное 600.<br></br>   p.w_600 {<br></br>   font-weight: 600;<br></br>   }<br></br>   Результат приведен на рис. 8.7.<br></br><div class="wrap_pict"><div style="text-align: center;"><img src="i_097.png" alt=""></img></div>   <b>Рис. 8.7.</b> Вес шрифта<br></br></div><br></br>   В качестве эксперимента вы можете попробовать задать элементу BODY значение свойства font-weight равным normal, а потом изменить его на 400. Вы увидите, что толщина шрифта основного текста в обоих случаях осталась одинаковой и вид текста на странице не изменился.<br></br></div><h3 id="idm139732168412496">Размер шрифта
</h3><div style="text-align: justify" class="hsection3">   Теперь изменим размер шрифта основного текста. Для этого существует свойство font-size. Размер шрифта задается с помощью значения и единицы измерения, выбранной в одной из двух разных групп: абсолютной и относительной.<br></br>   Абсолютные единицы:<br></br>   • in – дюйм, примерно равен 2,5 см;<br></br>   • mm – миллиметр;<br></br>   • cm – сантиметр;<br></br>   • pt – пункт, примерно равен 1/7 дюйма;<br></br>   • pc – пика (равна 12 пунктам).<br></br>   Относительные единицы:<br></br>   • em – высота шрифта элемента;<br></br>   • ex – высота буквы x;<br></br>   • px – пиксел;<br></br>   • % – процентное соотношение.<br></br>   Группу относительных единиц удобно использовать, чтобы сохранить первозданный вид документа на любом устройстве (на экране, при печати).<br></br>   Для нашего примера сделаем размер шрифта текста, равный 14 пунктам:<br></br>   p {<br></br>   font-size: 14pt;<br></br>   }<br></br>   Результат можно увидеть на рис. 8.8.<br></br><div class="wrap_pict"><div style="text-align: center;"><img src="i_098.png" alt=""></img></div>   <b>Рис. 8.8.</b> Размер шрифта 14 pt<br></br></div><br></br>   Мы рассмотрели основные возможности CSS по работе со шрифтами. Теперь приступим к изучению форматирования текста.<br></br></div></div><h2 id="idm139732168372688">8.3. Форматирование текста
</h2><div style="text-align: justify" class="hsection2"><div style="text-align: justify" class="section3">   В этом разделе вы познакомитесь с впечатляющими средствами CSS для отображения текста. Начнем изучение форматирования текста с отступов.<br></br>
</div><h3 id="idm139732168373840">Отступы
</h3><div style="text-align: justify" class="hsection3">   Представьте, что вы форматируете несколько HTML-страниц размером с небольшую книгу. Язык HTML не предоставляет специальных средств для задания отступа абзаца, и отступ приходится делать с помощью пробелов. Согласитесь, не очень-то удобно в начале каждого абзаца набирать пробелы, да еще и следить, чтобы их было одинаковое количество в начале всех абзацев. Еще хуже, если, выполнив часть или всю работу, вы обнаружите, что отступы недостаточны или слишком большие. CSS предоставляет замечательное свойство text-indent для решения данной проблемы. Размер отступа может задаваться как абсолютными, так и относительными единицами. В том числе и процентами. В качестве 100 % считается ширина всей страницы.<br></br>   Зададим в нашем примере отступ 25 пикселов (рис. 8.9):<br></br>   p {<br></br>   text-indent: 25px;<br></br>   }<br></br><div class="wrap_pict"><div style="text-align: center;"><img src="i_099.png" alt=""></img></div>   <b>Рис. 8.9.</b> Задание отступа 25 пикселов<br></br></div><br></br>   Для данного свойства остается порекомендовать поэкспериментировать с разными значениями и единицами измерений, чтобы лучше разобраться в них.<br></br></div><h3 id="idm139732168377936">Выравнивание текста
</h3><div style="text-align: justify" class="hsection3">   Выравнивание текста задается с помощью свойства text-align, значения которого такие же, как и значения свойства align у элемента P. Следующие значения указывают, что текст будет выровнен:<br></br>   • left – по левому краю;<br></br>   • right – по правому краю;<br></br>   • center – по центру;<br></br>   • justify – по формату.<br></br>   Для примера зададим для заголовков выравнивание по центру, а для вступительного намека – по правой стороне (рис. 8.10):<br></br>   h1 {<br></br>   text-align: center;<br></br>   }<br></br>   p.namek {<br></br>   text-align: right;<br></br>   }<br></br><div style="text-align: center;"><img src="i_100.png" alt=""></img></div>   <b>Рис. 8.10.</b> Выравнивание текста<br></br></div><h3 id="idm139732168351440">Декоративное оформление
</h3><div style="text-align: justify" class="hsection3">   С помощью CSS можно изменять или добавлять декоративное оформление текста. Для этого существует свойство text-decoration. Ниже перечислены все возможные значения данного свойства и их описания:<br></br>   • none – не производит декоративное оформление;<br></br>   • underline – каждая строка текста будет подчеркнута;<br></br>   • overline – над каждой строкой текста будет отображена линия;<br></br>   • line-through – каждая строка текста будет зачеркнута;<br></br>   • blink – текст будет мигать.<br></br><blockquote><div>   <b>Примечание</b><br></br>
   Вы можете указывать значения как по одному, так и по нескольку сразу. Если же вы определяете несколько значений, между ними нужно ставить только пробел. Указание запятой недопустимо, иначе браузер использует только те эффекты, которые записаны после последней запятой.<br></br>
</div></blockquote>   Свойство none на первый взгляд может показаться лишним. Ведь если не задавать его, то текст и так будет без декоративного оформления. Однако его полезно использовать для ссылок. Для них браузер по умолчанию считает заданным значение underline этого свойства. Иными словами, все ссылки на странице отображаются подчеркнутыми. Если вы захотите сделать ссылки такими же, как и основной текст, то есть без подчеркивания, то вам пригодится значение none.<br></br>   Применим новые знания на практике. Для примера обычным ссылкам установим значение text-decoration, равное none, а для ссылок типа hover – underline (рис. 8.11).<br></br>   a {<br></br>   text-decoration: none;<br></br>   }<br></br>   a:hover {<br></br>   text-decoration: underline;<br></br>   }<br></br><div class="wrap_pict"><div style="text-align: center;"><img src="i_101.png" alt=""></img></div>   <b>Рис. 8.11.</b> Декоративное оформление<br></br></div><br></br>   На рис. 8.11 видно, что ссылка главе 9 больше не подчеркнута.<br></br>   Чтобы лучше освоить данный пример форматирования, попробуйте сделать мигающими ссылки, на которые пользователь наводит указатель мыши.<br></br></div><h3 id="idm139732168360400">Расстояние между буквами
</h3><div style="text-align: justify" class="hsection3">   Расстояние между буквами можно задать свойством letter-spacing. В качестве значения указываются необходимая величина и абсолютная единица измерения.<br></br>   Для нашего примера зададим расстояние между буквами в заголовке шириной 6 пикселов:<br></br>   h1 {<br></br>   letter-spacing: 6px;<br></br>   }<br></br>   Результат можно увидеть на рис. 8.12.<br></br><div class="wrap_pict"><div style="text-align: center;"><img src="i_102.png" alt=""></img></div>   <b>Рис. 8.12.</b> Интервал между буквами<br></br></div><br></br>   Вы можете попробовать применить это свойство к другим элементам страницы.<br></br>   Далее вы узнаете, как с помощью данного свойства можно выделить необходимый текст на странице.<br></br></div><h3 id="idm139732168365392">Расстояние между словами
</h3><div style="text-align: justify" class="hsection3">   Можно задать расстояние как между буквами, так и между словами, используя свойство word-spacing. В качестве значения вы можете указать желаемое значение либо normal, чтобы использовать значение браузера по умолчанию.<br></br>   Это свойство не представляет сложностей, поэтому приведу лишь CSS-код:<br></br>   h1 { word-spacing: 1em }<br></br>   В данном примере расстояние между всеми словами в элементах H1 увеличивается на 1 em.<br></br></div><h3 id="idm139732194590544">Трансформация текста
</h3><div style="text-align: justify" class="hsection3">   Свойство text-transform управляет регистром символов. Существует три значения для данного свойства:<br></br>   • capitalize – пишет все слова с большой буквы;<br></br>   • uppercase – переводит все символы в верхний регистр;<br></br>   • lowercase – переводит все символы в нижний регистр.<br></br>   Сделаем заглавие первого уровня как в английском языке: все слова запишем с прописной буквы (рис. 8.13):<br></br>   h1 {<br></br>   text-transform: capitalize;<br></br>   }<br></br><div class="wrap_pict"><div style="text-align: center;"><img src="i_103.png" alt=""></img></div>   <b>Рис. 8.13.</b> Изменение регистра букв<br></br></div><br></br>   Вы можете использовать это свойство вместе со свойством letter-spacing, описанным выше. Вместе они дают интересный оформительский эффект. Текст, выделенный этими свойствами, может не отличаться по цвету от основного текста, не нарушая тем самым цветовую схему документа. И в то же время он будет сильно бросаться в глаза.<br></br>   Поэкспериментируйте с заданием разных значений данного свойства для нашего примера, попробуйте сделать весь текст заголовка написанным сначала прописными буквами, а потом строчными.<br></br></div><h3 id="idm139732194596176">Пустое место
</h3><div style="text-align: justify" class="hsection3">   CSS также позволяет задавать способ обработки браузером пустого пространства. Для этого нужно использовать свойство white-space. Рассмотрим значения, которые может принимать это свойство, и их описание:<br></br>   • normal – браузер будет сжимать последовательно пустое пространство и разбивать строки для вмещения линейных блоков;<br></br>   • pre – браузер не может изменять последовательность символов пустого пространства, строки разбиваются только в местах начала новой строки, обозначенных в исходном тексте;<br></br>   • nowrap – работает, как значение normal в смысле сокращения пустого пространства, но запрещает образовывать разрывы строк в тексте, за исключением разрывов, определенных с помощью элемента BR.<br></br>   Рассмотрим такой пример:<br></br>   body { white-space: pre }<br></br>   Браузер отобразит HTML-документ так, как он отображается в исходном виде, например в программе Блокнот.<br></br></div><h3 id="idm139732194599760">Направление вывода текста
</h3><div style="text-align: justify" class="hsection3">   Направлением вывода текста можно управлять, используя CSS-свойство direction. Оно может принимать следующие значения:<br></br>   • ltr – направление слева направо;<br></br>   • rtl – направление справа налево.<br></br></div></div><h2 id="idm139732194601552">Резюме
</h2><div style="text-align: justify" class="hsection2">   В данной главе мы разобрали основные методы форматирования текста средствами CSS. Вы познакомились с приемами изменения внешнего вида текста, заданием его шрифта, цвета, размера, научились изменять его внешний вид и располагать на странице.<br></br>   Теперь вам под силу отформатировать текст любой сложности и любых размеров. Немного практики – и вы станете настоящим профессионалом веб-дизайна.<br></br></div></div><h1 xmlns="http://www.w3.org/1999/xhtml" id="idm139732194602960" class="master">Глава 9<br></br>
Оформление HTML-документа средствами CSS
</h1><div xmlns="http://www.w3.org/1999/xhtml" style="text-align: justify" class="hsection1"><div style="text-align: justify" class="section2">   9.1. Фон<br></br>
   9.2. Генерируемое содержимое<br></br>
   9.3. Автоматическая нумерация и списки<br></br>
   9.4. Таблицы<br></br>
   9.5. Интерфейс пользователя<br></br>
   9.6. Поля и отступы<br></br>
   9.7. Границы<br></br>
   9.8. Работа с блоками<br></br>
   В этой главе мы рассмотрим все возможности CSS по оформлению документа. Изучив этот материал, вы с легкостью сможете придать вашим страницам эксклюзивный вид. Начнем изучение с изменения фона страницы.<br></br>
</div><h2 id="idm139732194574928">9.1. Фон
</h2><div style="text-align: justify" class="hsection2">   В качестве фона любого элемента страницы вы можете задать либо цвет, либо изображение. Свойства фона не наследуются, но фон родительского блока всегда будет виден, так как в качестве начального значения свойства background-color выступает значение transparent, то есть прозрачность.<br></br>   Следует отметить, что некоторые браузеры будут отображать фон HTML-документов, заданный для элемента HTML. Хотя рекомендуется устанавливать фон для элемента BODY, а не для элемента HTML.<br></br>   Рассмотрим пример, приведенный в листинге 9.1.<br></br><h5 class="subtitle"><b>Листинг 9.1.</b> Фон страницы</h5>   &lt;html&gt;<br></br>   &lt;head&gt;<br></br>   &lt;title&gt;Глава 9. Установка фона области представления&lt;/title&gt;<br></br>   &lt;style type="text/css"&gt;<br></br>   body { background: url("http://style.com/marble.png") }<br></br>   &lt;/style&gt;<br></br>   &lt;/head&gt;<br></br>   &lt;body&gt;<br></br>   &lt;p&gt;Я использую мраморный фон из файла картинки.<br></br>   &lt;/body&gt;<br></br>   &lt;/html&gt;<br></br>   Фон документа, представленного в листинге 9.1, будет задан картинкой, размноженной на все окно браузера и находящейся в файле marble.png.<br></br>   Список всех возможных свойств фона таков: background-color, background-image, background-repeat, background-attachment, background-position и background.<br></br>   Теперь рассмотрим каждое из них подробнее.<br></br>   Итак, первое свойство – background-color. Оно устанавливает цвет фона элемента, равный либо шестнадцатеричному значению цвета, либо названию цвета, либо RGB-значению цвета, либо ключевому слову transparent. Ключевое свойство transparent просто-напросто делает фон элемента прозрачным.<br></br>   Пример:<br></br>   body { background-color: #FF0000 }<br></br>   Приведенный код устанавливает красный цвет фона страницы.<br></br>   Второе свойство – background-image. Оно задает графический объект, то есть картинку из файла, в качестве фона элемента. При определении фонового изображения рекомендуется также указывать цвет фона, который будет использоваться, если изображение недоступно. Если изображение доступно, то оно отображается поверх фонового цвета, который все же будет виден сквозь прозрачные фрагменты изображения. В качестве значения этого свойства выступает адрес картинки. Вы также можете задать в качестве значения ключевое слово none, чтобы не использовать фоновое изображение, например, пока не известен адрес файла фоновой картинки. Рассмотрим такой фрагмент таблицы стилей:<br></br>   body { background-image: url(«some_bgimage.gif») }<br></br>   p { background-image: none }<br></br>   В данном примере в качестве фона страницы будет использоваться изображение из файла some_bgimage.gif. Однако содержимое страницы внутри элемента P будет находиться на белом либо на таком фоне, который задан в браузере по умолчанию (как правило, белый).<br></br>   Если вы задали фоновое изображение, то можете также использовать свойство background-repeat, которое определяет, будет ли изображение дублироваться, и если да, то каким образом. Данное свойство может принимать следующие значения:<br></br>   • repeat – дублируется как по вертикали, так и по горизонтали;<br></br>   • repeat-x – дублируется только по горизонтали;<br></br>   • repeat-y – дублируется только по вертикали;<br></br>   • no-repeat – не дублируется: выводится только одна копия изображения.<br></br>   Рассмотрим такой пример:<br></br>   body {<br></br>   background: white url("pendant.gif");<br></br>   background-repeat: repeat-y;<br></br>   background-position: center;<br></br>   }<br></br>   Цвет страницы будет белым. Фоновое изображение будет вертикально продублировано и расположено посередине страницы.<br></br>   Если вы задали фоновое изображение, то нужно указать свойство background-attachment, которое определяет, будет ли изображение фиксироваться относительно окна просмотра (значение fixed) или перемещаться вместе с документом (значение scroll) в процессе его прокрутки.<br></br>   Рассмотрим пример:<br></br>   body {<br></br>   background: red url("pendant.gif");<br></br>   background-repeat: repeat-y;<br></br>   background-attachment: fixed;<br></br>   }<br></br>   При использовании приведенного примера для какого-то HTML-документа цвет фона документа станет красным, а на странице сформируется бесконечная вертикальная полоса из файла pendant.gif. Полоса будет оставаться как бы «приклеенной» к окну просмотра во время горизонтальной или вертикальной прокрутки.<br></br>   Вы также можете задать начальное положение фонового изображения на странице, используя свойство background-position. Есть несколько способов присвоения значения данному свойству.<br></br>   Например, вы можете задавать местоположение, используя проценты. Причем если вы используете пару значений 0 % 0 %, то верхний левый угол изображения выравнивается относительно верхнего левого угла краевой линии отступов блока. Если зададите пару значений 100 % 100 %, то нижний правый угол изображения помещается в нижний правый угол краевой линии отступов. Если вы зададите пару значений 14 % 8 4 %, то верхний левый угол изображения смещается вдоль изображения на 14 % вправо по горизонтали и на 84 % вниз по вертикали. Тем самым он помещается в точку, смещенную вдоль области, предназначенной для отступов, на 14 % вправо по горизонтали и на 84 % вниз по вертикали.<br></br>   Вы также можете задать данное значение, используя число и единицу длины. Например, если вы зададите пару 2 cm 2 cm, то верхний левый угол изображения помещается на 2 см правее и 2 см ниже верхнего левого угла области, предназначенной для отступов.<br></br>   Помимо этого, вы можете использовать в качестве значений ключевые слова. Ниже приведены их список и описания:<br></br>   • top left и left top – аналогично паре значений 0 % 0 %;<br></br>   • top, top center и center top – как и пара значений 50 % 0 %;<br></br>   • right top и top right – аналогично паре значений 100 % 0 %;<br></br>   • left, left center и center left – как и пара значений 0 % 50 %;<br></br>   • center и center center – аналогично паре значений 50 % 50 %;<br></br>   • right, right center и center right – как и пара значений 100 % 50 %;<br></br>   • bottom left и left bottom – аналогично паре значений 0 % 100 %;<br></br>   • bottom, bottom center и center bottom – как и пара значений 50 % 100 %;<br></br>   • bottom right и right bottom – аналогично паре значений 100 % 100 %.<br></br>   Если вы зададите только одно значение длины или одно процентное соотношение, то оно определит позицию только по горизонтали, а позиция по вертикали будет принята браузером как значение 50 %. Если вы зададите два значения, то первым браузер будет считать позицию по горизонтали. Вы также можете сочетать значение длины и процентное соотношение (например, 5 0 % 2 cm). Можно использовать отрицательные значения. Однако помните, что ключевые слова нельзя применять вместе со значениями длины или процентными соотношениями.<br></br>   Можно использовать сокращенную запись для всех свойств, приведенных выше, с помощью свойства background. Например:<br></br>   body { background: url(«chess.png») gray 50% 20% repeat fixed }<br></br>   В данной таблице стилей заданы значения для всех свойств фона документа.<br></br></div><h2 id="idm139732194568656">9.2. Генерируемое содержимое
</h2><div style="text-align: justify" class="hsection2"><div style="text-align: justify" class="section3">   В некоторых случаях у вас может возникнуть необходимость в том, чтобы браузер пользователя отображал на экране содержимое, которое не принадлежит так называемому «дереву» HTML-документа. Хорошим примером может служить нумерованный список. Без сомнения, вам не захочется вводить числа нумерации вручную. Ведь если список довольно большой, а вам вдруг необходимо добавить элемент в его начало, то придется менять всю нумерацию. Не правда ли, будет гораздо удобнее, если браузер будет генерировать нумерацию автоматически? Согласитесь, также гораздо удобнее работать с большими страницами, если, к примеру, браузер сам добавляет слово «Рисунок» и номер рисунка перед его названием или, например, вставляет надпись «Глава 9.» перед заголовком девятой главы.<br></br>
   Хотя это может показаться нелепым, но в отличие от HTML CSS предоставляет средства для решения данных проблем.<br></br>
   С помощью CSS можно генерировать содержимое несколькими способами:<br></br>
   • с использованием свойства content в сочетании с псевдоэлементами: before и: after;<br></br>
   • с использованием элементов, свойство display которых принимает значение list-item.<br></br>
   Подробно рассмотрим все возможности CSS по генерации содержимого и начнем с использования свойства content.<br></br>
</div><h3 id="idm139732194522704">Псевдоэлементы :before и: after
</h3><div style="text-align: justify" class="hsection3">   С помощью псевдоэлементов: before и: after можно задать стиль и местоположение генерируемого содержимого. Не требуется особых познаний в английском языке, чтобы из названия догадаться, что эти псевдоэлементы определяют местоположение «перед» и «после» содержимого элемента, принадлежащего дереву HTML-документа. Используя эти псевдоэлементы в сочетании со свойством content, вы можете определить содержимое и место, куда оно должно быть вставлено.<br></br>   Рассмотрим простой пример. Пусть браузер сам расставит точки в конце абзацев в документе:<br></br>   p:after { content: "." }<br></br>   Надо помнить, что псевдоэлементы: before и: after могут быть связаны с элементом HTML-документа. Тогда они будут наследовать его свойства. Чтобы вы лучше разобрались, приведу такой пример:<br></br>   p:before {<br></br>   content: open-quote;<br></br>   color: red<br></br>   }<br></br>   Теперь перед каждым элементом P будет добавлена кавычка красного цвета, а шрифт кавычки будет такой же, какой задан всему абзацу.<br></br></div><h3 id="idm139732194527312">Свойство content
</h3><div style="text-align: justify" class="hsection3">   Это свойство используется вместе с псевдоэлементами: before и: after для генерации содержимого в документе. В примерах выше мы уже использовали это свойство. Теперь разберем его подробно.<br></br>   Свойство content может принимать одно из нескольких значений: строку текста, URL-адрес документа, который должен быть вставлен, счетчик, кавычки либо значение атрибута. Вы можете создавать сложную вложенную строку, используя строку текста, счетчики, значения атрибутов элемента одновременно. При этом сложная строка должна быть разделена только пробелами, а не запятыми. Например:<br></br>   content: "Рисунок " counter(imagenum) ". " attr(alt)<br></br>   В документ может быть вставлена обычная текстовая строка, которая обязательно должна быть заключена в кавычки. Для примера добавим перед всеми абзацами надпись Абзац::<br></br>   p:before { content "Абзац: " }<br></br>   Вы также можете вставлять в генерируемое содержимое переходы на новую строку с помощью последовательности \A. Вставка данной последовательности приводит к принудительному разрыву строки, аналогичному тому, который получается при использовании элемента BR.<br></br>   Скорректируем наш пример:<br></br>   p:before {<br></br>   content: "Абзац:\A"<br></br>   }<br></br>   Теперь перед каждым абзацем будет добавлена строка Абзац:, а сам абзац будет начинаться со следующей строки.<br></br>   Рассмотрим вставку строки, которая является значением параметра элемента. На первый взгляд может показаться непонятным, где это можно использовать. Такая функция применяется, например, для вставки значения атрибута alt элемента IMG:<br></br>   img:before { content: attr(alt) }<br></br>   Если изображение не будет выведено, то читатель, по крайней мере, увидит текст атрибута alt, то есть название или описание рисунка.<br></br>   Хорошо разобраться с данным свойством помогут только эксперименты. Не пожалейте на них времени, и при разработке и обслуживании страниц оно вам с лихвой окупится.<br></br></div><h3 id="idm139732194534864">Кавычки
</h3><div style="text-align: justify" class="hsection3">   Может понадобиться, чтобы в документе или в какой-то его части кавычки отображались не так, как обычно, а в зависимости от стиля и содержимого. С помощью CSS вы можете определять, каким образом браузер будет отображать кавычки. Свойство quotes задает пару «» для каждого уровня вложенности цитат, а свойство content предоставляет доступ к этим кавычкам и вставляет их до и после цитаты.<br></br>   Рассмотрим определения кавычек с помощью свойства quotes. Лучше всего это можно понять из примера. Попробуйте применить следующую таблицу стиля:<br></br>   /* Определение пар кавычек для двух уровней в двух языках */<br></br>   Q:lang(ru) { quotes: ‘"’ ‘"’ "’" "’" }<br></br>   Q:lang(no) { quotes: "«" "»" "&lt;" "&gt;" }<br></br>   /* Вставка кавычек до и после содержимого элемента Q */<br></br>   Q:before { content: open-quote }<br></br>   Q:after { content: close-quote }<br></br>   к HTML-документу, представленному в листинге 9.2.<br></br><h5 class="subtitle"><b>Листинг 9.2.</b> Кавычки</h5>   &lt;html&gt;<br></br>   &lt;head&gt;<br></br>   &lt;title&gt;Глава 9&lt;/title&gt;<br></br>   &lt;/head&gt;<br></br>   &lt;body&gt;<br></br>   &lt;p&gt;&lt;q&gt;Этот текст выделен кавычками.&lt;/q&gt;<br></br>   &lt;/body&gt;<br></br>   &lt;/html&gt;<br></br>   В результате его обработки браузером вы получите такой текст:<br></br>   «Этот текст выделен кавычками.»<br></br>   Если ту же таблицу стилей применить к HTML-документу, приведенному в листинге 9.3, то получим такую строку:<br></br>   «Trondere gra&#711;ter na&#711;r &lt;Vinsjan pa&#711; kaia&gt; blir deklamert.»<br></br><h5 class="subtitle"><b>Листинг 9.3.</b> Кавычки</h5>   &lt;html&gt;<br></br>   &lt;head&gt;<br></br>   &lt;title&gt;Глава 9&lt;/title&gt;<br></br>   &lt;/head&gt;<br></br>   &lt;body&gt;<br></br>   &lt;p&gt;&lt;q&gt;Trondere gra&#711;ter na&#711;r &lt;q&gt;Vinsjan pa&#711; kaia&lt;/q&gt; blir deklamert.&lt;/q&gt;<br></br>   &lt;/body&gt;<br></br>   &lt;/html&gt;<br></br>   Как вы, наверное, заметили из примера, кавычки вставляются в соответствующие места документа благодаря значениям open-quote и close-quote, принимаемым свойством content. Каждое вхождение open-quote или close-quote в зависимости от глубины вложения заменяется одной из строк, принадлежащих значению свойства quotes.<br></br>   Open-quote указывает на первую из двух кавычек, а close-quote – на вторую. Тип используемых кавычек зависит от уровня их вложенности.<br></br>   Вы также можете задавать кавычки, используя один из шестнадцатеричных кодов, приведенных в табл. 9.1, предварительно поставив знак \.<br></br><h5 class="subtitle"><b>Таблица 9.1.</b> Кавычки</h5><div class="wrap_pict"><div style="text-align: center;"><img src="i_104.png" alt=""></img></div>   Например:<br></br></div><br></br>   quotes: """ """ «\2039» «\203A»<br></br></div></div><h2 id="idm139732228204368">9.3. Автоматическая нумерация и списки
</h2><div style="text-align: justify" class="hsection2"><div style="text-align: justify" class="section3">   В CSS существует два свойства для управления нумерацией: counter-increment и counter-reset. Счетчики, которые определены данными свойствами, используются функциями counter() и counters() свойства content. Рассмотрим подробно свойства для управления нумерацией.<br></br>
   • counter-increment – с помощью этого свойства вы можете задать одно или несколько имен счетчиков, после каждого из которых может быть указано целое число. Оно определяет величину, на которую увеличивается содержимое счетчика при каждом его использовании. По умолчанию значение счетчика увеличивается на единицу. Вы также можете использовать отрицательные целые числа.<br></br>
   • counter-reset – также содержит список из одного или нескольких имен счетчиков, после каждого из которых может быть указано целое число. Оно задает значение, которое сначала присваивается счетчику. По умолчанию значение равно 0.<br></br>
   Для примера рассмотрим таблицу стилей, которая нумерует главы и разделы таким образом:<br></br>
   • Глава 1:<br></br>
   &#903; 1.1;<br></br>
   &#903; 1.2.<br></br>
   • Глава 2:<br></br>
   &#903; 2.1;<br></br>
   &#903; 2.2 и т. д.<br></br>
   Код таблицы следующий:<br></br>
   h1:before {<br></br>
   content: "Глава " counter(chapter) ". ";<br></br>
   counter-increment: chapter; /* Добавление 1 к номеру главы */<br></br>
   counter-reset: section; /* Установка значения 0 для раздела */<br></br>
   }<br></br>
   h2:before {<br></br>
   content: counter(chapter) "." counter(section) " ";<br></br>
   counter-increment: section;<br></br>
   }<br></br>
   В примере не указана цифра, с которой начинать нумерацию, так как по умолчанию она начинается с единицы. Однако, как отмечалось выше, это возможно.<br></br>
   Если вы одновременно зададите увеличение или сбрасывание счетчика, а также используете его с помощью свойства content, то сначала счетчик будет увеличен или сброшен, а потом применится в документе.<br></br>
   Важно помнить, что свойство counter-reset поддерживает правила каскада. По этим правилам в следующей таблице стилей сбрасывается только счетчик imagenum:<br></br>
   h1 { counter-reset: section -1 }<br></br>
   h1 { counter-reset: imagenum 99 }<br></br>
   Чтобы выполнить сброс обоих счетчиков, необходимо задать их вместе:<br></br>
   h1 { counter-reset: section -1 imagenum 99 }<br></br>
</div><h3 id="idm139732228183632">Стили счетчиков
</h3><div style="text-align: justify" class="hsection3">   По умолчанию браузер отображает значение счетчика как число в десятичном формате, но вы можете использовать и другие стили отображения счетчика, доступные через свойство list-style-type. Тогда описание счетчика будет выглядеть так:<br></br>   counter(«название счетчика», list-style-type)<br></br>   Чтобы задать стиль, используемый по умолчанию, можно использовать следующую запись:<br></br>   counter(«название счетчика»)<br></br>   Иными словами, просто не задавать значение list-style-type.<br></br>   Вы можете использовать любые стили, в том числе disc (круг), circle (окружность), square (квадрат) и none (ничего). Например:<br></br>   h1:before { content: counter(chno, upper-latin) ". " }<br></br>   h2:before { content: counter(section, upper-roman) " – " }<br></br>   blockquote:after { content: " [" counter(bq, hebrew) "]" }<br></br>   div.note:before { content: counter(notecntr, disc) " " }<br></br>   p:before { content: counter(p, none) }<br></br>   Попробуйте создать простую HTML-страницу, используя элементы, которые записаны в данном CSS-коде, и применить к ней только что созданную таблицу стилей.<br></br></div><h3 id="idm139732228189904">Счетчики со свойством display: none
</h3><div style="text-align: justify" class="hsection3">   Неотображаемые элементы, то есть элементы, для свойства display которых установлено значение none, не могут увеличивать или уменьшать значение счетчика.<br></br>   Например, в таблице стилей, представленной ниже, элементы H2 класса do_not_ display не увеличивают значение счетчика count_h2:<br></br>   H2. do_not_display {counter-increment: count_h2; display: none}<br></br>   Следует отметить, что элементы, для которых свойство visibility задано как hidden, увеличивают значения счетчиков.<br></br></div><h3 id="idm139732228159568">Списки
</h3><div style="text-align: justify" class="hsection3">   Рассмотрим все возможности задания спискам различного визуального форматирования.<br></br>   Кстати, если вы с помощью display: marker укажете маркер вместе с элементом списка, созданным с помощью свойств списка, то маркер просто-напросто заменит стандартный элемент списка. Подробно про маркеры будет рассказано дальше.<br></br>   Для списков также нельзя задать фон. Чтобы использовать в документе список с фоном, нужно задать список как маркер, то есть использовать display: marker, но про это также будет рассказано дальше.<br></br>   Итак, начнем со стилизации списка с помощью свойства list-style-type. Это свойство задает вид маркера элемента списка, если для свойства list-style-image указано значение none или изображение, на которое указывает URL, недоступно. Можно использовать три типа маркеров: глифы, нумерованные и алфавитные, либо задать значение none, которое означает, что маркер не используется.<br></br>   Рассмотрим типы маркеров списка подробнее. Первыми разберем глифы. Они определяются с помощью значений disk, circle и square. Обычно они отображаются браузерами клиента как круг, окружность или квадрат. Пример списка с маркером в виде квадрата приведен в листинге 9.4.<br></br><h5 class="subtitle"><b>Листинг 9.4.</b> Нумерация средствами CSS</h5>   &lt;html&gt;<br></br>   &lt;head&gt;<br></br>   &lt;title&gt;Глава 9. Маркеры в виде квадрата&lt;/title&gt;<br></br>   &lt;style type="text/css"&gt;<br></br>   ol { list-style-type: square }<br></br>   &lt;/style&gt;<br></br>   &lt;/head&gt;<br></br>   &lt;body&gt;<br></br>   &lt;ol&gt;<br></br>   &lt;li&gt; Это первый элемент списка.<br></br>   &lt;li&gt; Это второй элемент списка.<br></br>   &lt;li&gt; Это третий элемент списка.<br></br>   &lt;/ol&gt;<br></br>   &lt;/body&gt;<br></br>   &lt;/html&gt;<br></br>   Теперь рассмотрим нумерованные списки. Различают несколько систем нумерации списков. Ниже представлены все системы нумерации, используемые в CSS, и их описание:<br></br>   • decimal – десятичные числа, начиная с 1;<br></br>   • decimal-leading-zero – десятичные числа, дополненные нулями (например, 01, 02, 03… 98, 99);<br></br>   • lower-roman – римские цифры, представленные строчными буквами (i, ii, iii, iv, v и т. д.);<br></br>   • upper-roman – римские цифры, представленные прописными буквами (I, II, III, IV, V и т. д.);<br></br>   • hebrew – традиционная еврейская нумерация;<br></br>   • georgian – традиционная грузинская нумерация (an, ban, gan…, he, tan, in, in-an…);<br></br>   • armenian – традиционная армянская нумерация;<br></br>   • cjk-ideographic – простые идеографические числа;<br></br>   • hiragana – a, i, u, e, o, ka, ki…;<br></br>   • katakana – A, I, U, E, O, KA, KI…;<br></br>   • hiragana-iroha – i, ro, ha, ni, ho, he, to…;<br></br>   • katakana-iroha – I, RO, HA, NI, HO, HE, TO….<br></br>   Третий вариант задания маркеров списка – с помощью так называемой алфавитной системы, или с помощью букв. Ниже приведены алфавитные системы и их описание:<br></br>   • lower-latin или lower-alpha – строчные буквы в коде ASCII (a, b, c… z);<br></br>   • upper-latin или upper-alpha – прописные (заглавные) буквы в коде ASCII (A, B, C… Z);<br></br>   • lower-greek – классические строчные греческие буквы: альфа (а), бета (Р), гамма (у) и т. д.<br></br>   Для примера создадим страницу, представленную в листинге 9.5.<br></br><h5 class="subtitle"><b>Листинг 9.5.</b> Нумерация</h5>   &lt;html&gt;<br></br>   &lt;head&gt;<br></br>   &lt;title&gt;Глава 9. Нумерация с использованием римских цифр&lt;/title&gt;<br></br>   &lt;style type="text/css"&gt;<br></br>   ol { list-style-type: upper-roman }<br></br>   &lt;/style&gt;<br></br>   &lt;/head&gt;<br></br>   &lt;body&gt;<br></br>   &lt;ol&gt;<br></br>   &lt;li&gt; Это первый элемент списка.<br></br>   &lt;li&gt; Это второй элемент списка.<br></br>   &lt;li&gt; Это третий элемент списка.<br></br>   &lt;/ol&gt;<br></br>   &lt;/body&gt;<br></br>   &lt;/html&gt;<br></br>   В результате обработки браузером кода из листинга 9.5 вы должны увидеть такой список:<br></br>   I Это первый элемент.<br></br>   II Это второй элемент.<br></br>   III Это третий элемент.<br></br>   Теперь рассмотрим свойство list-style-image. Оно определяет файл с картинкой, используемой в качестве маркера списка. Если картинка доступна, то она заменяет маркер, устанавливаемый свойством list-style-type.<br></br>   Рассмотрим такой пример:<br></br>   UL { list-style-image: url(«http://my_site.com/my_marker.jpg») }<br></br>   Если браузеру удастся загрузить файл картинки my_marker. jpg, то он отобразит ее перед каждым пунктом списка в качестве маркера.<br></br>   Свойство list-style-position определяет положение блока маркера в главном структурном блоке. Для данного свойства вы можете задавать следующие значения:<br></br>   • outside – блок маркера находится за пределами главного структурного блока;<br></br>   • inside – блок маркера находится в первом строковом блоке главного структурного блока, следом за которым выводится содержимое элемента.<br></br>   Рассмотрим данное свойство на примере (листинг 9.6).<br></br><h5 class="subtitle"><b>Листинг 9.6.</b> Нумерация в списках</h5>   &lt;html&gt;<br></br>   &lt;head&gt;<br></br>   &lt;title&gt;Глава 9. Сравнение внутреннего/внешнего расположения&lt;/title&gt;<br></br>   &lt;style type="text/css"&gt;<br></br>   ul { list-style: outside }<br></br>   ul.compact { list-style: inside }<br></br>   &lt;/style&gt;<br></br>   &lt;/head&gt;<br></br>   &lt;body&gt;<br></br>   &lt;ul&gt;<br></br>   &lt;li&gt;первый элемент списка располагается первым<br></br>   &lt;li&gt;второй элемент списка располагается вторым<br></br>   &lt;/ul&gt;<br></br>   &lt;ul class="compact"&gt;<br></br>   &lt;li&gt;первый элемент списка располагается первым<br></br>   &lt;li&gt;второй элемент списка располагается вторым<br></br>   &lt;/ul&gt;<br></br>   &lt;/body&gt;<br></br>   &lt;/html&gt;<br></br>   HTML-документ, представленный в листинге 9.6, показан на рис. 9.1.<br></br><div class="wrap_pict"><div style="text-align: center;"><img src="i_105.png" alt=""></img></div>   <b>Рис. 9.1.</b> Сравнение внутреннего/внешнего расположения<br></br></div><br></br>   Следует отметить, что если направление отображения текста справа налево, то маркеры будут располагаться справа от текста.<br></br>   Свойство list-style является сокращенной формой задания трех свойств list-style-type, list-style-image и list-style-position, как и рассмотренная ранее сокращенная запись для шрифтов font. Например:<br></br><br></br>   UL { list-style: upper-roman inside } /* Любой элемент UL */<br></br>   UL &gt; UL { list-style: circle outside } /* Любой дочерний элемент UL элемента UL */<br></br><br></br>   Хотя вы можете задать информацию list-style о стиле списка непосредственно в элементах списка (например, в элементе LI языка HTML), тем не менее такой способ нужно применять с определенной осторожностью. Следующие два правила CSS выглядят похожими, хотя первое определяет селектор потомков, а второе (более специфичное) – селектор дочерних элементов:<br></br><br></br>   OL.alpha LI { list-style: lower-alpha } /* Любой потомок LI элемента OL */<br></br>   OL.alpha &gt; LI { list-style: lower-alpha } /* Любой дочерний элемент LI элемента OL */<br></br><br></br>   В чем же опасность? При использовании только селекторов потомков вы можете не достичь желаемых результатов. Рассмотрим пример, приведенный в листинге 9.7.<br></br><h5 class="subtitle"><b>Листинг 9.7.</b> Каскад</h5>   &lt;html&gt;<br></br>   &lt;head&gt;<br></br>   &lt;title&gt;Глава 9. Результат применения каскада&lt;/title&gt;<br></br>   &lt;style type="text/css"&gt;<br></br>   ol.alpha li { list-style: lower-alpha }<br></br>   ul li { list-style: disc }<br></br>   &lt;/style&gt;<br></br>   &lt;/head&gt;<br></br>   &lt;body&gt;<br></br>   &lt;ol class="alpha"&gt;<br></br>   &lt;li&gt;первый уровень списка<br></br>   &lt;ul&gt;<br></br>   &lt;li&gt;второй уровень списка<br></br>   &lt;/ul&gt;<br></br>   &lt;/ol&gt;<br></br>   &lt;/body&gt;<br></br>   &lt;/html&gt;<br></br><br></br>   Отображение элементов списка первого и второго уровней, помеченных маркерами типа lower-alpha и disc соответственно, будет осуществлено надлежащим образом. Однако каскад приведет к тому, что первое правило стиля (включающее специфичную информацию о классе) будет перекрывать второе. И вы получите одну и ту же маркировку для первого и второго уровней (рис. 9.2).<br></br><div class="wrap_pict"><div style="text-align: center;"><img src="i_106.png" alt=""></img></div>   <b>Рис. 9.2.</b> Каскад<br></br></div><br></br>   Следующий код позволит решить данную проблему:<br></br><br></br>   OL.alpha &gt; LI { list-style: lower-alpha }<br></br>   UL LI { list-style: disc }<br></br><br></br>   Есть еще один способ записи, который позволит отобразить ваш список так, как вы задумали. Для этого нужно задать информацию list-style о стиле списка исключительно в элементах списка:<br></br><br></br>   OL.alpha { list-style: lower-alpha }<br></br>   UL { list-style: disc }<br></br><br></br>   Благодаря наследованию значения свойства list-style элементов OL и UL будут передаваться соответствующим свойствам элементов LI. Именно этот способ рекомендуется использовать для задания стиля списка.<br></br>   Значение URL вы можете комбинировать с любыми другими значениями, как в этом примере:<br></br><br></br>   UL { list-style: url(«http://my_site.com/my_image.gif») disc }<br></br><br></br>   Если в данном примере браузер не сможет получить доступ к графическому объекту, то вместо него он будет использовать маркер типа disc.<br></br>   Надо отметить, что если для свойства list-style устанавливается значение none, то свойствам list-style-type и list-style-image также присваивается значение none:<br></br><br></br>   UL { list-style: none }<br></br><br></br>   В результате маркер элемента списка просто не отображается.<br></br></div><h3 id="idm139732227551312">Маркеры
</h3><div style="text-align: justify" class="hsection3">   В данном разделе мы рассмотрим использование маркеров.<br></br>   Для понимания маркеров нужно знать, что браузер обрабатывает каждый элемент HTML-документа как прямоугольный блок.<br></br>   Большинство элементов CSS генерируются внутри одного главного структурного блока HTML-элемента. При использовании в CSS маркеров браузер применяет два способа отображения, то есть генерирует два блока: один главный структурный блок (для содержимого элемента) и один отдельный блок для маркера (используемый для таких элементов оформления, как маркеры позиции, изображения или числа). Блок маркера может находиться внутри или вне главного блока. В отличие от содержимого, добавляемого с помощью свойства content, блок маркера не влияет на расположение главного блока.<br></br>   Более ограниченный в своих возможностях способ разбиения документа использует свойства списков. И хотя маркеры более сложны для понимания, в отличие от списков они позволят вам точно управлять их позицией и содержимым. Вы также можете использовать маркеры вместе со счетчиками для создания новых стилей списков, для нумерации заметок на полях и множества других действий.<br></br>   В примере из листинга 9.8 показано, как могут использоваться маркеры для добавления точек после каждого элемента нумерованного списка.<br></br><h5 class="subtitle"><b>Листинг 9.8.</b> Создание списка с помощью маркеров</h5>   &lt;html&gt;<br></br>   &lt;head&gt;<br></br>   &lt;title&gt;Глава 9. Создание списка с помощью маркеров&lt;/title&gt;<br></br>   &lt;style type="text/css"&gt;<br></br>   li:before {<br></br>   display: marker;<br></br>   content: counter(mycounter, upper-roman) ".";<br></br>   counter-increment: mycounter;<br></br>   }<br></br>   &lt;/style&gt;<br></br>   &lt;/head&gt;<br></br>   &lt;body&gt;<br></br>   &lt;ol&gt;<br></br>   &lt;li&gt; Это первый элемент списка.<br></br>   &lt;li&gt; Это второй элемент списка.<br></br>   &lt;li&gt; Это третий элемент списка.<br></br>   &lt;/ol&gt;<br></br>   &lt;/body&gt;<br></br>   &lt;/html&gt;<br></br>   В результате выполнения этого HTML-кода и таблицы стилей получим следующий список:<br></br>   I. Это первый элемент списка.<br></br>   II. Это второй элемент списка.<br></br>   III. Это третий элемент списка.<br></br>   С помощью селекторов потомков и селекторов дочерних элементов вы можете задавать различные типы маркеров в зависимости от глубины вложенности списков.<br></br>   Чтобы задать маркер, вы должны присвоить свойству display в псевдоэлементе: before или: after значение marker. Если содержимое псевдоэлемента: before или: after, которое относится к типу block или inline, является частью главного блока генерируемого элемента, то содержимое типа marker формируется в отдельный блок маркера, находящийся вне главного блока. Блоки маркеров формируются в виде отдельной строки. Следует также отметить, что блок маркера создается только тогда, когда свойство content псевдоэлемента генерирует какое-то содержимое.<br></br>   Вы можете задавать для блока маркера границы и отступы.<br></br>   В официальной документации по CSS говорится, что в псевдоэлементе: before вертикальное выравнивание базовой линии текста, содержащегося в блоке маркера, осуществляется относительно базовой линии текста первой строки содержимого главного блока. Если главный блок не содержит текста, то выравниваются верхние сегменты внешних краевых линий блока маркера и главного блока. В псевдоэлементе: after вертикальное выравнивание базовой линии текста, содержащегося в блоке маркера, осуществляется относительно базовой линии текста последней строки содержимого главного блока. Если главный блок не содержит текста, то выравниваются нижние сегменты внешних краевых линий блока маркера и главного блока.<br></br>   Высоту блока маркера вы можете задать свойством line-height. Блок маркера, связанный с псевдоэлементом: before или: after, принимается во внимание при вычислении высоты первого или последнего линейного блока, содержащегося в главном блоке. Таким образом, маркеры выравниваются по первой или по последней строке содержимого элемента, даже если блоки маркеров располагаются в отдельных линейных блоках.<br></br>   Вертикальное выравнивание внутри блока маркера определяется свойством vertical-align.<br></br>   Вы также можете изменять ширину блока маркера, используя свойство width. Если вы зададите для свойства width значение auto, то ширина содержимого блока маркера будет равна ширине содержимого.<br></br>   Для маркера также можно изменять величину горизонтального интервала, используя свойство marker-offset. Это свойство задает расстояние между блоком маркера и связанным с ним главным блоком. Расстояние измеряется между их ближайшими краями границ.<br></br>   Если для свойства display элемента задано CSS-правило display: list-item и устанавливается значение marker, то блок маркера, генерируемый для псевдоэлемента: before, заменяет обычный маркер элемента списка.<br></br>   Создадим такую страницу, в которой содержимое располагается по центру внутри блока маркера фиксированной ширины 6 em (листинг 9.9).<br></br><h5 class="subtitle"><b>Листинг 9.9.</b> Выравнивание содержимого в блоке маркера</h5>   &lt;html&gt;<br></br>   &lt;head&gt;<br></br>   &lt;title&gt;Глава .9 Выравнивание содержимого в блоке маркера&lt;/title&gt;<br></br>   &lt;style type="text/css"&gt;<br></br>   li:before {<br></br>   display: marker;<br></br>   content: "(" counter(counter) ")";<br></br>   counter-increment: counter;<br></br>   width: 6em;<br></br>   text-align: center;<br></br>   }<br></br>   &lt;/style&gt;<br></br>   &lt;/head&gt;<br></br>   &lt;body&gt;<br></br>   &lt;ol&gt;<br></br>   &lt;li&gt; Это первый элемент.<br></br>   &lt;li&gt; Это второй элемент.<br></br>   &lt;li&gt; Это третий элемент.<br></br>   &lt;/ol&gt;<br></br>   &lt;/body&gt;<br></br>   &lt;/html&gt;<br></br>   Если вы откроете документ, представленный в листинге 9.9, в браузере, то увидите следующее:<br></br>   (1) Это первый элемент.<br></br>   (2) Это второй элемент.<br></br>   (3) Это третий элемент.<br></br>   Рассмотрим еще один пример (листинг 9.10). В нем маркеры создаются перед элементами списка и после них.<br></br><h5 class="subtitle"><b>Листинг 9.10.</b> Маркеры перед элементами списка и после них</h5>   &lt;html&gt;<br></br>   &lt;head&gt;<br></br>   &lt;title&gt;Глава 9. Маркеры перед элементами списка и после них&lt;/title&gt;<br></br>   &lt;style type="text/css"&gt;<br></br>   @media screen, print {<br></br>   li:before {<br></br>   display: marker;<br></br>   content: url("smiley.gif");<br></br>   li:after {<br></br>   display: marker;<br></br>   content: url("sad.gif");<br></br>   }<br></br>   }<br></br>   &lt;/style&gt;<br></br>   &lt;/head&gt;<br></br>   &lt;body&gt;<br></br>   &lt;ul&gt;<br></br>   &lt;li&gt;первый элемент списка располагается первым<br></br>   &lt;li&gt;второй элемент списка располагается вторым<br></br>   &lt;/ul&gt;<br></br>   &lt;/body&gt;<br></br>   &lt;/html&gt;<br></br>   В результате обработки браузером документа из листинга 9.10 вы получите следующее:<br></br>   :-) первый элемент списка располагается первым :-(<br></br>   :-) второй элемент списка располагается вторым :-(<br></br>   Рассмотрим еще один пример, где маркеры используются для нумерации абзацев-заметок (листинг 9.11).<br></br><h5 class="subtitle"><b>Листинг 9.11.</b> Маркеры, используемые для создания нумерованных заметок</h5>   &lt;html&gt;<br></br>   &lt;head&gt;<br></br>   &lt;title&gt;глава 9. Маркеры, использующиеся для создания нумерованных заметок&lt;/title&gt;<br></br>   &lt;style type="text/css"&gt;<br></br>   p { margin-left: 12 em; }<br></br>   @media screen, print {<br></br>   p.note:before {<br></br>   display: marker;<br></br>   content: url("note.gif")<br></br>   "Примечание " counter(note-counter) ":";<br></br>   counter-increment: note-counter;<br></br>   text-align: left;<br></br>   width: 10em;<br></br>   }<br></br>   }<br></br>   &lt;/style&gt;<br></br>   &lt;/head&gt;<br></br>   &lt;body&gt;<br></br>   &lt;p&gt;Это первый абзац в данном документе.&lt;/p&gt;<br></br>   &lt;p class="note"&gt;Это очень короткий документ.&lt;/p&gt;<br></br>   &lt;p&gt;Конец.&lt;/p&gt;<br></br>   &lt;/body&gt;<br></br>   &lt;/html&gt;<br></br>   В результате выполнения документа из листинга 9.11 получим следующее:<br></br>   Это первый абзац в данном документе.<br></br>   Примечание 1: Это очень короткий документ.<br></br>   Конец.<br></br>   Вы также можете изменять расстояние между ближайшими краями границ блока маркера и связанного с ним главного блока, используя свойство marker-offset. В качестве значения можно использовать служебное слово auto. Тогда браузер задаст расстояние автоматически.<br></br>   Разберем это свойство на примере. Создадим страницу, в которой маркеры используются для добавления точек после каждого элемента нумерованного списка, и зададим область для маркеров списка шириной 8 em (листинг 9.12).<br></br><h5 class="subtitle"><b>Листинг 9.12.</b> Пример маркера</h5>   &lt;html&gt;<br></br>   &lt;head&gt;<br></br>   &lt;title&gt;Глава 9. Пример маркера&lt;/title&gt;<br></br>   &lt;style type="text/css"&gt;<br></br>   p { margin-left: 8em } /* Создаем пространство для счетчиков 8 em */<br></br>   li:before {<br></br>   display: marker;<br></br>   marker-offset: 3em;<br></br>   content: counter(mycounter, upper-roman) ".";<br></br>   counter-increment: mycounter;<br></br>   }<br></br>   &lt;/style&gt;<br></br>   &lt;/head&gt;<br></br>   &lt;body&gt;<br></br>   &lt;p&gt; Это предыдущий абзац ...<br></br>   &lt;ol&gt;<br></br>   &lt;li&gt; Это первый элемент списка.<br></br>   &lt;li&gt; Это второй элемент списка.<br></br>   &lt;li&gt; Это третий элемент списка.<br></br>   &lt;/ol&gt;<br></br>   &lt;p&gt; Это следующий абзац ...<br></br>   &lt;/body&gt;<br></br>   &lt;/html&gt;<br></br>   В результате получим следующее:<br></br>   Это предыдущий абзац ...<br></br>   I. Это первый элемент списка.<br></br>   II. Это второй элемент списка.<br></br>   III. Это третий элемент списка.<br></br>   Это следующий абзац ...<br></br>   Теперь вы сможете справиться с любым списком и при этом оформить его так, что он не будет выглядеть «серо» на фоне всей страницы.<br></br></div></div><h2 id="idm139732187792464">9.4. Таблицы
</h2><div style="text-align: justify" class="hsection2"><div style="text-align: justify" class="section3">   Таблицы – одно из главных средств расположения элементов на странице. Они позволяют расположить меню рядом с текстом и могут подстраиваться под монитор компьютера клиента.<br></br>
</div><h3 id="idm139732187793616">Селекторы столбцов
</h3><div style="text-align: justify" class="hsection3">   В CSS ячейки таблицы могут принадлежать одному из двух типов групп: строкам или столбцам. В HTML ячейки являются наследующими элементами строк, а не столбцов. Тем не менее на некоторые свойства ячеек оказывают влияние свойства столбцов.<br></br>   Ниже приведен список свойств, которые могут быть заданы столбцам таблицы и, соответственно, влиять на вид ячеек.<br></br>   • border – задает различные свойства границы столбцам, но работает, только если для свойства border-collapse в элементе таблицы установлено значение collapse.<br></br>   • background – определяет фон для ячеек в столбце.<br></br>   • width – определяет ширину столбца.<br></br>   • visibility – если свойству столбца visibility присвоено значение collapse, то ни одна ячейка столбца не представляется, а ячейки, охватывающие другие столбцы, урезаются. Кроме того, ширина таблицы уменьшается на ширину этого столбца. Другие значения свойства visibility не имеют влияния на отображение.<br></br>   Рассмотрим несколько строк CSS-кода, определяющих свойства столбцов:<br></br>   col.totals { background: blue }<br></br>   table { table-layout: fixed }<br></br>   col.totals { width: 5em }<br></br>   Первое правило выделяет столбец класса totals синим цветом, а последние два правила указывают способ фиксирования размера столбца, используя фиксированное расположение.<br></br></div><h3 id="idm139732187798864">Положение и выравнивание заголовка
</h3><div style="text-align: justify" class="hsection3">   Первым в данном разделе рассмотрим свойство caption-side. Оно определяет положение поля заголовка относительно поля таблицы. Вот список его значений, указывающих, что поле заголовка располагается:<br></br>   • top – над полем таблицы;<br></br>   • bottom – ниже поля таблицы;<br></br>   • left – слева от поля таблицы;<br></br>   • right – справа от поля таблицы.<br></br>   Заголовки, расположенные ниже или выше элемента TABLE, форматируются подобно элементам блока, находящимся ниже или выше таблицы, с тем исключением, что они:<br></br>   • наследуют наследуемые свойства таблицы;<br></br>   • не считаются блоками для элементов compact или run-in, которые могут предшествовать таблице.<br></br>   Заголовок, находящийся ниже или выше поля таблицы, действует как блок для вычисления ширины; она вычисляется относительно ширины содержащего блока таблицы.<br></br>   Для заголовка, располагающегося в правой или левой части поля таблицы, значение свойства width, отличное от auto, явным образом устанавливает ширину, в то время как значение auto предписывает браузеру выбрать ширину самому. Значение, выбранное браузером автоматически, может колебаться от «самого узкого блока» до «одной строки», поэтому рекомендуется не указывать значение auto для установки ширины левого и правого заголовка.<br></br>   Для выравнивания содержимого заголовка по горизонтали внутри поля заголовка используйте свойство text-align. Для вертикального выравнивания левого и правого блока заголовка относительно блока таблицы используйте свойство vertical-align. В этом случае смысл имеют только значения top, middle и bottom. Все другие значения данного свойства будут трактоваться браузером как top.<br></br>   Чтобы лучше разобраться с данным свойством, рассмотрим пример.<br></br>   caption {<br></br>   caption-side: bottom;<br></br>   width: auto;<br></br>   text-align: left<br></br>   }<br></br>   В этом примере свойство caption-side определяет расположение заголовка под таблицей. Заголовок может иметь ширину родительского элемента таблицы, а текст заголовка будет выровнен по левому краю.<br></br>   Теперь рассмотрим более сложный пример.<br></br>   body {<br></br>   margin-left: 8em<br></br>   }<br></br>   table {<br></br>   margin-left: auto;<br></br>   margin-right: auto<br></br>   }<br></br>   caption {<br></br>   caption-side: left;<br></br>   margin-left: -8em;<br></br>   width: 8em;<br></br>   text-align: right;<br></br>   vertical-align: bottom<br></br>   }<br></br>   В этом примере показан способ помещения заголовка в левое поле. Таблица выровнена по центру за счет задания для левого и правого полей значения auto, а весь блок с таблицей и заголовком сдвинут в левое поле на расстояние, равное ширине заголовка.<br></br></div><h3 id="idm139732187764048">Слои и прозрачность таблицы
</h3><div style="text-align: justify" class="hsection3">   Чтобы определить фон каждой ячейки таблицы, браузер разбивает различные элементы таблицы на шесть слоев (рис. 9.3). Фон элемента, установленный в одном из слоев, будет видим, только если у расположенных выше слоев фон прозрачный.<br></br><div class="wrap_pict"><div style="text-align: center;"><img src="i_107.png" alt=""></img></div>   <b>Рис. 9.3.</b> Схема слоев таблицы<br></br></div><br></br>   Рассмотрим каждый слой таблицы подробно снизу вверх.<br></br>   1. Самый нижний слой представляет собой одну плоскость и сам блок таблицы. Как и все блоки, он может быть прозрачным.<br></br>   2. Следующий слой содержит группы столбцов. Они по высоте равны самой таблице, но не обязательно занимают всю ее ширину.<br></br>   3. В верхней части групп столбцов находятся области, представляющие блоки столбцов. Как и группы, столбцы по высоте равны самой таблице, но не всегда занимают всю ее ширину.<br></br>   4. Далее следует слой, содержащий группы строк. Каждая группа строк имеет ширину, равную ширине таблицы. Вместе взятые, группы полностью занимают таблицу сверху вниз.<br></br>   5. Предпоследний слой содержит строки. Строки также занимают всю таблицу.<br></br>   6. Самый верхний слой содержит собственно ячейки. Как показано на рис. 9.3, хотя все строки и содержат одинаковое количество ячеек, не в каждой ячейке имеется содержимое. «Пустые» ячейки считаются прозрачными, поэтому через них будут видны нижние слои.<br></br>   В качестве примера будем использовать страницу с таблицей стилей, описываемую в листинге 9.13. В этом примере первая строка содержит четыре ячейки, вторая – ни одной, поэтому через нее виден фон таблицы, за исключением тех случаев, когда ячейка первой строки занимает и вторую строку.<br></br><h5 class="subtitle"><b>Листинг 9.13.</b> Форматирование таблиц средствами CSS</h5>   &lt;html&gt;<br></br>   &lt;head&gt;<br></br>   &lt;style type="text/css"&gt;<br></br>   table { background: #ff0; border-collapse: collapse }<br></br>   td { background: red; border: double black }<br></br>   &lt;/style&gt;<br></br>   &lt;/head&gt;<br></br>   &lt;body&gt;<br></br>   &lt;p&gt;<br></br>   &lt;table&gt;<br></br>   &lt;tr&gt;<br></br>   &lt;td&gt; 1<br></br>   &lt;td rowspan="2"&gt; 2<br></br>   &lt;td&gt; 3<br></br>   &lt;td&gt; 4<br></br>   &lt;/tr&gt;<br></br>   &lt;tr&gt;&lt;td&gt;&lt;/td&gt;&lt;/tr&gt;<br></br>   &lt;/table&gt;<br></br>   &lt;/body&gt;<br></br>   &lt;/html&gt;<br></br><br></br>   Документ, представленный в листинге 9.13, будет выглядеть, как показано на рис. 9.4.<br></br><div class="wrap_pict"><div style="text-align: center;"><img src="i_108.png" alt=""></img></div>   <b>Рис. 9.4.</b> Таблица с тремя пустыми ячейками в нижней строке<br></br></div><br></br>   Теперь рассмотрим, как можно изменять ширину таблицы свойствами CSS.<br></br></div><h3 id="idm139732187746640">Ширина таблицы
</h3><div style="text-align: justify" class="hsection3">   Для управления отображением ширины таблицы при размещении ее ячеек, строк и столбцов используется свойство table-layout. Оно может принимать следующие значения.<br></br>   • fixed – горизонтальное положение таблицы не зависит от содержимого ячеек; оно зависит только от ширины таблицы, ширины столбцов и расстояния между границами или ячейками. Ширина таблицы может указываться явным образом с помощью свойства width либо может быть равной auto.<br></br>   • auto – браузер автоматически размещает таблицу. Ширина таблицы задается шириной столбцов и расстоянием между границами.<br></br></div><h3 id="idm139732187748432">Высота таблицы
</h3><div style="text-align: justify" class="hsection3">   Высоту таблицы можно задать, используя свойство height для элемента TABLE. Как и для ширины, вы можете оставить выбор высоты браузеру, используя значение auto, либо задать значение числом и указать единицу измерения.<br></br>   Используя свойство height, вы также можете задавать высоту поля элемента table-row, то есть высоту строк.<br></br></div><h3 id="idm139732187749840">Вертикальное выравнивание
</h3><div style="text-align: justify" class="hsection3">   Свойство vertical-align каждой ячейки таблицы определяет вертикальное выравнивание ее содержимого. Содержимое каждой ячейки имеет базовую линию, верх, середину и низ. В контексте таблиц свойство vertical-align может принимать следующие значения.<br></br>   • baseline – базовая линия ячейки располагается на той же высоте, что и базовая линия первой строки, занимаемой ячейкой.<br></br>   • top – верх блока ячейки совпадает с верхом первой строки, занимаемой ячейкой.<br></br>   • bottom – низ блока ячейки совпадает с низом последней строки, занимаемой ячейкой.<br></br>   • middle – середина ячейки совпадает с серединой строк, занимаемых ячейкой.<br></br>   • sub, super, text-top, text-bottom – эти значения не применяются к ячейкам. В случае их использования ячейка выравнивается по базовой линии.<br></br></div><h3 id="idm139732187752784">Горизонтальное выравнивание
</h3><div style="text-align: justify" class="hsection3">   Горизонтальное выравнивание содержимого ячейки устанавливается свойством text-align. Если в качестве значения свойства text-align для нескольких ячеек в столбце задана строка текста, то содержимое этих ячеек выравнивается относительно вертикальной оси. Начало строки соприкасается с этой осью. Расположение строки слева или справа относительно оси определяется направлением текста. Если значением свойства text-align для ячейки таблицы является строка, но этой строки нет в содержимом ячейки, то конец содержимого соприкасается с вертикальной осью выравнивания.<br></br>   Это станет понятно из примера. Создадим следующую таблицу стиля:<br></br>   td { text-align: "." }<br></br>   td:before { content: "$" }<br></br>   Создадим также HTML-документ, который имеет следующий фрагмент кода:<br></br>   &lt;table&gt;<br></br>   &lt;col width="40"&gt;<br></br>   &lt;tr&gt; &lt;th&gt;Плата за междугородние звонки<br></br>   &lt;tr&gt; &lt;td&gt; 1.30<br></br>   &lt;tr&gt; &lt;td&gt; 2.50<br></br>   &lt;tr&gt; &lt;td&gt; 10.80<br></br>   &lt;tr&gt; &lt;td&gt; 111.01<br></br>   &lt;tr&gt; &lt;td&gt; 85.<br></br>   &lt;tr&gt; &lt;td&gt; 90<br></br>   &lt;tr&gt; &lt;td&gt; .05<br></br>   &lt;tr&gt; &lt;td&gt; .06<br></br>   &lt;/table&gt;<br></br>   Тогда согласно этой таблице стилей цифры, обозначающие доллары, будут выровнены относительно десятичной точки. Здесь также используется псевдоэлемент: before для вставки значка доллара перед каждой цифрой в строке.<br></br>   Браузер клиента представит на странице эту таблицу следующим образом:<br></br>   Плата за междугородние звонки<br></br>   $1.30<br></br>   $2.50<br></br>   $10.80<br></br>   $111.01<br></br>   $85.<br></br>   $90<br></br>   $.05<br></br>   $.06<br></br></div><h3 id="idm139732187732304">Динамические эффекты строк и столбцов
</h3><div style="text-align: justify" class="hsection3">   Свойство visibility для элементов строк, групп строк, столбцов и групп столбцов может принимать значение collapse. В результате вся строка или весь столбец не будет отображаться и место, которое бы он занимал, будет доступно для размещения содержимого. Это позволяет динамически удалять строки или столбцы, не меняя расположения таблицы.<br></br>   Данное свойство удобно использовать, если приходится добавлять на страницу некий блок, который должен, во-первых, обтекаться текстом, а во-вторых, быть выделенным фоном и границей.<br></br></div><h3 id="idm139732187733712">Границы
</h3><div style="text-align: justify" class="hsection3">   Для задания границ вы можете использовать следующие свойства: border, border-collapse и border-spacing.<br></br>   Свойство border задает стиль границы и размер. Стили границ будут подробно рассмотрены в следующих разделах. Размер границы задается целым числом и с указанием единицы измерения.<br></br>   Свойство border-collapse позволяет выбрать модель границ таблицы. Значение separate задает модель с отдельными границами. Значение collapse задает модель с пересекающимися границами.<br></br>   Свойство border-spacing может принимать сразу два значения длины. Заданная длина обозначает расстояние между границами соседних ячеек. Если указана одна длина, то она определяет расстояние по горизонтали и по вертикали. Если указаны оба значения, то первое определяет расстояние по горизонтали, а второе – по вертикали. Естественно, длины не могут быть отрицательными.<br></br>   Рассмотрим простой пример задания границы для таблиц на странице:<br></br>   table { border: outset 10pt;<br></br>   border-collapse: separate;<br></br>   border-spacing: 15pt }<br></br>   td { border: inset 5pt }<br></br>   Этот CSS-код создаст вокруг таблицы выпуклую границу размером 10 пунктов. Поскольку задано значение separate свойства border-collapse, то для ячеек будут созданы вдавленные границы размером 5 пунктов. Расстояние между ячейками будет составлять 15 пунктов.<br></br></div><h3 id="idm139732187738576">Стили границ
</h3><div style="text-align: justify" class="hsection3">   Помимо размера, CSS предоставляет возможность задавать стиль границ таблицы. Для этого используется свойство border-style. Рассмотрим список значений данного свойства и их описания.<br></br>   • none – граница отсутствует.<br></br>   • hidden – аналогично значению none, но в модели с пересекающимися границами имеет приоритет над любыми другими границами.<br></br>   • dotted – граница представляется рядом точек.<br></br>   • dashed – граница представляется рядом коротких линейных сегментов.<br></br>   • solid – граница представляется единым сегментом линии.<br></br>   • double – граница представляется двумя сплошными линиями. Сумма толщины двух линий и расстояния между ними равна значению border-width.<br></br>   • groove – граница выглядит вдавленной.<br></br>   • ridge – в противоположность groove, граница выглядит выпуклой.<br></br>   • inset – в модели с отдельными границами весь блок выглядит вдавленным. В модели с пересекающимися границами это значение дает тот же эффект, что и значение groove.<br></br>   • outset – в модели с отдельными границами весь блок выглядит выпуклым. В модели с пересекающимися границами это значение дает тот же эффект, что и значение ridge.<br></br>   Вы можете поэкспериментировать с различными значениями и посмотреть, как их отобразит ваш браузер. Подробнее про границы будет рассказано в разд. 9.7.<br></br></div><h3 id="idm139732340549328">Пустые ячейки
</h3><div style="text-align: justify" class="hsection3">   CSS позволяет определить, отображать ли границы пустых ячеек. Вы можете задать отображение пустых ячеек, используя свойство CSS empty-cells. Это свойство управляет представлением границ вокруг ячеек, не имеющих видимого содержимого. Считается, что видимого содержимого нет в пустых ячейках и ячейках, для которых свойству visibility присвоено значение hidden.<br></br>   Чтобы все ячейки таблицы (в том числе и пустые) имели границы, можно использовать следующий CSS-код:<br></br>   table { empty-cells: show }<br></br></div></div><h2 id="idm139732340551248">9.5. Интерфейс пользователя
</h2><div style="text-align: justify" class="hsection2"><div style="text-align: justify" class="section3">   Таблицы стилей позволяют управлять и интерфейсом пользователя, то есть, например, задавать вид указателя мыши или определять стили шрифта и оформления, установленные по умолчанию на компьютере клиента.<br></br>
</div><h3 id="idm139732340552400">Указатели мыши
</h3><div style="text-align: justify" class="hsection3">   Средства CSS позволяют задавать указатель мыши свойством cursor. Данное свойство может принимать следующие значения.<br></br>   • auto – браузер определяет отображаемый указатель исходя из контекста.<br></br>   • crosshair – простое перекрестие (напоминающее символ +).<br></br>   • default – указатель, используемый в данной операционной системе по умолчанию. Зачастую представляется в виде стрелки.<br></br>   • pointer – указатель, обозначающий ссылку.<br></br>   • move – указатель, определяющий объект, который можно переместить.<br></br>   • e-resize, ne-resize, nw-resize, n-resize, se-resize, sw-resize, s-resize, w-resize – указатель, определяющий перемещение некоторого края. Например, при перемещении, начинающемся с правого нижнего угла блока, используется указатель se-resize. Первые буквы в этом значении – это первые буквы частей света South и East.<br></br>   • text – указатель, используемый при выделении текста. Зачастую представляется в виде вертикальной линии |.<br></br>   • wait – указатель, показывающий занятость программы, когда пользователю необходимо подождать. Зачастую представляется в виде циферблата или песочных часов.<br></br>   • help – указатель, означающий, что для объекта, на который он указывает, имеется справочная информация. Зачастую представляется в виде вопросительного знака или воздушного шара.<br></br>   • hand – указатель представляет собой «руку». Зачастую такой указатель используется для ссылок.<br></br>   • uri_адрес_файла – при данном значении браузер пользователя загружает файл указателя, задаваемого этим URL-адресом.<br></br>   Если браузеру не удается обработать указатель мыши, расположенный первым в списке указателей, то он попытается обработать второй, третий и т. д. Если браузеру не удается обработать ни одного указателя, заданного в таблице стилей, он будет использовать общий указатель, расположенный в конце списка. Например:<br></br>   p { cursor : url(«mything.cur»), url(«second.csr»), text; }<br></br>   В этом примере при наведении на содержимое элемента P указатель мыши станет таким, какой задан в файле mything.cur. Если браузер не сможет загрузить данный файл указателя, он попробует загрузить файл second.csr и отобразить указатель, изображенный в этом файле. Если и этот файл окажется недоступным, браузер отобразит указатель, используемый при выделении текста.<br></br></div><h3 id="idm139732340559312">Пользовательские настройки цветов
</h3><div style="text-align: justify" class="hsection3">   Чтобы цветовая схема вашей страницы отвечала цветовой схеме операционной системы пользователя, вы можете использовать одно из определенных в CSS значений, задающих цвета следующих элементов.<br></br>   • ActiveBorder – граница активного окна.<br></br>   • ActiveCaption – заголовок активного окна.<br></br>   • AppWorkspace – фон мультидокументного интерфейса.<br></br>   • Background – фон Рабочего стола.<br></br>   • ButtonFace – «лицевая» сторона объемных элементов.<br></br>   • ButtonHighlight – насыщенная тень для объемных элементов (ребер, находящихся в тени).<br></br>   • ButtonShadow – тень объемных элементов.<br></br>   • ButtonText – текст на кнопках.<br></br>   • CaptionText – текст в заголовках, в элементах управления размерами и элементах полосы прокрутки.<br></br>   • GrayText – отключенный (недоступный) текст. Если текущий драйвер дисплея не поддерживает насыщенно-серый цвет, то для этого цвета устанавливается значение #0 0 0.<br></br>   • Highlight – объекты, выделяемые в элементах управления.<br></br>   • HighlightText – текст в объектах, выделенных в элементах управления.<br></br>   • InactiveBorder – граница неактивного окна.<br></br>   • InactiveCaption – заголовок неактивного окна.<br></br>   • InactiveCaptionText – текст в неактивном заголовке.<br></br>   • InfoBackground – фон всплывающей подсказки.<br></br>   • InfoText – текст всплывающей подсказки.<br></br>   • Menu – фон меню.<br></br>   • MenuText – текст в меню.<br></br>   • Scrollbar – полоса прокрутки.<br></br>   • ThreeDDarkShadow – насыщенная тень для объемных элементов.<br></br>   • ThreeDFace – «лицевая» сторона объемных элементов.<br></br>   • ThreeDHighlight – выделенные объемные элементы.<br></br>   • ThreeDLightShadow – объемные элементы (ребра, расположенные «лицом» к источнику света).<br></br>   • ThreeDShadow – насыщенная тень для объемных элементов.<br></br>   • Window – фон окна.<br></br>   • WindowFrame – рамка окна.<br></br>   • WindowText – текст в окне.<br></br>   Рассмотрим CSS-код:<br></br>   body { background: Background; }<br></br>   При использовании данной таблицы стилей в HTML-документе цвет фона страницы будет такой же, как цвет Рабочего стола пользователя.<br></br></div><h3 id="idm139732340523472">Пользовательские настройки шрифтов
</h3><div style="text-align: justify" class="hsection3">   Наряду с заданием пользовательских настроек цвета вы можете указывать пользовательские настройки шрифтов. Рассмотрим список доступных значений, относящихся к системным шрифтам, и их описание.<br></br>   • caption – используется для заголовков элементов управления (кнопок, выпадающих меню и т. д.).<br></br>   • icon – применяется для обозначения пиктограмм.<br></br>   • menu – используется в меню (например, в выпадающих меню и списках меню).<br></br>   • message-box – применяется в диалоговых окнах.<br></br>   • small-caption – используется для обозначения небольших элементов управления.<br></br>   • status-bar – применяется в панелях, описывающих статус окон.<br></br>   Рассмотрим пример:<br></br>   h1 { font: caption; }<br></br>   Приведенный выше фрагмент таблицы стилей задаст для элемента H1 шрифт, используемый для заголовков элементов управления операционной системой пользователя.<br></br></div><h3 id="idm139732340528208">Контуры
</h3><div style="text-align: justify" class="hsection3">   Иногда при создании страницы вам может понадобиться акцентировать внимание пользователя на некотором визуально отображаемом объекте, например на кнопке, активном поле формы, месте для графического объекта и т. п. Используя CSS, такие объекты можно окружить контуром, отличие которого от границ состоит в следующем:<br></br>   • контуры вообще не занимают места;<br></br>   • они могут иметь непрямоугольную форму.<br></br>   Для задания контура используются свойства outline-width, outline-style и outline-color.<br></br>   Для более компактной записи можно использовать свойство outline. Это сокращенное свойство, которое устанавливает значения для всех трех свойств outline-style, outline-width и outline-color. Рассмотрим их подробнее.<br></br>   • outline-style – задает стиль контура и может принимать такие же значения, как и свойство границы border-style, за исключением значения hidden: none, dotted, dashed, solid, double, groove, ridge, inset, outset.<br></br>   • outline-width – определяет размер контура.<br></br>   • outline-color – принимает те же значения, что и ключевое слово invert, осуществляющее инверсию цветов, используемых для отображения пикселов на экране. Этот традиционный прием используется для того, чтобы независимо от цвета фона контур был всегда виден.<br></br>   Поскольку использование контура не приводит к переформатированию браузером HTML-страницы, вы также можете применять его для выделения активного элемента либо элемента, на котором располагается фокус. Рассмотрим следующий пример:<br></br>   :focus { outline: thick solid black }<br></br>   :active { outline: thick solid red }<br></br>   Если в данной таблице стилей в начале строк задать элемент HTML-страницы, то всякий раз, когда элемент будет находиться в фокусе, вокруг него будет отображаться толстая линия черного цвета, а когда элемент будет активизирован, вокруг него будет отображаться линия красного цвета.<br></br></div></div><h2 id="idm139732340484688">9.6. Поля и отступы
</h2><div style="text-align: justify" class="hsection2"><div style="text-align: justify" class="section3">   В этом разделе мы разберем важный момент при создании веб-страниц – задание полей и отступов. Итак, начнем с полей.<br></br>
</div><h3 id="idm139732340485840">Свойства полей
</h3><div style="text-align: justify" class="hsection3">   Как отмечалось выше, отображая каждый элемент, браузер как бы создает прямоугольный блок, внутри которого и размещается содержимое элемента. Свойства полей определяют ширину области поля блока. Свойство margin позволяет управлять шириной всех четырех полей. Вы также можете указывать одно из следующих свойств: margin-top, margin-right, margin-bottom, margin-left либо некоторые из них в любой комбинации, чтобы задать значения полей только для отдельных сегментов.<br></br>   Все свойства margin могут принимать следующие значения.<br></br>   • «длина» – вы указываете фиксированную ширину поля.<br></br>   • «проценты» – вы указываете значения поля в процентах. Процентное соотношение вычисляется относительно ширины сгенерированного блока.<br></br>   • auto – браузер задает значение поля автоматически. Соответственно, разные браузеры будут использовать разные значения.<br></br>   Рассмотрим пример – небольшое правило CSS, которое устанавливает значение ширины верхнего поля, равное 2 em.<br></br>   H1 { margin-top: 2em }<br></br>   Подробнее разберем сокращенную запись этих свойств – margin. Согласитесь, не очень-то удобно каждый раз набирать следующий код:<br></br>   body {<br></br>   margin-top: 2em;<br></br>   margin-right: 2em;<br></br>   margin-bottom: 2em;<br></br>   margin-left: 2em;<br></br>   }<br></br>   Если свойство margin принимает только одно значение, то оно применяется ко всем полям. Если свойство принимает два значения, то первое применяется к верхнему и нижнему полям, а второе – к правому и левому. Если же оно принимает три значения, то первое значение применяется к верхнему, второе – к левому и правому, а третье – к нижнему полю. И, наконец, если оно принимает четыре значения, то они применяются к верхнему, правому, нижнему и левому сегментам соответственно.<br></br>   Если вы зададите для свойства margin только одно значение, то оно будет применяться ко всем полям. Если вы зададите два значения, то первое будет применяться к верхнему и нижнему, а второе – к правому и левому полям. Если же вы зададите три значения, то первое будет применяться к верхнему, второе – к левому и правому, а третье – к нижнему полю. И, наконец, если зададите четыре значения, то они будут применяться к верхнему, правому, нижнему и левому полям соответственно.<br></br>   Напоследок рассмотрим такой пример:<br></br>   body { margin: 1em 2em 3em }<br></br>   Применив эту таблицу стилей к HTML-документу, вы установите ширину верхнего, правого, нижнего и левого полей страницы равной 1 em, 2 em, 3 em и 2 em соответственно.<br></br></div><h3 id="idm139732340494544">Свойства отступов
</h3><div style="text-align: justify" class="hsection3">   Свойства отступов позволяют задать ширину области отступов блока.<br></br>   Всего существует четыре свойства отступов: padding-top, padding-right, padding-bottom и padding-left, которые задают верхний, правый, нижний и левый отступы соответственно. Эти свойства можно комбинировать. Свойства padding могут принимать одно из следующих значений.<br></br>   • «длина» – вы указываете фиксированную ширину поля.<br></br>   • «проценты» – вы указываете значения поля в процентах. Процентное соотношение вычисляется относительно ширины сгенерированного блока.<br></br>   В отличие от свойств поля свойства отступов не могут принимать отрицательные значения, и для них не может быть задано значение auto. Как и для свойств поля, процентные соотношения, задаваемые для свойств отступов, вычисляются относительно ширины сгенерированного блока.<br></br>   Свойство padding является сокращенной записью всех четырех свойств отступов: padding-top, padding-right, padding-bottom и padding-left. Свойство padding работает, как и сокращенная запись для полей. Если свойство принимает только одно значение, то оно применяется ко всем отступам. Если свойство принимает два значения, то первое применяется к верхнему и нижнему отступам, а второе – к правому и левому отступам. Если оно принимает три значения, то первое значение применяется к верхнему, второе – к левому и правому, а третье – к нижнему отступу. Если свойство принимает четыре значения, то они применяются к верхнему, правому, нижнему и левому отступам соответственно.<br></br>   Фон отступов будет использовать цвет или изображение, заданные этому элементу с помощью свойства background:<br></br>   h1 {<br></br>   background: white;<br></br>   padding: 1em 2em;<br></br>   }<br></br>   В приведенном примере ширина вертикальных (padding-top и padding-bottom) и горизонтальных (padding-right и padding-left) отступов устанавливается равной 1 em и 2 em соответственно. Напомню, что единица измерения em задается относительно размера шрифта элемента: 1 em равен размеру используемого шрифта.<br></br></div></div><h2 id="idm139732340467408">9.7. Границы
</h2><div style="text-align: justify" class="hsection2"><div style="text-align: justify" class="section3">   Для всех элементов страницы вы можете задать границы, а также установить их ширину, цвет и стиль. Начнем изучение границ со свойства ширины.<br></br>
</div><h3 id="idm139732340468560">Ширина границы
</h3><div style="text-align: justify" class="hsection3">   Рассмотрим свойства border-top-width, border-right-width, border-bottom-width, border-left-width, которые определяют значение ширины верхней, правой, нижней и левой границы элемента страницы соответственно. Все свойства, рассматриваемые в данном разделе, могут принимать одно из следующих значений:<br></br>   • thin – тонкая граница;<br></br>   • medium – граница средней толщины;<br></br>   • thick – толстая граница;<br></br>   • «длина» – толщина границы задается числом. Естественно, что число, заданное в качестве значения ширины границы, не может быть отрицательным.<br></br>   Надо отметить, что каждый браузер будет по-своему устанавливать числовое значение для ключевых слов thin, medium и thick, соблюдая такое правило: thin &lt;= medium &lt;= thick.<br></br>   Для границ также существует свойство border-width, позволяющее одновременно установить значения всем четырем свойствам: border-top-width, border-right-width, border-bottom-width и border-left-width. Причем, если задать для border-width только одно значение, оно будет применяться ко всем границам. Если задать два значения, то первое будет применяться к верхней и нижней границам, а второе – к правой и левой. Если указать три значения, то первое значение будет применяться к верхней границе, второе – к левой и правой, а третье – к нижней границе. Если же задать четыре значения, то они будут применяться к верхней, правой, нижней и левой границам соответственно.<br></br>   Рассмотрим три CSS-правила:<br></br>   h1 { border-width: thin } /* тонкая */<br></br>   h1 { border-width: thin thick } /* тонкая толстая */<br></br>   h1 { border-width: thin medium thick } /* тонкая средняя толстая */<br></br>   В первой строке записано правило, которое будет создавать четыре тонкие границы для всех элементов H1. Во второй строке записано правило, которое для элементов H1 создаст тонкую верхнюю и нижнюю границы и толстую правую и левую границы. Третье правило в третьей строке для элементов H1 в документе задаст их верхнюю границу тонкой, левую и правую – средней, а нижнюю – толстой ширины.<br></br>   Теперь рассмотрим, как можно задавать границе цвет.<br></br></div><h3 id="idm139732340474448">Цвет границы
</h3><div style="text-align: justify" class="hsection3">   Как и для ширины, для задания цвета существует четыре свойства для четырех сторон: border-top-color, border-right-color, border-bottom-color, border-left-color и сокращенная запись – border-color. Они задают цвет верхней, правой, левой и нижней границ соответственно. Для всех этих свойств вы можете либо задать значения цвета, либо использовать ключевое слово transparent, которое сделает границу прозрачной. Если задать значение transparent, то граница будет невидимой, даже если она имеет какую-то ширину.<br></br>   Рассмотрим такой пример: p {<br></br>   p {<br></br>   border-width: 2px<br></br>   border-color: blue;<br></br>   }<br></br>   Для элемента P будет создана граница синего цвета размером два пиксела.<br></br></div><h3 id="idm139732340478032">Стиль границы
</h3><div style="text-align: justify" class="hsection3">   Для задания стиля границы используются следующие свойства: border-top-style, border-right-style, border-bottom-style, border-left-style и сокращенная запись – border-style. Свойства стиля границы определяют стиль линии (сплошная, двойная, пунктирная и т. д.), выступающей в качестве границы. Все свойства могут принимать одно из следующих значений.<br></br>   • none – граница отсутствует. В результате значение свойства border-width будет равно нулю.<br></br>   • hidden – подобно значению none, за исключением сценария разрешения конфликтов между границами, используемого для элементов таблицы.<br></br>   • dotted – граница отображается пунктирной линией.<br></br>   • dashed – граница выводится штрихпунктирной линией.<br></br>   • solid – граница отображается сплошной линией.<br></br>   • double – граница выводится двумя непрерывными линиями. Сумма значений ширины двух линий и расстояния между ними равна значению свойства border-width.<br></br>   • groove – граница отображается вдавленной линией.<br></br>   • ridge – противоположно значению groove: граница отображается выпуклой линией.<br></br>   • inset – весь блок выглядит вдавленным.<br></br>   • outset – противоположно значению inset: весь блок выглядит выпуклым.<br></br>   Все границы выводятся поверх фоновой заставки блока. Цвет границ для значений groove, ridge, inset и outset зависит от значения свойства элемента color.<br></br>   Свойство border-style определяет стиль всех четырех сегментов границ. Оно может иметь от одного до четырех значений, каждое из которых присваивается различным сегментам подобно тому, как это происходит у свойства border-width.<br></br>   Рассмотрим такой пример:<br></br>   #xyz { border-style: solid dotted }<br></br>   Здесь горизонтальные сегменты границы будут иметь значение solid, а вертикальные – dotted.<br></br>   Следует отметить, что, поскольку начальное значение стиля границы равно none, она не будет видна до тех пор, пока для нее не будет указан другой стиль.<br></br></div></div><h2 id="idm139732340452816">9.8. Работа с блоками
</h2><div style="text-align: justify" class="hsection2"><div style="text-align: justify" class="section3">   В этом разделе мы рассмотрим работу с блоками и слоями. Изучив данный материал, вы сможете указывать точное место на странице, где по вашему желанию и будут размещаться элементы страницы.<br></br>
</div><h3 id="idm139732340453968">Выбор схемы позиционирования
</h3><div style="text-align: justify" class="hsection3">   Свойства position и float определяют алгоритм позиционирования, используемый для определения положения блока.<br></br>   Рассмотрим значения этого свойства и их интерпретацию браузером.<br></br>   • static – является обычным блоком, позиционируемым в соответствии с нормальным потоком. Свойства left и top не применяются.<br></br>   • relative – положение блока рассчитывается в соответствии с нормальным потоком (оно называется нормальным положением). Затем блок смещается относительно своего нормального положения. Когда для расположения блока применяется модель относительного позиционирования, положение следующего блока рассчитывается так, как будто блок не был смещен.<br></br>   • absolute – положение блока (возможно, и размер) указывается свойствами left, right, top и bottom. Они определяют величину смещения относительно контейнера блока. Абсолютно позиционируемые блоки изымаются из нормального потока. Это значит, что они не влияют на размещение последующих сестринских элементов. Следует заметить, что поля абсолютно позиционируемых блоков не перекрываются никакими другими полями.<br></br>   • fixed – положение блока рассчитывается в соответствии с моделью абсолютного позиционирования, а затем он фиксируется относительно некоторого объекта. При использовании устройств без разбивки блок фиксируется относительно области просмотра (и не перемещается при прокрутке). При использовании устройств с постраничной разбивкой блок фиксируется относительно страницы, даже если она отображается в области просмотра (например, при предварительном просмотре печати). Вы также имеете возможность сделать определение значения fixed аппаратно-зависимым. Например, вы можете сделать так, чтобы на экране блок всегда отображался в верхней части области просмотра, но на печатной странице этого бы не происходило. Два объявления могут быть отделены друг от друга с помощью правила @media, как это показано на примере ниже:<br></br>   @media screen {<br></br>   h1#first { position: fixed }<br></br>   }<br></br>   @media print {<br></br>   h1#first { position: static }<br></br>   }<br></br></div><h3 id="idm139732340459472">Смещение блоков
</h3><div style="text-align: justify" class="hsection3">   Говорится, что элементу была присвоена позиция, если для свойства position устанавливается значение, отличное от static. Позиционированные элементы порождают позиционированные блоки, положение которых регулируется с помощью следующих четырех свойств.<br></br>   • top – задает смещение верхнего сегмента внутренней краевой линии относительно верхнего сегмента краевой линии контейнера блока.<br></br>   • right – определяет смещение правого сегмента внутренней краевой линии влево относительно правого сегмента краевой линии контейнера блока.<br></br>   • bottom – задает смещение нижнего сегмента внутренней краевой линии вверх относительно нижнего сегмента краевой линии контейнера блока.<br></br>   • left – определяет смещение левого сегмента внутренней краевой линии вправо относительно левого сегмента краевой линии контейнера блока.<br></br>   Значения этих четырех свойств имеют следующий смысл.<br></br>   • «длина» – смещение задается фиксированным значением расстояния от исходной краевой линии.<br></br>   • «проценты» – смещение задается процентным соотношением относительно ширины (для свойств left и right) или высоты (для свойств top и bottom) контейнера. Если высота контейнера не указана точно, то есть зависит от высоты содержимого, то процентное соотношение, определяющее значение свойств top и bottom, интерпретируется как значение auto.<br></br>   • auto – результат данного значения зависит от того, какие из свойств, близких по своему содержанию к рассматриваемым, также имеют значение auto.<br></br>   Для абсолютно позиционируемых блоков смещение осуществляется относительно контейнера, а для относительно позиционируемых блоков – относительно внешней краевой линии самого блока. Сначала блоку присваивается положение в нормальном потоке, а затем с использованием названных свойств указывается смещение относительно этого положения.<br></br></div><h3 id="idm139732200053072">Позиционирование перемещаемого объекта
</h3><div style="text-align: justify" class="hsection3">   Перемещаемый объект – это блок, который смещается по строке в левую или правую сторону. Свойство float определяет, будет ли блок перемещен влево, вправо или вообще не будет перемещен. Оно может устанавливаться для элементов, порождающих блоки, не являющиеся абсолютно позиционируемыми. Значения данного свойства имеют следующий смысл.<br></br>   • left – элемент порождает структурный блок, перемещаемый влево. Содержимое выводится вдоль правой стороны блока, начиная с самого верха (за счет свойства clear). Свойство display игнорируется, если ему не присвоено значение none.<br></br>   • right – подобно значению left с той лишь разницей, что содержимое выводится вдоль левой стороны блока, начиная с самого верха.<br></br>   • none – блок не перемещается.<br></br>   Следующее правило перемещает все блоки, порожденные элементом IMG с атрибутом class="icon", влево и устанавливает значение ширины поля равным нулю:<br></br>   IMG.icon {<br></br>   float: left;<br></br>   margin-left: 0;<br></br>   }<br></br>   Рассмотрим исходный HTML-документ и таблицу стилей на примере из листинга 9.14.<br></br><h5 class="subtitle"><b>Листинг 9.14.</b> Пример перемещаемого объекта</h5>   &lt;html&gt;<br></br>   &lt;head&gt;<br></br>   &lt;title&gt;Глава 9. Пример перемещаемого объекта&lt;/title&gt;<br></br>   &lt;style type="text/css"&gt;<br></br>   img { float: left }<br></br>   body, p, img { margin: 2em }<br></br>   &lt;/style&gt;<br></br>   &lt;/head&gt;<br></br>   &lt;body&gt;<br></br>   &lt;p&gt;&lt;img src="img.gif" alt="Данный рисунок иллюстрирует перемещаемые объекты"&gt;<br></br>   Пример текста, у которого нет другого...<br></br>   &lt;/body&gt;<br></br>   &lt;/html&gt;<br></br>   Блок, порожденный элементом IMG, перемещается влево. Следующее за ним содержимое форматируется справа от него, начиная с той же строки, на которой находится он сам. Присутствие перемещаемого объекта влияет на то, что, пока линейные блоки находятся справа от него, они укорачиваются, но как только они достигают его конца, сразу восстанавливают свою исходную ширину (равную ширине контейнера, назначенного элементом P). Приведенный документ может быть отформатирован следующим образом:<br></br>   &lt;body&gt;<br></br>   &lt;p&gt;Произвольный текст,<br></br>   &lt;img src="img.gif" alt="Данный рисунок иллюстрирует перемещаемые объекты"&gt;<br></br>   у которого нет другого...<br></br>   &lt;/body&gt;<br></br>   Это объясняется тем, что содержимое, находящееся слева от перемещаемого объекта, заменяется им, а само отображается справа от него.<br></br></div><h3 id="idm139732200066384">Фиксированное позиционирование
</h3><div style="text-align: justify" class="hsection3">   Фиксированное позиционирование – разновидность абсолютного позиционирования. Единственным его отличием является то, что контейнер определяется областью просмотра. Для устройств без разбивки фиксированные блоки не перемещаются при прокрутке документа. В этом отношении они схожи с фиксированными фоновыми изображениями. Для устройств с постраничной разбивкой блоки с фиксированным положением повторяются на каждой странице. Это может оказаться удобным, например, при размещении подписей в нижней части каждой страницы.<br></br>   Вы можете использовать фиксированное позиционирование для создания презентации в виде совокупности кадров. Рассмотрим один из примеров такой презентации, представленный на рис. 9.5.<br></br><div class="wrap_pict"><div style="text-align: center;"><img src="i_109.png" alt=""></img></div>   <b>Рис. 9.5.</b> Фиксированное позиционирование<br></br></div><br></br>   Подобного эффекта можно достичь с помощью HTML-кода и правил стиля, представленных в листинге 9.15.<br></br><h5 class="subtitle"><b>Листинг 9.15.</b> Создание кадров в CSS</h5>   &lt;html&gt;<br></br>   &lt;head&gt;<br></br>   &lt;title&gt;Глава 9. Создание кадров в CSS&lt;/title&gt;<br></br>   &lt;style type="text/css"&gt;<br></br>   body { height: 8.5in } /* будет использовано ниже для определения */<br></br>   /* процентных соотношений, задающих значение */<br></br>   /* высоты элемента */<br></br>   #header {<br></br>   position: fixed;<br></br>   width: 100%;<br></br>   height: 15%;<br></br>   top: 0;<br></br>   right: 0;<br></br>   bottom: auto;<br></br>   left: 0;<br></br>   }<br></br>   #sidebar {<br></br>   position: fixed;<br></br>   width: 10em;<br></br>   height: auto;<br></br>   top: 15%;<br></br>   right: auto;<br></br>   bottom: 100px;<br></br>   left: 0;<br></br>   }<br></br>   #main {<br></br>   position: fixed;<br></br>   width: auto;<br></br>   height: auto;<br></br>   top: 15%;<br></br>   right: 0;<br></br>   bottom: 100px;<br></br>   left: 10em;<br></br>   }<br></br>   #footer {<br></br>   position: fixed;<br></br>   width: 100%;<br></br>   height: 100px;<br></br>   top: auto;<br></br>   right: 0;<br></br>   bottom: 0;<br></br>   left: 0;<br></br>   }<br></br>   &lt;/style&gt;<br></br>   &lt;/head&gt;<br></br>   &lt;body&gt;<br></br>   &lt;div id="header"&gt; ... &lt;/div&gt;<br></br>   &lt;div id="sidebar"&gt; ... &lt;/div&gt;<br></br>   &lt;div id="main"&gt; ... &lt;/div&gt;<br></br>   &lt;div id="footer"&gt; ... &lt;/div&gt;<br></br>   &lt;/body&gt;<br></br>   &lt;/html&gt;<br></br><br></br>   Попробуйте нарисовать на листе бумаги свою разметку страницы, а потом создать ее, используя приобретенные навыки.<br></br></div><h3 id="idm139732200008528">Определение позиционного уровня
</h3><div style="text-align: justify" class="hsection3">   Для размещенного блока вы можете задать позиционный уровень, в текущем контексте используя свойство z-index. Это свойство может принимать такие значения.<br></br>   • «целое число» – является значением позиционного уровня сгенерированного блока в текущем контексте. Блок также назначает локальный позиционный контекст с позиционным уровнем 0.<br></br>   • auto – позиционный уровень блока в текущем контексте совпадает с позиционным уровнем родительского блока.<br></br>   Рассмотрим пример, приведенный в листинге 9.16. В этом примере позиционные уровни блоков именуются с использованием атрибута id. Причем позиционный уровень text2 наследуется от корневого блока. Другие уровни указываются свойством z-index.<br></br><h5 class="subtitle"><b>Листинг 9.16.</b> Позиционирование вдоль оси z</h5>   &lt;html&gt;<br></br>   &lt;head&gt;<br></br>   &lt;title&gt;Глава 9. Позиционирование вдоль оси z&lt;/title&gt;<br></br>   &lt;style type="text/css"&gt;<br></br>   .pile {<br></br>   position: absolute;<br></br>   left: 2in;<br></br>   top: 2in;<br></br>   width: 3in;<br></br>   height: 3in;<br></br>   }<br></br>   &lt;/style&gt;<br></br>   &lt;/head&gt;<br></br>   &lt;body&gt;<br></br>   &lt;p&gt;<br></br>   &lt;img id="image" class="pile"<br></br>   src="someimg.gif" alt="Картинка"<br></br>   style="z-index: 1"&gt;<br></br>   &lt;div id="text1" class="pile"<br></br>   style="z-index: 3"&gt;<br></br>   Этот текст будет находиться поверх изображения.<br></br>   &lt;/div&gt;<br></br>   &lt;div id="text2"&gt;<br></br>   Этот текст будет находиться под всем остальным.<br></br>   &lt;/div&gt;<br></br>   &lt;div id="text3" class="pile"<br></br>   style="z-index: 2"&gt;<br></br>   Этот текст будет находиться ниже текста text1, но поверх изображения.<br></br>   &lt;/div&gt;<br></br>   &lt;/body&gt;<br></br>   &lt;/html&gt;<br></br>   Данный пример должен пояснить вам понятие прозрачности. По умолчанию блок ведет себя так, что другие блоки, находящиеся за ним, видны сквозь прозрачную область его содержимого. В данном примере каждый блок, накладывающийся на другие блоки, является прозрачным. Такой тип поведения может быть переназначен посредством использования одного из существующих свойств фона.<br></br></div></div><h2 id="idm139732199990992">Резюме
</h2><div style="text-align: justify" class="hsection2">   В данной главе были разобраны основные возможности CSS по оформлению документа. Немного попрактикуйтесь, и с уверенностью можно будет сказать, что вы можете создать и оформить страницу как истинный профессионал.<br></br></div></div><h1 xmlns="http://www.w3.org/1999/xhtml" id="idm139732199992016" class="master">Глава 10<br></br>
Введение в динамический HTML
</h1><div xmlns="http://www.w3.org/1999/xhtml" style="text-align: justify" class="hsection1"><div style="text-align: justify" class="section2">   10.1. Браузер и HTML-документ<br></br>
   10.2. Родительские и дочерние объекты<br></br>
   10.3. Объекты браузера<br></br>
   10.4. Объектная модель документа (DOM)<br></br>
   Язык HTML позволяет создавать только статические веб-страницы, не обеспечивающие интерактивное взаимодействие с посетителем сайта. Однако в HTML-документ можно встраивать <i>сценарии,</i> то есть небольшие программы, написанные на специальном языке, придающие веб-странице динамичность. Одним из таких языков создания сценариев является JavaScript.<br></br>
   JavaScript – это объектно-ориентированный язык программирования. Это означает, что каждый элемент на веб-странице и в окне вашего браузера предстает в виде некоего объекта, доступного для управления из программного кода. Кнопки и поля формы, гиперссылки, изображения, цвет фона веб-страницы и даже само окно браузера с точки зрения программирования на JavaScript являются объектами.<br></br>
   Каждый объект имеет свои свойства, и с ним можно совершать определенные действия. Это позволяет разработчику легко получать доступ к любому элементу веб-страницы. Какие объекты существуют в JavaScript, какими свойствами они обладают и как с помощью сценариев управлять любыми элементами HTML-документа, вы узнаете, прочитав данную главу.<br></br>
</div><h2 id="idm139732199996496">10.1. Браузер и HTML-документ
</h2><div style="text-align: justify" class="hsection2">   При программировании сценариев на JavaScript вы всегда будете использовать объекты в качестве основных инструментальных средств. <b>Объекты</b> – это элементы рабочей области браузера и HTML-документа. Окно браузера, веб-страница, ее фоновый цвет, изображения, текст и все, что находится на странице, – это объекты. В языке JavaScript принято различать объекты браузера и объекты HTML-документа. Рассмотрим их подробнее.<br></br>   Объекты браузера создаются автоматически при загрузке веб-страницы. К ним относятся Window, Navigator, Screen, History, Location. Приведу их краткую характеристику.<br></br>   • Window – дает доступ к окну браузера.<br></br>   • History – дает доступ к истории посещенных ссылок.<br></br>   • Navigator – дает доступ к характеристикам браузера.<br></br>   • Location – содержит текущий URL страницы.<br></br>   • Screen – дает доступ к характеристикам экрана монитора.<br></br>   С точки зрения языка JavaScript окно вашего браузера – это объект Window. Данный объект, в свою очередь, также содержит некоторые объекты – элементы оформления, например строку состояния и полосу прокрутки.<br></br>   Внутри окна браузера размещается веб-страница – HTML-документ. Он является ни чем иным, как объектом Document. В свою очередь, объект Document содержит другие объекты – объекты HTML. Это ссылки, изображения, формы, цвет фона, то есть все, что находится на веб-странице.<br></br>   Итак, в языке JavaScript есть объекты. Их можно сравнить с существительными или предметами. У каждого объекта есть свои <b>свойства,</b> или характеристики. Свойства описывают объекты, как прилагательные описывают существительные. В синтаксисе языка JavaScript свойство любого объекта описывается так: oбъект. свойство. Например, установить желтый цвет фона веб-страницы с помощью языка JavaScript можно следующим образом: document.bgColor = «yellow». В этой конструкции document – объект (веб-страница, HTML-документ), bgColor – свойство объекта Document (фоновый цвет веб-страницы), yellow – значение свойства bgColor.<br></br>   Кроме того, над каждым объектом можно совершать определенные действия. Эти действия принято называть <b>методами.</b> Согласно синтаксису языка JavaScript после метода всегда ставятся скобки по схеме oбъект. мeтoд(). Например, чтобы с помощью языка JavaScript отобразить на веб-странице текст «Hello world!», нужно использовать следующую конструкцию: document. write ("Hello world! "). Здесь document – объект, write() – метод, присущий объекту Document, а выражение в скобках – текст, который должен отобразиться на странице в результате использования метода write(). На языке программирования это называется «метод возвращает результат».<br></br>   В листинге 10.1 представлен пример сценария, демонстрирующий рассмотренные ранее правила записи свойства и метода объекта Document.<br></br><h5 class="subtitle"><b>Листинг 10.1.</b> Свойство и метод объекта Document</h5>   &lt;html&gt;<br></br>   &lt;head&gt;<br></br>   &lt;title&gt;Hello!&lt;/title&gt;<br></br>   &lt;/head&gt;<br></br>   &lt;body&gt;<br></br>   &lt;script language="JavaScript"&gt;<br></br>   document.write("Hello world!"); //пишем текст на странице<br></br>   document.bgColor="yellow" //устанавливаем желтый фон страницы<br></br>   &lt;/script&gt;<br></br>   &lt;/body&gt;<br></br>   &lt;/html&gt;<br></br>   Обратите внимание, что строки внутри сценария отделяются друг от друга точкой с запятой. Данный сценарий меняет фоновый цвет веб-страницы и выводит текст Hello world! (рис. 10.1).<br></br><div class="wrap_pict"><div style="text-align: center;"><img src="i_110.png" alt=""></img></div>   <b>Рис. 10.1.</b> Вывод текста и изменение фонового цвета страницы<br></br></div><br></br>   Таким образом, каждый элемент браузера и HTML-документа для сценария на JavaScript предстает в виде объекта. И каждый такой объект может иметь определенные свойства и методы. Можно сказать, что свойства объектов – это данные, связанные с объектом, методы – функции для обработки данных объекта. При этом у разных объектов разные свойства и методы. Более того, по отношению друг к другу объекты не равноценны. В JavaScript существует строгая иерархия объектов.<br></br></div><h2 id="idm139732199960400">10.2. Родительские и дочерние объекты
</h2><div style="text-align: justify" class="hsection2">   Согласно правилам языка JavaScript все элементы на веб-странице выстраиваются в иерархическую структуру. Каждый объект является потомком объекта более высокого уровня.<br></br>   Иерархия объектов JavaScript показана на схеме, представленной на рис. 10.2.<br></br><div class="wrap_pict"><div style="text-align: center;"><img src="i_111.png" alt=""></img></div>   <b>Рис. 10.2.</b> Иерархия объектов в языке JavaScript<br></br></div><br></br>   Родительским по отношению ко всем остальным объектам является объект Window, расположенный на самом верхнем уровне иерархии. Он представляет окно браузера и создается при его запуске. Свойства объекта Window относятся ко всему окну, в котором отображается документ.<br></br>   Прямыми потомками объекта Window являются объекты Document, History, Location, Frame. Свойства объекта History представляют адреса ранее загруженных веб-страниц. Свойства объекта Location связаны с URL-адресом документа, отображаемого в окне браузера в данный момент, объекта Frame – со специальным способом представления данных в HTML-документе через фреймы.<br></br>   Для каждой веб-страницы создается один объект Document. Он содержит другие объекты – объекты HTML. Это различные элементы веб-страницы: формы, ссылки на другие HTML-документы или локальные ссылки внутри одного документа, объекты, определяющие URL-адрес, и т. д. Все эти объекты являются дочерними для объекта Document.<br></br>   Если в HTML-документе имеются формы, то они также предстают в виде иерархического набора объектов. Сама форма соответствует объекту Form, выступающему дочерним по отношению к объекту Document. Объект Fo rm может включать в себя такие объекты, как кнопки, переключатели, поля для ввода текстовой информации. Все элементы формы являются ее дочерними объектами.<br></br>   Иерархия объектов внутри веб-страницы задается вложенностью HTML-элементов друг в друга и текста внутрь элементов. Объекты, имеющие открывающий и закрывающий теги (элементы-контейнеры), могут иметь дочерние объекты. Текст, атрибуты и элементы типа img, не имеющие закрывающего тега, не могут иметь дочерних объектов.<br></br>   Чтобы лучше понять иерархию объектов в HTML-документе, рассмотрим простейший пример (листинг 10.2).<br></br><h5 class="subtitle"><b>Листинг 10.2.</b> Иерархия объектов в HTML-документе</h5>   &lt;html&gt;<br></br>   &lt;head&gt;<br></br>   &lt;title&gt;javascript objects&lt;/title&gt;<br></br>   &lt;/head&gt;<br></br>   &lt;body&gt;<br></br>   &lt;h1&gt;Объекты JavaScript&lt;/h1&gt;<br></br>   &lt;p&gt;Все элементы этой страницы являются объектами&lt;/p&gt;<br></br>   &lt;/body&gt;<br></br>   &lt;/html&gt;<br></br><br></br>   Разберем этот документ с точки зрения иерархии объектов в языке JavaScript. Самому HTML-документу соответствует объект Document. Он является родителем для всех элементов, расположенных на веб-странице. Эти элементы принято называть <b>узлами,</b> а их иерархию – деревом HTML-документа.<br></br>   Узел HTML является родительским по отношению ко всем остальным элементам веб-страницы. Узел HEAD имеет один дочерний узел TITLE. В свою очередь, узел TITLE имеет свой дочерний узел – текст Объекты JavaScript. BODY имеет два дочерних узла: H1 и P. Текст Все элементы этой страницы являются объектами выступает дочерним по отношению к P. Соответственно, текст Объекты JavaScript является дочерним объектом по отношению к H1.<br></br>   Таким образом, с точки зрения сценария JavaScript браузер и HTML-документ представляются иерархически организованным набором объектов. Обращаясь к свойствам и методам этих объектов, можно выполнять различные операции над окном браузера, загруженным в это окно HTML-документом, а также над отдельными элементами в HTML-документе.<br></br></div><h2 id="idm139732320254288">10.3. Объекты браузера
</h2><div style="text-align: justify" class="hsection2"><div style="text-align: justify" class="section3">   Объекты браузера являются тем интерфейсом, с помощью которого сценарий JavaScript взаимодействует с пользователем и HTML-документом, загруженным в окно браузера, а также с самим браузером. Рассмотрим подробнее каждый из объектов браузера.<br></br>
</div><h3 id="idm139732320255440">Объект Window
</h3><div style="text-align: justify" class="hsection3">   Объект Window представляет собой окно браузера и является родительским по отношению ко всем остальным объектам в языке JavaScript. Он имеет свойства, описывающие размеры окна, расположенные в окне фреймы, имя окна и содержимое строки состояния окна браузера.<br></br>   • defaultStatus – сообщение, отображаемое в строке состояния браузера по умолчанию.<br></br>   • status – текущее сообщение, отображаемое в строке состояния браузера.<br></br>   • frames – массив всех фреймов данного окна.<br></br>   • length – количество фреймов в родительском окне.<br></br>   • name – имя окна, указанное при его открытии методом open(), а также в атрибуте target элемента A или в атрибуте name элемента FORM.<br></br>   • parent – синоним имени окна, относится к окну, содержащему набор фреймов.<br></br>   • self – синоним имени окна, относится к текущему окну.<br></br>   • top – синоним имени окна, относится к окну верхнего уровня.<br></br>   • window – синоним имени окна, относится к текущему окну.<br></br>   • Свойства window и self – синонимы. Вы можете применять любое из них по своему усмотрению, результат будет одинаков.<br></br>   • Свойства frames, length, parent и top применяются, когда в окно загружен HTML-документ с фреймами. Анализируя свойство length, вы можете определить количество фреймов в окне, а с помощью свойства frames (которое является массивом) получить доступ к окнам этих фреймов. Об использовании фреймов в JavaScript было подробно рассказано в гл. 5.<br></br>   • Рассмотрим использование свойств объекта Window на примере сценария из листинга 10.3.<br></br><h5 class="subtitle"><b>Листинг 10.3.</b> Свойство status объекта Window</h5>   &lt;html&gt;<br></br>   &lt;head&gt;<br></br>   &lt;title&gt;Свойство status объекта Window&lt;/title&gt;<br></br>   &lt;/head&gt;<br></br>   &lt;body&gt;<br></br>   &lt;script language="JavaScript"&gt;<br></br>   window.status="ЗДЕСЬ БУДЕТ ВАШ ТЕКСТ!"<br></br>   &lt;/script&gt;<br></br>   &lt;p&gt;Обратите внимание на текст в строке состояния вашего браузера!&lt;/p&gt;<br></br>   &lt;/body&gt;<br></br>   &lt;/html&gt;<br></br>   Сценарий позволяет изменить текст в строке состояния браузера (рис. 10.3).<br></br><div class="wrap_pict"><div style="text-align: center;"><img src="i_112.png" alt=""></img></div>   <b>Рис. 10.3.</b> Изменение текста в строке состояния браузера<br></br></div><br></br>   Этот механизм удобно использовать при работе со ссылками. Вместо того чтобы выводить на экран URL-ссылку, вы можете объяснять пользователю краткое содержание загружаемой по ней веб-страницы.<br></br>   Среди методов, определенных для объекта Window, можно отметить методы, предназначенные для открытия новых окон и закрытия существующих, для отображения на экране диалоговых панелей с сообщениями и методы для установки таймера.<br></br>   • alert() – отображение диалоговой панели Alert (Предупреждение) с сообщением и кнопкой OK.<br></br>   • close() – закрытие окна.<br></br>   • confirm() – отображение диалоговой панели Confirm (Подтверждение) с кнопками OK и Отмена.<br></br>   • prompt() – отображение диалоговой панели Prompt (Запрос) с полем ввода.<br></br>   • open() – открытие окна.<br></br>   • setTimeout() – установка таймера.<br></br>   • clearTimeout() – сброс таймера.<br></br>   Рассмотрим практические примеры использования каждого из этих методов.<br></br>   Метод alert() применяется для вывода на экран простейшей диалоговой панели, отображающей какое-либо сообщение. После вызова этого метода выполнение сценария задерживается до тех пор, пока пользователь не нажмет кнопку OK в окне с сообщением.<br></br>   Пример сценария, в котором используется метод alert(), приведен в листинге 10.4.<br></br><h5 class="subtitle"><b>Листинг 10.4.</b> Использование метода alert</h5>   &lt;html&gt;<br></br>   &lt;head&gt;<br></br>   &lt;title&gt;Метод alert&lt;/title&gt;<br></br>   &lt;/head&gt;<br></br>   &lt;body&gt;<br></br>   &lt;script language="JavaScript"&gt;<br></br>   alert("Добро пожаловать!")<br></br>   &lt;/script&gt;<br></br>   &lt;/body&gt;<br></br>   &lt;/html&gt;<br></br><br></br>   Приведенный в примере сценарий выдает пользователю окно с сообщением Добро пожаловать! (рис. 10.4).<br></br><div class="wrap_pict"><div style="text-align: center;"><img src="i_113.png" alt=""></img></div>   <b>Рис. 10.4.</b> Окно с сообщением<br></br></div><br></br><blockquote><div>   <b>Внимание!</b><br></br>
   При вызове метода alert() не нужно указывать объект, для которого вызывается метод, – объект Window. Если при вызове метода объект не указан, интерпретатор сценария, встроенный в браузер, предполагает, что метод относится к объекту Window. Тем не менее вы можете явно указывать объект window: window. alert(). Результат будет тем же самым.<br></br>
</div></blockquote>   С помощью метода confi rm() также можно отобразить на экране диалоговую панель с вашим сообщением, однако эта панель содержит две кнопки – OK и Отмена. В зависимости от того, какая кнопка будет нажата, метод возвратит значение true или false. Поэтому данный метод часто применяется в сценариях с условиями if…else.<br></br>   Рассмотрим использование метода confirm() на примере сценария из листинга 10.5.<br></br><h5 class="subtitle"><b>Листинг 10.5.</b> Использование метода confirm</h5>   &lt;html&gt;<br></br>   &lt;head&gt;<br></br>   &lt;title&gt;Метод confirm()&lt;/title&gt;<br></br>   &lt;script language="JavaScript"&gt;<br></br>   &lt;!– Маскировка сценария<br></br>   function okno() //функция<br></br>   {<br></br>   if (confirm("Вы действительно желаете закрыть окно браузера?") )<br></br>   {<br></br>   alert("До свидания!");<br></br>   window.close();<br></br>   }<br></br>   else<br></br>   {<br></br>   alert("Tогда оставайтесь");<br></br>   }<br></br>   }<br></br>   // Конец маскировки сценария –&gt;<br></br>   &lt;/script&gt;<br></br>   &lt;/head&gt;<br></br>   &lt;body onLoad="okno()"&gt;<br></br>   &lt;/body&gt;<br></br>   &lt;/html&gt;<br></br><br></br>   Помимо метода confirm(), в сценарии использованы методы alert() и close(). В области заголовка документа определена функция okno(). Она содержит условие и обращается к методу confirm(), который выводит на экран диалоговую панель с запросом на закрытие окна (рис. 10.5).<br></br><div class="wrap_pict"><div style="text-align: center;"><img src="i_114.png" alt=""></img></div>   <b>Рис. 10.5.</b> Окно с запросом, выводимое методом confirm()<br></br></div><br></br>   Если пользователь нажмет кнопку OK, метод возвратит значение true, а если кнопку Отмена – значение false.<br></br>   В случае положительного ответа функция okno() вызывает методы alert() и close() для текущего объекта Window. В данном случае таким объектом является окно браузера. Метод close() позволяет закрыть текущее окно браузера, а метод alert() выдаст пользователю сообщение До свидания!. Если же пользователь нажмет кнопку Отмена, то получит окно с сообщением Тогда оставайтесь.<br></br><blockquote><div>   <b>Примечание</b><br></br>
   Вместо объекта Window в сценарии можно указывать объект Self, так как это синоним текущего окна. Например, self.close().<br></br>
</div></blockquote>   Если вам необходимо получить от пользователя одну текстовую строку, то можете применить другой метод объекта Window – метод prompt(). Он отображает на экране диалоговую панель, в которой есть одно текстовое поле ввода и кнопка OK. Когда пользователь нажимает эту кнопку, метод prompt() возвращает введенную строку.<br></br>   Рассмотрим пример сценария, вызывающего метод prompt() (листинг 10.6).<br></br><h5 class="subtitle"><b>Листинг 10.6.</b> Использование метода prompt()</h5>   &lt;html&gt;<br></br>   &lt;head&gt;<br></br>   &lt;title&gt;Метод prompt()&lt;/title&gt;<br></br>   &lt;/head&gt;<br></br>   &lt;body&gt;<br></br>   &lt;script language="JavaScript"&gt;<br></br>   &lt;!– Маскировка сценария<br></br>   var name = prompt("Напишите свое имя, пожалуйста","Введите имя")<br></br>   document.write("Привет, "+name+ ". Спасибо, что зашли.")<br></br>   // Конец маскировки сценария –&gt;<br></br>   &lt;/script&gt;<br></br>   &lt;/body&gt;<br></br>   &lt;/html&gt;<br></br><br></br>   Сценарий выдает пользователю запрос на ввод его имени (рис. 10.6).<br></br><div class="wrap_pict"><div style="text-align: center;"><img src="i_115.png" alt=""></img></div>   <b>Рис. 10.6.</b> Окно запроса<br></br></div><br></br>   Имя, которое ввел пользователь в окне запроса, отображается на веб-странице благодаря команде document.write.<br></br><blockquote><div>   <b>Совет</b><br></br>
   Метод prompt() позволяет сценарию получить от пользователя только одну текстовую строку. Когда необходимо ввести сразу несколько строк, используйте форму, имеющую произвольное количество полей и кнопку завершения ввода с обработкой события onClick. Когда пользователь нажмет эту кнопку, обработчик события сможет извлечь из полей формы введенные данные.<br></br>
</div></blockquote>   Ранее мы рассматривали пример закрытия окна браузера с использованием метода close(). С помощью метода open() в сценарии JavaScript можно открыть новое окно браузера и загрузить в него HTML-документ или изображение для просмотра.<br></br>   Синтаксис команды с использованием метода open() следующий: ореп('адрес URL', 'имя окна', сопйд='параметр 1, параметр 2, параметр 3…., параметр n').<br></br>   Первый параметр метода open() задает URL-адрес HTML-документа, предназначенный для загрузки в новое окно. Например, data.html. Если загружаемая HTML-страница располагается на другом сервере, то добавьте http:// и полный адрес страницы в Интернете. Например, <a href="http://www.mysite.ru/download/javascript.html">http://www.mysite.ru/download/javascript.html</a>.<br></br>   Второй параметр в синтаксисе метода open() определяет имя окна для использования в атрибуте target элемента A или FORM. Вы также можете указать его как пустую строку вида "". Если вам нужно, чтобы страница загружалась в маленьком окне, то данный параметр должен иметь значение joe. Необходимо будет указать joe и после атрибута target.<br></br>   Параметр config показывает, что следующие атрибуты относятся к конфигурации нового окна и определяют его внешний вид.<br></br>   • width – ширина окна в пикселах.<br></br>   • height – высота окна в пикселах.<br></br>   • toolbar – если параметр имеет значение yes или 1, окно снабжается стандартной панелью инструментов. Если же значение этого параметра равно no, то панель инструментов в новом окне не отображается.<br></br>   • location – параметр определяет, будет ли отображаться поле ввода адреса HTML-документа (адресная строка).<br></br>   • status – отображение строки состояния.<br></br>   • menubar – отображение строки меню.<br></br>   • scrollbars – отображение полос прокрутки.<br></br>   • resizable – если этот параметр указан как yes или 1, пользователь сможет изменять размер вновь созданного окна.<br></br>   Все атрибуты параметра config перечисляются через запятую без пробелов и заключаются в одинарные кавычки, поскольку являются подкомандами.<br></br><blockquote><div>   <b>Примечание</b><br></br>
   Помните, что пробел для браузера означает конец команды.<br></br>
</div></blockquote>   Теперь рассмотрим примеры сценариев, использующих метод open() (листинги 10.7 и 10.8).<br></br><h5 class="subtitle"><b>Листинг 10.7.</b> Файл okno.html</h5>   &lt;html&gt;<br></br>   &lt;head&gt;<br></br>   &lt;title&gt;Метод open()&lt;/title&gt;<br></br>   &lt;/head&gt;<br></br>   &lt;body&gt;<br></br>   &lt;script language="JavaScript"&gt;<br></br>   &lt;!– Маскировка сценария<br></br>   window.open('okno2.html', 'joe',config='height=250,width=300,toolbar= no,menubar=no,scrollbars=no,resizable=yes,location=no,status=yes')<br></br>   window.name="main window"<br></br>   // Конец маскировки сценария –&gt;<br></br>   &lt;/script&gt;<br></br>   &lt;/body&gt;<br></br>   &lt;/html&gt;<br></br><br></br><h5 class="subtitle"><b>Листинг 10.8.</b> Файл okno2.html</h5>   &lt;html&gt;<br></br>   &lt;head&gt;<br></br>   &lt;title&gt;Метод open()&lt;/title&gt;<br></br>   &lt;/head&gt;<br></br>   &lt;body&gt;<br></br>   &lt;a href="http://www.ya.ru" TARGET="main window"&gt;Yandex&lt;/a&gt;<br></br>   &lt;p&gt;&lt;a href="" onClick="window.close"&gt;Щелкните, чтобы закрыть&lt;/a&gt;&lt;/p&gt;<br></br>   &lt;/body&gt;<br></br>   &lt;/html&gt;<br></br><br></br>   Сценарий в файле okno.html открывает документ okno2. html в новом маленьком окне браузера (рис. 10.7).<br></br><div class="wrap_pict"><div style="text-align: center;"><img src="i_116.png" alt=""></img></div>   <b>Рис. 10.7.</b> Новое окно браузера<br></br></div><br></br>   Это окно имеет размеры 300 х 250 пикселов, в нем не отображаются меню, панель инструментов, адресная строка и полоса прокрутки. За это отвечают значения атрибутов параметра config, равные no. В новом окне отображается только строка состояния, что определяется атрибутом status=yes. Кроме того, пользователь может изменять размеры нового окна. За это отвечает атрибут resizable=yes.<br></br>   Обратите внимание на строку window.name="main window". Здесь использовано свойство name объекта Window, а main window – это имя главного (большого) окна. Вместо window.name можно написать self.name. Результат будет тот же самый, поскольку window и self – синонимы.<br></br>   В новое окно загружается документ okno2.html, содержащий две ссылки. Одна ссылка загружает главную страницу сайта поисковой системы «Яндекс» в большом окне браузера, имя которому main window. Этого результата мы добились благодаря команде target="main window". Если необходимо, чтобы страница загружалась в маленьком окне, просто напишите j oe вместо main window. Другая ссылка позволяет закрыть маленькое окно благодаря обработчику события onCli ck и методу close(): onClick="window.close".<br></br><blockquote><div>   <b>Совет</b><br></br>
   При открытии новых окон ставьте сценарий ближе к концу HTML-документа. Причина проста: сначала загрузится веб-страница, а потом всплывет окошко. Если команда стоит в начале HTML-документа, то окошко всплывет прежде, чем пользователь увидит вашу страницу. Он может закрыть новое окно, не успев им воспользоваться.<br></br>
</div></blockquote>   Рассмотрим следующий метод объекта Window – setTimeout(). С его помощью вы можете запрограммировать компьютер на выполнение определенных команд по истечении некоторого времени.<br></br>   При использовании описываемого метода применяется следующий синтаксис: setTimeout ("cmd", timeout). Когда пройдет время, заданное параметром timeout (в миллисекундах), запускается команда JavaScript, определенная параметром cmd.<br></br>   Пример сценария, содержащего метод setTimeout(), приведен в листинге 10.9.<br></br><h5 class="subtitle"><b>Листинг 10.9.</b> Использование метода setTimeout</h5>   &lt;html&gt;<br></br>   &lt;head&gt;<br></br>   &lt;title&gt;Метод setTimeout&lt;/title&gt;<br></br>   &lt;script language="JavaScript"&gt;<br></br>   &lt;!– Маскировка сценария<br></br>   function timer() //функция<br></br>   {<br></br>   idTimer=window.setTimeout("alert('Время истекло!')", 3000);<br></br>   }<br></br>   // Конец маскировки сценария –&gt;<br></br>   &lt;/script&gt;<br></br>   &lt;/head&gt;<br></br>   &lt;body&gt;<br></br>   &lt;form&gt; //форма<br></br>   &lt;input type="button" value="Timer" onClick="timer()"&gt;<br></br>   &lt;/form&gt;<br></br>   &lt;/body&gt;<br></br>   &lt;/html&gt;<br></br><br></br>   Данный HTML-документ содержит сценарий и форму с кнопкой Timer. При нажатии кнопки открывается окно Alert с задержкой в три секунды (рис. 10.8).<br></br><div class="wrap_pict"><div style="text-align: center;"><img src="i_117.png" alt=""></img></div>   <b>Рис. 10.8.</b> Окно Alert с сообщением<br></br></div><br></br>   Здесь setTimeout() – это метод объекта Window. Он определяет интервал времени в 3000 миллисекунд (3 секунды) и команду, которая должна быть выполнена по истечении этого времени. В данном случае это вызов окна с сообщением с помощью метода alert: «alert(Время истекло!)». Обратите внимание, что код на JavaScript должен быть обязательно заключен в кавычки, а время указывается в миллисекундах и без кавычек.<br></br>   С помощью метода clearTimeout() можно остановить таймер, запущенный только что рассмотренным методом setTimeout(). В качестве параметра методу clearTimeout() необходимо передать идентификатор таймера, полученный от метода setTimeout():<br></br><br></br>   clearTimeout(idTimer)<br></br><br></br>   Методы setTimeout() и clearTimeout() применяются для периодического вызова функции сдвига сообщения в строке состояния браузера («бегущая» строка) и для ограничения времени ввода пользователем пароля в формах. Еще одно применение данного метода – создание анимационных эффектов с использованием сценариев JavaScript.<br></br>   Помимо свойств и методов, с объектом Window связаны два обработчика событий – onLoad и onUnload. Первый из них срабатывает, когда браузер заканчивает загрузку окна, а второй – когда пользователь завершает работу с HTML-документом.<br></br>   В своем сценарии вы можете предусмотреть обработку этих событий, назначив для каждого определенную функцию. Функция, которая вызывается при завершении загрузки документа, может выполнять какие-либо действия, создавать дополнительные окна или выводить сообщения. Обработчик события onUnload может освобождать полученные ресурсы или выводить какие-либо дополнительные сообщения при уходе пользователя с веб-страницы.<br></br><blockquote><div>   <b>Внимание!</b><br></br>
   Как правило, вызов обработчиков событий onLoad и onUnload располагается в строке элемента BODY.<br></br>
</div></blockquote>   В качестве примера рассмотрим HTML-документ, который приведен в листинге 10.10.<br></br><h5 class="subtitle"><b>Листинг 10.10.</b> Использование обработчиков событий onLoad и onUnload</h5>   &lt;html&gt;<br></br>   &lt;head&gt;<br></br>   &lt;title&gt;Обработчики событий onLoad и onUnload&lt;/title&gt;<br></br>   &lt;/head&gt;<br></br>   &lt;script language="JavaScript"&gt;<br></br>   &lt;!– Маскировка сценария<br></br>   function hello() //функция<br></br>   {<br></br>   alert("Добро пожаловать на мою домашнюю страничку!")<br></br>   }<br></br>   function bye() //функция<br></br>   {<br></br>   alert("До свидания! Спасибо, что зашли!")<br></br>   }<br></br>   // Конец маскировки сценария –&gt;<br></br>   &lt;/script&gt;<br></br>   &lt;body bgcolor=white onLoad="hello()" onUnload="bye()"&gt;<br></br>   &lt;/body&gt;<br></br>   &lt;/html&gt;<br></br><br></br>   Здесь в элементе BODY определены обработчики событий onLoad и onUnload. При возникновении первого события будет вызываться функция hello, при возникновении второго – функция bye.<br></br>   Поскольку HTML-документ интерпретируется в направлении сверху вниз, функции hello и bye необходимо определить до появления элемента BODY. Лучшее место для определения этих функций – заголовок HTML-документа.<br></br>   Итак, вы познакомились с методами, свойствами и событиями объекта Window, позволяющими выполнять различные действия с окном браузера. Теперь рассмотрим другой объект JavaScript, с помощью которого вы можете получить некоторые данные о самом браузере, – объект Navigator.<br></br></div><h3 id="idm139732168646736">Объект Navigator
</h3><div style="text-align: justify" class="hsection3">   Объект Navigator автоматически создается при открытии веб-страницы браузером и содержит общую информацию о браузере пользователя.<br></br><blockquote><div>   <b>Примечание</b><br></br>
   Объект Navigator служит для доступа к самой программе обозревателя. Не путайте его с объектом Window, представляющим текущее окно браузера, и названием программы Netscape Navigator.<br></br>
</div></blockquote>   Благодаря объекту Navigator можно узнать некоторые данные о браузере и компьютере пользователя. Эта информация может пригодиться при формировании<br></br>   разного стиля веб-страниц для различных браузеров.<br></br>   Как и другие объекты JavaScript, Navigator имеет свои свойства. Это конкретные<br></br>   строковые значения о браузере пользователя.<br></br>   • appCodeName – определяет кодовое имя (платформу, «движок») браузера.<br></br>   • appName – указывает имя (название) браузера, например Netscape или Internet Explorer.<br></br>   • appVersion – определяет версию браузера, включая платформу, выпуск браузера и операционную систему пользователя.<br></br>   • userAgent – возвращает строку, идентифицирующую браузер пользователя, то есть заголовок протокола, используемого браузером во время работы с сервером. Проще говоря, это название браузера, посылаемое серверу с помощью HTTP-протокола. Оно является комбинацией значений свойств appCodeName и appVersion.<br></br>   • cookieEnabled – указывает, разрешено или нет использование cookies, позволяющих сохранять небольшие фрагменты информации на компьютере пользователя. Возвращает true, если пользователь разрешил браузеру прием cookies. Поддерживается только Internet Explorer, начиная с версии 4.0.<br></br>   • browserLanguage – определяет текущий язык браузера. Поддерживается только Internet Explorer, начиная с версии 4.0.<br></br>   • systemLanguage – указывает язык операционной системы по умолчанию, например ru, если используется русская версия Windows. Поддерживается только Internet Explorer, начиная с версии 4.0.<br></br>   • userLanguage – определяет пользовательские настройки языка операционной системы. Поддерживается только Internet Explorer, начиная с версии 4.0.<br></br>   • platform – указывает платформу операционной системы пользователя, например Win32.<br></br>   • cpuClass – определяет класс (тип) центрального процессора компьютера пользователя. Например, x8 6 или Alpha. Поддерживается только Internet Explorer, начиная с версии 4.0.<br></br>   Рассмотрим пример сценария, в котором определяются различные характеристики браузера (листинг 10.11).<br></br><h5 class="subtitle"><b>Листинг 10.11.</b> Определение характеристик браузера</h5>   &lt;html&gt;<br></br>   &lt;head&gt;<br></br>   &lt;title&gt;Свойства объекта Navigator&lt;/title&gt;<br></br>   &lt;/head&gt;<br></br>   &lt;body&gt;<br></br>   &lt;script language=JavaScript&gt;<br></br>   &lt;!– Определение переменных –&gt;<br></br>   var an = navigator.appName;<br></br>   var av = navigator.appVersion;<br></br>   var acn = navigator.appCodeName;<br></br>   var ua = navigator.userAgent;<br></br>   var cook = navigator.cookieEnabled;<br></br>   var blang = navigator.browserLanguage;<br></br>   var slang = navigator.systemLanguage;<br></br>   var ulang = navigator.userLanguage;<br></br>   var platf = navigator.platform;<br></br>   var cpu = navigator.cpuClass;<br></br>   &lt;!– Код JavaScript для отображения надписи на странице –&gt;<br></br>   document.write("&lt;b&gt;Ваш браузер&lt;/b&gt; "+an+" &lt;b&gt;версии&lt;/b&gt; "+av+"&lt;br&gt;&lt;b&gt;Его кодовое имя&lt;/b&gt; "+acn+" &lt;b&gt;и заголовок протокола&lt;/b&gt; "+ua+"&lt;br&gt;&lt;b&gt;Текущее значение cookies &lt;/b&gt;"+cook+"&lt;br&gt;&lt;b&gt;Текущий язык браузера &lt;/b&gt;"+blang+ "&lt;br&gt;&lt;b&gt;Язык ОС by default &lt;/b&gt;"+slang+"&lt;br&gt;&lt;b&gt;Пользовательские настройки языка ОС &lt;/b&gt;"+ulang+ "&lt;br&gt;&lt;b&gt;Платформа ОС &lt;/b&gt;"+platf+"&lt;br&gt;&lt;b&gt;Тип процессора вашего компьютера &lt;/b&gt;"+cpu)<br></br>   &lt;/script&gt;<br></br>   &lt;/body&gt;<br></br>   &lt;/html&gt;<br></br>   В данном примере каждому свойству объекта Navigator назначена отдельная переменная. Благодаря команде document. write() информация о характеристиках браузера отображается на веб-странице (рис. 10.9).<br></br><div class="wrap_pict"><div style="text-align: center;"><img src="i_118.png" alt=""></img></div>   <b>Рис. 10.9.</b> Характеристики браузера<br></br></div><br></br>   Если какие-либо свойства объекта Navigator не определяются, значит, ваш браузер их не поддерживает.<br></br>   Рассмотрим еще один пример использования свойств объекта Navigator (листинг 10.12).<br></br><h5 class="subtitle"><b>Листинг 10.12.</b> Определение имени браузера</h5>   &lt;html&gt;<br></br>   &lt;head&gt;<br></br>   &lt;title&gt;Test of Browser name&lt;/title&gt;<br></br>   &lt;/head&gt;<br></br>   &lt;body&gt;<br></br>   &lt;h1 align=center&gt;Проверка имени браузера&lt;/h1&gt;<br></br>   &lt;hr&gt;<br></br>   &lt;script language=JavaScript&gt;<br></br>   &lt;!– Маскировка сценария<br></br>   if(navigator.appName == "Microsoft Internet Explorer") //условие<br></br>   {<br></br>   alert("У вас хороший браузер"); //окно с сообщением<br></br>   }<br></br>   else<br></br>   {<br></br>   alert("А чем вам не понравился Microsoft Internet Explorer?");<br></br>   }<br></br>   // Конец маскировки сценария –&gt;<br></br>   &lt;/script&gt;<br></br>   &lt;/body&gt;<br></br>   &lt;/html&gt;<br></br><br></br>   Приведенный в листинге сценарий содержит условие if…else и проверяет имя браузера пользователя (рис. 10.10).<br></br><div class="wrap_pict"><div style="text-align: center;"><img src="i_119.png" alt=""></img></div>   <b>Рис. 10.10.</b> Проверка имени браузера<br></br></div><br></br>   Если страница открыта в Internet Explorer, то пользователь получит сообщение У вас хороший браузер (рис. 10.11).<br></br><div class="wrap_pict"><div style="text-align: center;"><img src="i_120.png" alt=""></img></div>   <b>Рис. 10.11.</b> Окно с сообщением<br></br></div><br></br>   Если для открытия страницы используется другой браузер, сообщение будет следующим: А чем вам не понравился Microsoft Internet Explorer?.<br></br>   Этот простейший пример показывает, как можно применять свойства объекта Navigator при решении задач программирования типа «Если браузер клиента такой-то, то…, иначе…».<br></br>   Помимо свойств, для объекта Navigator в языке JavaScript определены свои методы.<br></br>   • taintEnabled() – проверяет браузер на несовместимость с Netscape Navigator.<br></br>   • javaEnabled() – проверяет, разрешено ли в браузере выполнение сценариев JavaScript.<br></br>   Оба метода возвращают логические значения (true или false). Их можно использовать для принятия каких-либо решений в других сценариях.<br></br></div><h3 id="idm139732168598224">Объект Screen
</h3><div style="text-align: justify" class="hsection3">   Объект Screen содержит информацию о различных параметрах экрана монитора пользователя: разрешающая способность, глубина цвета, частота обновления экрана и т. п. Эти данные могут помочь разработчику подстроить интерфейс сайта под конкретные параметры экрана.<br></br>   Как и другие объекты, Screen имеет свои свойства.<br></br>   • width – определяет полную ширину экрана монитора в пикселах.<br></br>   • height – задает полную высоту экрана монитора пользователя в пикселах.<br></br>   • availHeight – определяет высоту полезной области экрана монитора без Панели задач и подобных ей элементов графического интерфейса операционной системы.<br></br>   • availWidth – возвращает ширину полезной области экрана монитора без Панели задач и подобных ей элементов графического интерфейса операционной системы.<br></br>   • colorDepth – возвращает глубину цвета. Для 16 цветов возвращается 2, для 256 – 8, для 16,7 миллионов цветов (режим High Color) – 32.<br></br>   • updateInterval – возвращает интервал времени (в миллисекундах) между обновлениями экрана. Значение 0 позволяет браузеру выбирать среднее число, что обычно работает лучше всего.<br></br><blockquote><div>   <b>Примечание</b><br></br>
   На значения свойств объекта Screen также влияют пользовательские настройки параметров видео в Панели управления.<br></br>
</div></blockquote>   В следующем примере приведен сценарий, который позволит вам определить параметры экрана монитора (листинг 10.13).<br></br><h5 class="subtitle"><b>Листинг 10.13.</b> Свойства объекта Screen</h5>   &lt;html&gt;<br></br>   &lt;head&gt;<br></br>   &lt;title&gt;Свойства объекта Screen&lt;/title&gt;<br></br>   &lt;/head&gt;<br></br>   &lt;body&gt;<br></br>   &lt;script language=JavaScript&gt;<br></br>   &lt;!– Маскировка сценария<br></br>   document.write('width: '+window.screen.width+'&lt;br&gt;');<br></br>   document.write('availWidth: '+window.screen.availWidth+'&lt;br&gt;');<br></br>   document.write('height: '+window.screen.height+'&lt;br&gt;');<br></br>   document.write('availHeight: '+window.screen.availHeight+'&lt;br&gt;');<br></br>   document.write('colorDepth: '+window.screen.colorDepth+'&lt;br&gt;');<br></br>   document.write('updateInterval: '+window.screen.updateInterval)<br></br>   // Конец маскировки сценария –&gt;<br></br>   &lt;/script&gt;<br></br>   &lt;/body&gt;<br></br>   &lt;/html&gt;<br></br>   Результат работы сценария показан на рис. 10.12.<br></br><div class="wrap_pict"><div style="text-align: center;"><img src="i_121.png" alt=""></img></div>   <b>Рис. 10.12.</b> Параметры экрана монитора<br></br></div><br></br>   Размеры экрана монитора пользователя являются очень важными для разработчика. Создавая сайт под разрешение монитора 1280 х 720 пикселов, нужно помнить, что его будет очень неудобно просматривать на экране с разрешением 800 х 600. Используя свойства объекта Screen, в сценарии JavaScript можно изменять размер веб-страниц в зависимости от разрешения экрана монитора пользователя. Если вместе с этим приемом использовать сценарий для определения браузера пользователя, то ваш сайт будет прекрасно отображаться в окне любого браузера на экране с любым разрешением.<br></br></div><h3 id="idm139732168579920">Объект History
</h3><div style="text-align: justify" class="hsection3">   Объект History является частью объекта Window. Он содержит информацию о посещенных пользователем веб-страницах за текущий сеанс путешествия по Сети. Эти URL-адреса можно загружать снова, то есть передвигаться по истории посещений. Основной целью объекта History является доступ к списку введенных в браузере адресов URL.<br></br><blockquote><div>   <b>Внимание!</b><br></br>
   Поскольку объект History является частью объекта Window, доступ к нему осуществляется именно через этот объект: window, history, length.<br></br>
</div></blockquote>   У объекта History всего одно свойство – length. Оно определяет количество посещенных веб-страниц за текущий сеанс работы в браузере. Сценарий из листинга 10.14 показывает, сколько страниц вы посетили за сеанс.<br></br><h5 class="subtitle"><b>Листинг 10.14.</b> Определение количества посещенных веб-страниц</h5>   &lt;html&gt;<br></br>   &lt;head&gt;<br></br>   &lt;title&gt;Количество посещенных страниц&lt;/title&gt;<br></br>   &lt;/head&gt;<br></br>   &lt;body&gt;<br></br>   &lt;script language=JavaScript&gt;<br></br>   &lt;!– Маскировка сценария<br></br>   function hislen() //функция<br></br>   {<br></br>   alert(window.history.length)<br></br>   }<br></br>   // Конец маскировки сценария –&gt;<br></br>   &lt;/script&gt;<br></br>   &lt;!– Элементы страницы –&gt;<br></br>   &lt;input type="button" onclick="hislen()" value="Показать количество посещенных страниц"&gt;<br></br>   &lt;/body&gt;<br></br>   &lt;/html&gt;<br></br>   Данный сценарий содержит функцию hislen(), вызывающую окно Alert при нажатии кнопки формы. В окне отображается количество веб-страниц, посещенных за текущий сеанс работы с браузером. Если вы запускаете сценарий с жесткого диска, не удивляйтесь, если количество посещенных страниц будет равно нулю (рис. 10.13).<br></br><div class="wrap_pict"><div style="text-align: center;"><img src="i_122.png" alt=""></img></div>   <b>Рис. 10.13.</b> Окно с указанием количества посещенных веб-страниц<br></br></div><br></br>   Передвигаться по истории и загружать ранее посещенные пользователем веб-страницы позволяют следующие методы объекта History:<br></br>   • go() – загружает веб-страницу с определенным номером относительно страницы, открытой в данный момент в браузере (текущая страница имеет индекс 0, предыдущая– 1, посещенная до этого страница–2 и т. д.);<br></br>   • back() – загружает предыдущую веб-страницу, посещенную пользователем (эквивалентно go(-1));<br></br>   • forward() – загружает следующую веб-страницу из списка истории, если таковая имеется (эквивалентно go(1)).<br></br>   Например, чтобы перейти на две страницы назад, можно использовать сценарий из листинга 10.15.<br></br><h5 class="subtitle"><b>Листинг 10.15.</b> Перемещение по истории посещений</h5>   &lt;html&gt;<br></br>   &lt;head&gt;<br></br>   &lt;title&gt;Перемещение по истории посещений&lt;/title&gt;<br></br>   &lt;/head&gt;<br></br>   &lt;body&gt;<br></br>   &lt;script language=JavaScript&gt;<br></br>   &lt;!– Маскировка сценария<br></br>   function goback() //функция<br></br>   {<br></br>   window.history.go(-2)<br></br>   }<br></br>   // Конец маскировки сценария –&gt;<br></br>   &lt;/script&gt;<br></br>   &lt;!– Элементы страницы –&gt;<br></br>   &lt;input type="button" onclick="goback()" value="Перейти на 2 страницы назад"&gt;<br></br>   &lt;/body&gt;<br></br>   &lt;/html&gt;<br></br><br></br>   При нажатии кнопки формы (рис. 10.14) запускается функция goback(), позволяющая перейти на две страницы назад.<br></br><div class="wrap_pict"><div style="text-align: center;"><img src="i_123.png" alt=""></img></div>   <b>Рис. 10.14.</b> Кнопка для запуска функции<br></br></div><br></br>   Используя методы объекта History, вы сможете организовать удобную систему навигации по сайту. Учтите, что для этого пользователь должен просматривать все страницы вашего сайта в одном окне браузера. Как только какая-либо из страниц будет открыта в новом окне, история посещений применительно к этому окну браузера начнется с нуля.<br></br></div><h3 id="idm139732184920400">Объект Location
</h3><div style="text-align: justify" class="hsection3">   Объект Location является частью объекта Window. Он содержит информацию об URL-адресе текущей страницы и его составляющих.<br></br>   Использование объекта Location в сценарии JavaScript позволяет обновить текущую страницу или полностью поменять URL-адрес, то есть перейти на другую веб-страницу.<br></br>   Свойства объекта Location содержат различную информацию о подключении пользователя к HTTP-серверу.<br></br>   • href – полный URL-адрес текущей веб-страницы.<br></br>   • hash – имя «якоря» в URL-адресе веб-страницы (значение атрибута name), если он есть.<br></br>   • host – часть URL-адреса страницы, содержащая имя сервера в Интернете и номер порта.<br></br>   • hostname – имя сервера в Сети, с которого загружена текущая веб-страница.<br></br>   • pathname – путь к файлу на веб-сервере без имени сервера и порта.<br></br>   • port – сообщает номер порта HTTP-сервера, через который идет обращение к веб-странице. Если порт не указан, возвращает номер 8 0 – стандартный порт, через который работает протокол HTTP.<br></br>   • protocol – протокол передачи данных (HTTP, FTP и др.). Если протокол не указан, возвращает значение http:.<br></br>   • search – строка параметров для серверных сценариев, начинается со знака?.<br></br>   Команды host, hostname, port, search не работают, если просматривать страницу с жесткого диска компьютера. Результат может быть только в том случае, если веб-страница размещается на сервере в Интернете.<br></br><blockquote><div>   <b>Внимание!</b><br></br>
   Поскольку объект Location является частью объекта Window, доступ к нему осуществляется именно через этот объект: window.location.property.<br></br>
</div></blockquote>   Рассмотрим использование свойств объекта Location на примере сценария из листинга 10.16.<br></br><h5 class="subtitle"><b>Листинг 10.16.</b> Свойство href объекта Location</h5>   &lt;html&gt;<br></br>   &lt;head&gt;<br></br>   &lt;title&gt;URL текущего HTML-документа&lt;/title&gt;<br></br>   &lt;/head&gt;<br></br>   &lt;body&gt;<br></br>   &lt;script language=JavaScript&gt;<br></br>   &lt;!– Маскировка сценария<br></br>   document.write(location.href); //код JavaScript<br></br>   // Конец маскировки сценария –&gt;<br></br>   &lt;/script&gt;<br></br>   &lt;/body&gt;<br></br>   &lt;/html&gt;<br></br>   Данный сценарий определяет полный URL-адрес текущего HTML-документа. При запуске сценария с жесткого диска вашего компьютера команда location. href покажет полный путь к файлу со сценарием (рис. 10.15).<br></br><div class="wrap_pict"><div style="text-align: center;"><img src="i_124.png" alt=""></img></div>   <b>Рис. 10.15.</b> Путь к файлу со сценарием<br></br></div><br></br>   Методы объекта Location позволяют перезагружать текущую веб-страницу или менять URL-адрес, загружать другую веб-страницу вместо предыдущей. При этом будет невозможен переход к предыдущей странице с помощью кнопки Назад в браузере пользователя. Возникает эффект, что страницы как бы подменяются друг другом.<br></br>   Рассмотрим подробнее методы объекта Location.<br></br>   • assign() – загружает другую страницу, меняя URL-адрес текущей веб-страницы на адрес, указанный в параметре метода.<br></br>   • reload() – обновляет текущую веб-страницу (не всегда срабатывает правильно, поскольку некоторые браузеры все равно берут эту страницу из кэша, не обращаясь к серверу).<br></br>   • replace() – замена текущей веб-страницы страницей, URL которой указан в параметре метода. При этом в списке истории браузера адрес предыдущего HTML-документа заменяется адресом нового.<br></br>   В листинге 10.17 приведен пример сценария, содержащего один из методов объекта Location – метод replace().<br></br><h5 class="subtitle"><b>Листинг 10.17.</b> Использование метода replace()</h5>   &lt;html&gt;<br></br>   &lt;head&gt;<br></br>   &lt;title&gt;Метод replace()&lt;/title&gt;<br></br>   &lt;script language=JavaScript&gt;<br></br>   &lt;!– Маскировка сценария<br></br>   function replaceDoc()<br></br>   {<br></br>   window.location.replace("http://www.yandex.ru") //код JavaScript<br></br>   }<br></br>   // Конец маскировки сценария –&gt;<br></br>   &lt;/script&gt;<br></br>   &lt;/head&gt;<br></br>   &lt;body&gt;<br></br>   &lt;input type="button" value="Replace" onclick="replaceDoc()" /&gt; //кнопка<br></br>   &lt;/body&gt;<br></br>   &lt;/html&gt;<br></br><br></br>   Сценарий позволяет изменить текущую страницу в окне браузера на главную страницу сайта <a href="http://www.yandex.ru/">www.yandex.ru</a>. За это отвечает функция replaceDoc(), которая вызывается при нажатии кнопки Replace (рис. 10.16).<br></br><div class="wrap_pict"><div style="text-align: center;"><img src="i_125.png" alt=""></img></div>   <b>Рис. 10.16.</b> Кнопка Replace<br></br></div><br></br>   Таким образом, объект Location позволяет не только определять адрес загруженного в браузер HTML-документа, но, что более важно, загружать в текущее окно новую вебстраницу.<br></br>   Итак, мы рассмотрели объекты браузера, их свойства и методы. Для HTML-документа и его содержимого в языке JavaScript также определены свои объекты.<br></br></div></div><h2 id="idm139732184863824">10.4. Объектная модель документа (DOM)
</h2><div style="text-align: justify" class="hsection2"><div style="text-align: justify" class="section3">   Стандартный набор объектов в HTML-документе, их свойства и способ доступа к ним определяется объектной моделью документа (Document Object Model, сокращенно DOM). DOM позволяет управлять всеми элементами на веб-странице, изменять их свойства и содержание, создавать новые элементы.<br></br>
</div><h3 id="idm139732184865104">Объект Document
</h3><div style="text-align: justify" class="hsection3">   Для работы с документами HTML в языке JavaScript существует отдельный объект – Document. Пользуясь его свойствами и методами, сценарий JavaScript может получить информацию о текущем документе, загруженном в окно браузера, а также управлять отображением содержимого этого документа.<br></br>   Любая веб-страница, которую вы просматриваете в окне браузера, может быть описана как набор объектов. Она включает собственно HTML-документ «в целом» и более мелкие объекты – элементы веб-страницы. Например, заголовок, абзац_1, абзац_2, абзац_3, рисунок, ссылка, форма и т. п.<br></br>   HTML-документ «в целом» и есть объект Document. Элементы веб-страницы называются HTML-объектами, поскольку определяются элементами языка HTML. Все HTML-объекты выступают в качестве дочерних по отношению к объекту Document. Благодаря этому вы можете обращаться к данным объектам из сценариев JavaScript.<br></br>   Совокупность описывающих веб-страницу объектов со всеми их методами и свойствами в языке JavaScript называется объектной моделью документа. Объект Document является главным в этой модели. Он содержит внутри себя множество подчиненных объектов и коллекций.<br></br>   <b>Коллекция</b> – это массив объектов, проиндексированный не только по числовым номерам элементов, но и по их именам и имеющий свойства и методы. Коллекция отличается от обычного массива именно наличием свойств и методов. Поэтому каждая коллекция сама по себе объект и в то же время свойство объекта Document.<br></br>   Рассмотрим, какие же коллекции существуют для объекта Document.<br></br>   • anchors – коллекция всех локальных меток («якорей»), размещенных в HTML-документе. Эти метки содержатся в тегах &lt;a name="…"&gt; &lt;/a&gt; и применяются для организации ссылок внутри одной веб-страницы.<br></br>   • links – коллекция всех ссылок в HTML-документе, содержащихся в тегах &lt;a href="…"&gt; &lt;/a&gt;.<br></br>   • images – массив всех изображений на веб-странице.<br></br>   • forms – коллекция всех форм в HTML-документе.<br></br>   Благодаря этим коллекциям сценарию JavaScript доступны все локальные метки, формы, изображения и ссылки в HTML-документе как элементы соответствующих массивов.<br></br>   Пример сценария, использующего одну из коллекций объекта Document, приведен в листинге 10.18.<br></br><h5 class="subtitle"><b>Листинг 10.18.</b> Использование коллекции anchors</h5>   &lt;html&gt;<br></br>   &lt;head&gt;<br></br>   &lt;title&gt;Anchors&lt;/title&gt;<br></br>   &lt;/head&gt;<br></br>   &lt;body&gt;<br></br>   &lt;!– Элементы страницы –&gt;<br></br>   &lt;a name="first"&gt;1 anchor&lt;/a&gt;&lt;br /&gt;<br></br>   &lt;a name="second"&gt;2 anchor&lt;/a&gt;&lt;br /&gt;<br></br>   &lt;a name="third"&gt;3 anchor&lt;/a&gt;&lt;br /&gt;<br></br>   &lt;br /&gt;Количество "якорей" в этом HTML-документе:<br></br>   &lt;!–Код JavaScript –&gt;<br></br>   &lt;script language=JavaScript&gt;<br></br>   document.write(document.anchors.length)<br></br>   &lt;/script&gt;<br></br>   &lt;/body&gt;<br></br>   &lt;/html&gt;<br></br>   Данный сценарий демонстрирует использование массива anchors для определения количества «якорей» в HTML-документе. Команда document. write отображает количество «якорей» на странице в числовом выражении (рис. 10.17).<br></br><div class="wrap_pict"><div style="text-align: center;"><img src="i_126.png" alt=""></img></div>   <b>Рис. 10.17.</b> Использование коллекции anchors<br></br></div><br></br>   Количество «якорей» подсчитывается с помощью команды document.anchors. length, где document – объект Document, anchor – массив всех «якорей» на веб-странице, а length – длина массива (то есть количество элементов в массиве).<br></br>   Аналогично можно определить количество всех ссылок, изображений и форм на веб-странице. Для этого вместо коллекции anchors в строку document. anchors. length достаточно подставить названия массивов: links, images или forms.<br></br>   Помимо коллекции, для объекта Document существуют свои свойства, анализируя которые, сценарий JavaScript может определить значения различных параметров веб-страницы. Рассмотрим эти свойства объекта Document.<br></br>   • alinkColor – содержимое атрибута alink. Он определяет цвет ссылок, выбранных пользователем.<br></br>   • linkColor – содержимое атрибута link, определяющего цвет еще не посещенных ссылок, размещенных в HTML-документе.<br></br>   • vlinkColor – содержимое атрибута vlink. Он задает цвет уже посещенных ранее ссылок, размещенных в HTML-документе.<br></br>   • bgColor – содержимое атрибута bgcolor. Применяется для создания цветного фона HTML-документа. Цвет задается либо в шестнадцатеричном виде (например, #F0F8FF), либо в виде названий цветов (например, red или white).<br></br>   • fgColor – содержимое атрибута text, определяющего цвет текста. Задается таким же образом, что и цвет фона веб-страницы bgcolor.<br></br>   • lastModified – дата последнего изменения HTML-документа.<br></br>   • location – полный URL-адрес текущей веб-страницы.<br></br>   • referrer – URL-адрес страницы, с которой была открыта данная веб-страница.<br></br>   • title – заголовок документа, заданный с помощью элемента TITLE.<br></br>   • URL – полный URL-адрес HTML-документа.<br></br>   Многие из перечисленных свойств объекта Document позволяют динамически изменять значения HTML-элементов, расположенных в блоке BODY. Например, фоновый цвет страницы, цвет ссылок, содержание заголовка документа.<br></br>   Большинство свойств объекта Document доступно сценарию JavaScript как для чтения, так и для записи. Следующий пример демонстрирует, как с помощью сценария JavaScript изменить свойства HTML-документа: цвет фона и текста, а также цвета посещенных, непосещенных и выбранных пользователем ссылок (листинг 10.19).<br></br><h5 class="subtitle"><b>Листинг 10.19.</b> Свойства объекта Document</h5>   &lt;html&gt;<br></br>   &lt;head&gt;<br></br>   &lt;title&gt; Свойства объекта Document&lt;/title&gt;<br></br>   &lt;!–Код JavaScript –&gt;<br></br>   &lt;script language="JavaScript"&gt;<br></br>   document.bgColor = "#00FF80";<br></br>   document.fgColor = "#800080";<br></br>   document.linkColor = "#000000";<br></br>   document.alinkColor = "#FF0000";<br></br>   document.vlinkColor = "#4000FF";<br></br>   &lt;/script&gt;<br></br>   &lt;/head&gt;<br></br>   &lt;body bgcolor=white&gt;<br></br>   &lt;h1&gt;Изменение цветового оформления страницы&lt;/h1&gt;<br></br>   &lt;h3&gt;Щелкните по этим ссылкам: &lt;/h3&gt;<br></br>   &lt;p&gt;&lt;a href="http://www.yandex.ru"&gt;Yandex&lt;/a&gt;<br></br>   &lt;p&gt;&lt;a href="http://www.mail.ru"&gt;Бесплатная электронная почта&lt;/a&gt;<br></br>   &lt;p&gt;&lt;a href="http://www.microsoft.com"&gt;Сервер Microsoft&lt;/a&gt;<br></br>   &lt;/body&gt;<br></br>   &lt;/html&gt;<br></br><br></br>   Результат работы сценария показан на рис. 10.18.<br></br><div class="wrap_pict"><div style="text-align: center;"><img src="i_127.png" alt=""></img></div>   <b>Рис. 10.18.</b> Изменение цвета фона, текста и ссылок<br></br></div><br></br>   Обратите внимание, что данный сценарий переопределяет цвет фона веб-страницы, заданный параметром bgcolor=white в элементе BODY: document. bgColor = «#00FF80».<br></br>   Рассмотрим еще один пример сценария, в котором используется свойство lastModified объекта Document (листинг 10.20).<br></br><h5 class="subtitle"><b>Листинг 10.20.</b> Использование свойства lastModified</h5>   &lt;html&gt;<br></br>   &lt;head&gt;<br></br>   &lt;title&gt; Свойство lastModified&lt;/title&gt;<br></br>   &lt;/head&gt;<br></br>   &lt;body&gt;<br></br>   &lt;center&gt;<br></br>   &lt;!–Код JavaScript –&gt;<br></br>   &lt;script language="JavaScript"&gt;<br></br>   document.write("Последний раз страница редактировалась:&lt;br&gt;" +document. lastModified)<br></br>   &lt;/script&gt;<br></br>   &lt;/center&gt;<br></br>   &lt;/body&gt;<br></br>   &lt;/html&gt;<br></br><br></br>   Свойство lastModified позволяет узнать дату внесения последних изменений в содержание HTML-документа. В сценарии это реализовано в команде document.lastModified. Строка document. write() помещает полученную дату на веб-страницу (рис. 10.19).<br></br><div class="wrap_pict"><div style="text-align: center;"><img src="i_128.png" alt=""></img></div>   <b>Рис. 10.19.</b> Использование свойства lastModified<br></br></div><br></br>   Во многих рассмотренных ранее примерах сценариев JavaScript вам не раз встречалась строка document. write(). Write() – это метод объекта Document, позволяющий отображать какую-либо информацию на веб-странице. Кроме этого широко используемого метода, сценарии JavaScript могут вызывать и другие методы, определенные для объекта Document.<br></br>   • close() – заставляет веб-страницу немедленно обновить свое содержимое после использования метода write(). Метод close() не имеет параметров и не возвращает значения. Поддерживается Internet Explorer, начиная с версии 4.0.<br></br>   • getElementsByName({имя_элемента}) – возвращает элемент, специфическое имя которого передано в качестве параметра. Данный метод поддерживается браузером Internet Explorer, начиная с версии 5.0.<br></br>   • getElementByld ({ID}) – возвращает элемент, имя которого передано в качестве параметра. Имя элемента страницы задается атрибутом ID. Метод getElementById() имеет единственный параметр – имя элемента страницы. Поддерживается браузером Internet Explorer, начиная с версии 5.0.<br></br>   • getElementsByTagName({Имя тега}) – возвращает тег, имя которого передано в качестве параметра. Поддерживается браузером Internet Explorer, начиная с версии 5.0.<br></br>   • write() – записывает текст или HTML-код в текущее место документа.<br></br>   В браузере Microsoft Internet Explorer версии 5.0 появилась поддержка таких методов объекта Document, как getElementById(), getElementsByName() и getElementsByTagName(). Последний используется в сценариях JavaScript особенно часто. Рассмотрим пример такого сценария (листинг 10.21).<br></br><h5 class="subtitle"><b>Листинг 10.21.</b> Использование метода getElementsByTagNameO</h5>   &lt;html&gt;<br></br>   &lt;head&gt;<br></br>   &lt;title&gt; Метод getElementsByTagName()&lt;/title&gt;<br></br>   &lt;!–Код JavaScript –&gt;<br></br>   &lt;script language="JavaScript"&gt;<br></br>   function getElements() //функция<br></br>   {<br></br>   var x=document.getElementsByTagName("input");<br></br>   alert(x.length);<br></br>   }<br></br>   &lt;/script&gt;<br></br>   &lt;/head&gt;<br></br>   &lt;body&gt;<br></br>   &lt;!–Форма –&gt;<br></br>   &lt;input name="myInput" type="text" size="30" /&gt;&lt;br /&gt;<br></br>   &lt;input name="myInput" type="text" size="30" /&gt;&lt;br /&gt;<br></br>   &lt;input name="myInput" type="text" size="30" /&gt;&lt;br /&gt;<br></br>   &lt;br /&gt;<br></br>   &lt;input type="button" onclick="getElements()" value="Посчитаем элементы input" /&gt;<br></br>   &lt;/body&gt;<br></br>   &lt;/html&gt;<br></br><br></br>   Данный сценарий содержит функцию getElements(), которая производит подсчет всех элементов типа INPUT на веб-странице, а затем выводит результат в окне Alert (рис. 10.20).<br></br><div class="wrap_pict"><div style="text-align: center;"><img src="i_129.png" alt=""></img></div>   <b>Рис. 10.20.</b> Окно с количеством элементов<br></br></div><br></br>   Функция срабатывает при нажатии кнопки в форме. Как видите, в этом HTML-документе содержится четыре элемента, обозначенные элементом INPUT: три поля для ввода и кнопка (рис. 10.21).<br></br><div class="wrap_pict"><div style="text-align: center;"><img src="i_130.png" alt=""></img></div>   <b>Рис. 10.21.</b> Элементы INPUT<br></br></div><br></br>   Итак, мы рассмотрели один из главных объектов в языке JavaScript – объект Document, представляющий собой веб-страницу, загруженную в окно браузера. Благодаря определенным свойствам и методам через объект Document можно получить доступ к любым другим объектам, расположенным на веб-странице.<br></br></div><h3 id="idm139732184818896">Доступ к объектам документа
</h3><div style="text-align: justify" class="hsection3">   Сценарии JavaScript очень часто применяются для создания динамических вебстраниц, способных получать и обрабатывать произвольную информацию. Для этого необходимо организовать доступ сценария к определенным элементам веб-страницы.<br></br>   Доступ к различным объектам HTML-документа в языке JavaScript организован в строгом соответствии с иерархией объектов. Каждый объект иерархической структуры имеет свое имя.<br></br>   Например, на веб-странице может находиться несколько изображений с именами img1, img2 и img3. Если вы хотите обратиться к первому рисунку, то должны сориентироваться в иерархии объектов и начать с самой ее вершины. Главный объект на веб-странице называется Document. Все изображения на странице представлены как коллекция images. Причем первый рисунок всегда обозначается как images [0], второй как images [1], третий как images [2] и т. д. Иными словами, отсчет объектов в коллекции начинается не с единицы, а с нуля.<br></br>   Таким образом, вы можете получить доступ к первому изображению img1, записав в сценарии JavaScript document.images[0]. Чтобы получить доступ ко второму изображению img2, запишите в сценарии строку document. images [1]. Соответственно для получения доступа к третьему изображению img3 на веб-странице используйте конструкцию document.images[2].<br></br><blockquote><div>   <b>Примечание</b><br></br>
   Как видите, номер изображения на веб-странице и номер изображения в коллекции отличаются на единицу.<br></br>
</div></blockquote>   Тот же принцип действует по отношению к ссылкам и формам. Если вы хотите получить доступ к какому-либо элементу формы, снова необходимо начать с вершины иерархии объектов. Затем прослеживаете путь к объекту и последовательно записываете названия всех объектов, которые минуете.<br></br>   Например, чтобы узнать, какой текст ввел посетитель вашей веб-страницы в поле формы, необходимо обратиться к значению (value) данного поля. Для этого в сценарии JavaScript можно записать строку name= document. forms [0]. elements [0]. value. Полученная строка заносится в переменную name. И теперь вы можете работать с этой переменной, используя ее в других строках сценария JavaScript.<br></br>   Однако, если вы создаете сложную веб-страницу, процедура адресации к различным объектам по номеру становится весьма затруднительной. Например, довольно неудобно обращаться к объекту через строку document. forms [4]. elements [15]. Можно запутаться в количестве объектов на странице и неправильно указать номер нужного объекта.<br></br>   Во избежание подобной проблемы в JavaScript можно не только пользоваться существующими коллекциями объекта Document, но и самим присваивать различным объектам уникальные имена. Например, форме на вашей веб-странице можно присвоить имя myform с помощью оператора name: &lt;form name="myform"&gt;. Эта запись означает, что первая форма, соответствующая объекту forms[0], получает уникальное имя myform.<br></br>   Точно так же нужно поступать по отношению к любому элементу формы. Вместо elements[0] вы можете указывать оператор name. Вместо name = document. forms[0].elements[0].value можно записать name = document.myf orm. element name.value.<br></br>   Такой прием значительно упрощает доступ к элементам HTML-документа, а следовательно, и программирование на JavaScript, особенно в случае с большими веб-страницами, содержащими множество объектов.<br></br><blockquote><div>   <b>Внимание!</b><br></br>
   При написании имен объектов обязательно следите за положением регистра. Нельзя писать Myform вместо myform, поскольку язык JavaScript чувствителен к регистру и будет воспринимать их как совершенно разные имена объектов.<br></br>
</div></blockquote>   Таким образом, доступ к объектам HTML-документа можно получить двумя способами:<br></br>   • используя коллекции и нумерацию объектов;<br></br>   • присваивая каждому объекту уникальное имя.<br></br>   В любом из этих случаев вам необходимо будет определить имя объекта и всех его предков. Объект высшего уровня всегда находится слева в выражении, и слева направо происходит переход к дочерним объектам. По правилам языка JavaScript родительские и дочерние объекты отделяются друг от друга точками.<br></br>   Рассмотрим несколько примеров, иллюстрирующих способы доступа к объектам веб-страницы.<br></br>   В листинге 10.22 приведен текст сценария, в котором данные, введенные пользователем в поле формы, передаются в функцию для дальнейшей обработки.<br></br><h5 class="subtitle"><b>Листинг 10.22.</b> Передача данных в функцию</h5>   &lt;html&gt;<br></br>   &lt;head&gt;<br></br>   &lt;!–Код JavaScript –&gt;<br></br>   &lt;script language="JavaScript"&gt;<br></br>   function doit()<br></br>   {<br></br>   var greeting="Мне нравится "<br></br>   alert(greeting + document.aform.color.value<br></br>   + " " + document.aform.geometr.value)<br></br>   var prich="Потому, что "<br></br>   alert(prich + document.aform.prichina.value)<br></br>   alert("Количество букв в названии вашей фигуры "<br></br>   + document.aform.geometr.value.length)<br></br>   }<br></br>   &lt;/script&gt;<br></br>   &lt;/head&gt;<br></br>   &lt;body&gt;<br></br>   &lt;center&gt;<br></br>   &lt;!–Форма –&gt;<br></br>   &lt;form name="aform"&gt;<br></br>   Ваша любимая геометрическая фигура:<br></br>   &lt;input type="text" NAME="geometr"&gt;&lt;p&gt;<br></br>   Ваш любимый цвет:<br></br>   &lt;input type="text" NAME="color"&gt;&lt;p&gt;<br></br>   Почему вам нравится эта фигура:<br></br>   &lt;input type="text" NAME="prichina"&gt;&lt;p&gt;<br></br>   &lt;input type="button" VALUE="Ответить" onClick="doit()"&gt;<br></br>   &lt;/form&gt;<br></br>   &lt;/center&gt;<br></br>   &lt;/body&gt;<br></br>   &lt;/html&gt;<br></br>   В данном HTML-документе расположена форма с полями ввода и кнопкой (рис. 10.22). При ее нажатии обработчик событий onClick запускает функцию doit(), обрабатывающую данные, введенные пользователем в поля формы.<br></br><div class="wrap_pict"><div style="text-align: center;"><img src="i_131.png" alt=""></img></div>   <b>Рис. 10.22.</b> Элементы формы<br></br></div><br></br>   Доступ к объектам формы в данном сценарии организован путем присвоения каждому объекту формы уникального имени и перечисления всех объектов в соответствии с их иерархией в документе.<br></br>   Самой форме присвоено имя aform. Каждому полю ввода также присвоены уникальные имена: geometr, color, prichina. Введенные пользователем данные передаются в функцию как значение value. В соответствии с иерархией объектов на первом месте стоит объект Document, далее идет форма, затем поле формы и, наконец, значение поля – текст, введенный пользователем.<br></br>   В сценарии эта цепочка объектов выглядит следующим образом: document. aform.geometr.value. Таким образом, функция doit() получает данные пользователя из значения value поля geometr формы aform в HTML-документе document. Аналогично происходит передача данных в функцию из других полей формы.<br></br>   Данные, полученные от формы, отображаются функцией в окне Alert (рис. 10.23).<br></br><div class="wrap_pict"><div style="text-align: center;"><img src="i_132.png" alt=""></img></div>   <b>Рис. 10.23.</b> Результат работы сценария<br></br></div><br></br>   Рассмотрим еще один пример сценария JavaScript (листинг 10.23).<br></br><h5 class="subtitle"><b>Листинг 10.23.</b> Смена изображений на веб-странице</h5>   &lt;html&gt;<br></br>   &lt;head&gt;<br></br>   &lt;title&gt;Смена картинок через массив&lt;/title&gt;<br></br>   &lt;!–Код JavaScript –&gt;<br></br>   &lt;script language="JavaScript"&gt;<br></br>   function myimage(pic) //функция<br></br>   {<br></br>   document.images[0].src=pic<br></br>   }<br></br>   &lt;/script&gt;<br></br>   &lt;/head&gt;<br></br>   &lt;body text="#000000" bgcolor="#FFFFCC" link="#0000EE" vlink="#551A8B" alink="#FF0000"&gt;<br></br>   &lt;!– Элементы страницы –&gt;<br></br>   &lt;h1&gt;<br></br>   &lt;font color="#000099"&gt;Просмотр фотографий&lt;/FONT&gt;<br></br>   &lt;/h1&gt;<br></br>   &lt;center&gt;<br></br>   &lt;table cols=2 width="100%"&gt;<br></br>   &lt;caption&gt;<br></br>   &lt;font color="#000099" size=+2&gt;Природа&lt;/font&gt;<br></br>   &lt;/caption&gt;<br></br>   &lt;tr&gt;<br></br>   &lt;td&gt;<br></br>   &lt;ul&gt;<br></br>   &lt;li&gt;&lt;a href="javascript:myimage('a.jpg')"&gt;картинка1&lt;/li&gt;<br></br>   &lt;li&gt;&lt;a href="javascript:myimage('b.jpg')"&gt;картинка2&lt;/li&gt;<br></br>   &lt;li&gt;&lt;a href="javascript:myimage('c.jpg')"&gt;картинка3&lt;/li&gt;<br></br>   &lt;li&gt;&lt;a href="javascript:myimage('d.jpg')"&gt;картинка4&lt;/li&gt;<br></br>   &lt;li&gt;&lt;a href="javascript:myimage('e.jpg')"&gt;картинка5&lt;/li&gt;<br></br>   &lt;li&gt;&lt;a href="javascript:myimage('f.jpg')"&gt;картинка6&lt;/li&gt;<br></br>   &lt;li&gt;&lt;a href="javascript:myimage('g.jpg')"&gt;картинка7&lt;/li&gt;<br></br>   &lt;/ul&gt;<br></br>   &lt;/td&gt;<br></br>   &lt;td align=center valign=center&gt;<br></br>   &lt;img src="d.jpg"&gt; &lt;/td&gt;<br></br>   &lt;/tr&gt;<br></br>   &lt;/table&gt;<br></br>   &lt;/center&gt;<br></br>   &lt;/body&gt;<br></br>   &lt;/html&gt;<br></br><br></br>   Данный сценарий позволяет просматривать различные фотографии природы на веб-странице (рис. 10.24).<br></br><div class="wrap_pict"><div style="text-align: center;"><img src="i_133.png" alt=""></img></div>   <b>Рис. 10.24.</b> Просмотр фотографий на странице<br></br></div><br></br>   В HTML-документе размещена таблица с двумя столбцами. В первом столбце находятся ссылки на изображения, которые загружаются во второй столбец. Без сценария JavaScript реализация такой задачи практически невозможна.<br></br>   Сам сценарий находится в заголовке HEAD HTML-документа. Он содержит функцию myimage(pic), которой передаются названия рисунков. В функции определена строка, ответственная за смену изображений: document. images [0]. src=pic. Как видите, в данной строке указаны объект Document, массив изображений на странице (images [0]) и источник изображений (src). В массиве определен индекс [0], поскольку в веб-странице отображается только одна картинка. Как вы помните, нулевой индекс в коллекции соответствует первому изображению в HTML-документе.<br></br>   Изначально на странице отображается картинка d.jpg. Это определено в строке &lt;IMG SRC="d.jpg"&gt;. При щелчке кнопкой мыши на ссылке с названием картинки запускается сценарий: &lt;A HREF="javascript: myimage ('a.jpg')"&gt;. Фотографии сменяют друг друга благодаря тому, что название изображения из скобок передается в строку document.images [0].src=pic. Значение pic заменяется названием фотографии из выбранной ссылки, например 'a.jpg'. При выборе следующей ссылки значение pic опять заменяется названием фотографии, а точнее именем файла с изображением.<br></br>   С помощью данного сценария можно организовать удобный просмотр фотографий в одном окне браузера на одной веб-странице. Этот прием довольно часто используется в фотогалереях и интернет-магазинах.<br></br>   Итак, мы рассмотрели объекты HTML-документа. Это сама веб-страница и расположенные на ней элементы. Все они обладают своими свойствами. К каждому из них можно применить определенные действия, или методы. Эти методы позволяют управлять содержимым веб-страницы и динамически его изменять.<br></br></div></div><h2 id="idm139732192843216">Резюме
</h2><div style="text-align: justify" class="hsection2">   В этой главе вы познакомились с фундаментальными понятиями языка JavaScript – объектами, свойствами и методами. Теперь вы сможете использовать в сценариях различные элементы окна браузера и веб-страницы, изменять их свойства и управлять ими с помощью JavaScript. Помните, что все эти элементы являются объектами. Правильное применение их свойств и методов позволит вам стать профессиональным веб-разработчиком.<br></br></div></div><h1 xmlns="http://www.w3.org/1999/xhtml" id="idm139732192844240" class="master">Глава 11<br></br>
Основы языка JavaScript
</h1><div xmlns="http://www.w3.org/1999/xhtml" style="text-align: justify" class="hsection1"><div style="text-align: justify" class="section2">   11.1. Работа с информацией<br></br>
   11.2. Переменные и типы данных<br></br>
   11.3. Выражения<br></br>
   11.4. Условия и циклы<br></br>
   11.5. Функции и события<br></br>
   11.6. Встроенные объекты JavaScript<br></br>
   Эта глава является незаменимой для новичков, так как в ней разъясняются основные элементы языка JavaScript: переменные, типы данных, выражения, различные операторы, функции и т. д. Эти знания являются базовыми – без них невозможно понимание остального материала книги.<br></br>
</div><h2 id="idm139732192848208">11.1. Работа с информацией
</h2><div style="text-align: justify" class="hsection2"><div style="text-align: justify" class="section3">   Любая программа или сценарий работают с информацией, то есть получают некие данные, обрабатывают их согласно своему алгоритму, а затем обычно возвращают результат в виде изображения на экране или бумаге, звука, файла, сигнала другой программе и т. д.<br></br>
   Серверные программы получают данные либо от пользователя, например через формы, либо из баз данных. При этом в качестве обрабатываемой информации могут выступать абсолютно любые данные: опросы, регистрационные данные, фотографии, почта, статистические данные.<br></br>
   Клиентские сценарии часто выступают буфером между пользователем и серверной программой, осуществляя предварительную обработку и верификацию данных. Следовательно, они работают с теми же данными.<br></br>
   Клиентские сценарии могут получать информацию различными способами, которые описаны ниже.<br></br>
   • Информация может быть заложена в сценарий разработчиком. Обычно это некие начальные значения.<br></br>
   • Информация может передаваться от пользователя с помощью форм.<br></br>
   • Передача через URL.<br></br>
   • Получение информации обработкой событий, например после перемещения указателя мыши, щелчка кнопкой мыши, нажатия клавиш.<br></br>
   • Получение данных с других сайтов или передача серверной программой.<br></br>
   Для знакомства с вводом/выводом информации в JavaScript понадобятся три метода: alert(), prompt() и confirm().<br></br>
   Эти методы генерируют различные окна сообщений.<br></br>
<blockquote><div>   <b>Примечание</b><br></br>
   В действительности методы alert(), prompt() и confirm() являются методами объекта Window в браузере.<br></br>
</div></blockquote></div><h3 id="idm139732192805200">Метод alert()
</h3><div style="text-align: justify" class="hsection3">   Метод alert() отображает окно предупреждения с соответствующим сообщением. После прочтения сообщения пользователю необходимо нажать кнопку OK, чтобы закрыть окно. Аргументом данного метода является строка.<br></br><blockquote><div>   <b>Примечание</b><br></br>
   О типах данных в JavaScript, в том числе и о строках, будет рассказано далее в этой главе.<br></br>
</div></blockquote>   В простейшем случае текст предупреждения, заключенный в кавычки, вводится внутри круглых скобок (листинг 11.1).<br></br><h5 class="subtitle"><b>Листинг 11.1.</b> Работа с предупреждением</h5>   &lt;html&gt;<br></br>   &lt;head&gt;<br></br>   &lt;title&gt;Работа с предупреждением&lt;/title&gt;<br></br>   &lt;/head&gt;<br></br>   &lt;script&gt;<br></br>   alert("Это мое предупреждение");<br></br>   &lt;/script&gt;<br></br>   &lt;body&gt;<br></br>   &lt;/body&gt;<br></br>   &lt;/html&gt;<br></br>   Окно предупреждения генерируется самим браузером, поэтому внешний вид окна в разных браузерах может различаться. На рис. 11.1, 11.2 и 11.3 представлен вид окна, сгенерированного в трех популярных браузерах с помощью описанного кода.<br></br><div class="wrap_pict"><div style="text-align: center;"><img src="i_134.png" alt=""></img></div>   <b>Рис. 11.1.</b> Окно предупреждений в браузере Internet Explorer<br></br></div><br></br><div class="wrap_pict"><div style="text-align: center;"><img src="i_135.png" alt=""></img></div>   <b>Рис. 11.2.</b> Окно предупреждений в браузере Mozilla Firefox<br></br></div><br></br><div style="text-align: center;"><img src="i_136.png" alt=""></img></div>   <b>Рис. 11.3.</b> Окно предупреждений в браузере Opera<br></br></div><h3 id="idm139732192815568">Метод prompt()
</h3><div style="text-align: justify" class="hsection3">   Метод prompt() имеет противоположное предназначение. Он служит для получения данных от пользователя (листинг 11.2). При его вызове отображается окно приглашения с текстовым полем. Метод может содержать два аргумента. Оба этих аргумента должны быть строками. Первый аргумент – сообщение, которое отображается в окне. Второй аргумент – это текст по умолчанию, который должен появиться в соответствующем поле. Кроме того, этот метод, в свою очередь, возвращает значение, которое также является строкой, – это текст, который ввел пользователь.<br></br><h5 class="subtitle"><b>Листинг 11.2.</b> Работа с запросом</h5>   &lt;html&gt;<br></br>   &lt;head&gt;<br></br>   &lt;title&gt;Работа с запросом&lt;/title&gt;<br></br>   &lt;/head&gt;<br></br>   &lt;script&gt;<br></br>   //Объявляем переменную<br></br>   var nameUser;<br></br>   //Введенное пользователем значение присваивается переменной nameUser<br></br>   nameUser=prompt("Здравствуйте, как вас зовут?", "аноним");<br></br>   //Используем метод alert() для вывода введенного имени<br></br>   alert("Рад вас видеть, "+ nameUser);<br></br>   &lt;/script&gt;<br></br>   &lt;body&gt;<br></br>   &lt;/body&gt;<br></br>   &lt;/html&gt;<br></br>   После запуска страницы с вышеприведенным кодом появится запрос (рис. 11.4), вслед за которым отобразится предупреждение.<br></br><div class="wrap_pict"><div style="text-align: center;"><img src="i_137.png" alt=""></img></div>   <b>Рис. 11.4.</b> Работа с запросом<br></br></div><br></br>   В этом примере для демонстрации работы метода prompt() использована переменная, а в методе alert() в качестве аргумента выступает выражение. Данные понятия будут введены далее в этой главе.<br></br><blockquote><div>   <b>Примечание</b><br></br>
   В методе prompt() можно опустить второй аргумент, то есть указывать только одну строку. В этом случае различные браузеры по-разному реагируют: строка запроса может быть пустой, а может отображать ключевое слово undefined (не определено).<br></br>
</div></blockquote></div><h3 id="idm139732192793040">Метод confirm()
</h3><div style="text-align: justify" class="hsection3">   Метод confirm() отображает окно подтверждения, которое сходно с окном предупреждения, генерируемым методом alert(), но содержит две кнопки: OK и Cancel. В листинге 11.3 демонстрируется создание окна подтверждения, но в этом сценарии не делается разницы между кнопками OK и Cancel. Нажатие любой из кнопок просто закроет окно (рис. 11.5).<br></br><div class="wrap_pict"><div style="text-align: center;"><img src="i_138.png" alt=""></img></div>   <b>Рис. 11.5.</b> Работа с подтверждением<br></br></div><br></br><h5 class="subtitle"><b>Листинг 11.3.</b> Работа с подтверждением</h5>   &lt;html&gt;<br></br>   &lt;head&gt;<br></br>   &lt;title&gt;Работа с подтверждением&lt;/title&gt;<br></br>   &lt;/head&gt;<br></br>   &lt;script&gt;<br></br>   confirm("Это мое подтверждение");<br></br>   &lt;/script&gt;<br></br>   &lt;body&gt;<br></br>   &lt;/body&gt;<br></br>   &lt;/html&gt;<br></br><br></br>   После прочтения данной главы вы научитесь использовать этот метод, чтобы сценарий по-разному реагировал на нажатие кнопок OK и Cancel.<br></br></div></div><h2 id="idm139732192800080">11.2. Переменные и типы данных
</h2><div style="text-align: justify" class="hsection2"><div style="text-align: justify" class="section3">   Во время интерпретации сценария браузер разбивает код на отдельные слова, фразы или символы, которые умеет распознавать. Эти элементы называются лексемами. В языке JavaScript лексемы делятся на четыре типа: идентификаторы, ключевые слова, литералы и операции.<br></br>
</div><h3 id="idm139732192801232">Идентификаторы
</h3><div style="text-align: justify" class="hsection3">   Идентификаторами называются имена, которые обозначают переменные, функции и объекты. Некоторые имена являются ключевыми или зарезервированными и не могут использоваться в качестве идентификатора, так как имеют особый смысл. О них будет рассказано далее.<br></br>   Идентификаторы образуются с помощью комбинации различных символов, однако при этом накладываются некоторые ограничения.<br></br>   • Все идентификаторы должны начинаться с буквы.<br></br>   • После первой буквы остальными символами могут быть буквы и цифры.<br></br>   • Буквами считаются заглавные и строчные буквы латинского алфавита: от A до Z и от a до z.<br></br>   • Символ подчеркивания (_) выступает в качестве буквы и часто используется вместо пробела, который нельзя применять в идентификаторах.<br></br>   • Символ доллара ($) выступает в качестве буквы и обычно используется при автоматической генерации кода.<br></br>   • Можно использовать в качестве букв символы Unicode, однако старые версии браузеров не умеют работать с Unicode.<br></br>   • Цифрами считаются символы от 0 до 9.<br></br><blockquote><div>   <b>Совет</b><br></br>
   Не следует использовать в одном сценарии идентификаторы, отличающиеся только символами верхнего и нижнего регистра, например flagld и FlagID, так как это будут различные идентификаторы, которые могут вызвать трудноуловимые ошибки.<br></br>
</div></blockquote>   В табл. 11.1 приведены примеры допустимых и недопустимых идентификаторов.<br></br><h5 class="subtitle"><b>Таблица 11.1.</b> Примеры идентификаторов JavaScript</h5><div style="text-align: center;"><img src="i_139.png" alt=""></img></div>   Обратите внимание, что идентификатор new хотя и содержит разрешенные символы, но относится к числу ключевых слов, поэтому не может выступать в качестве пользовательского идентификатора.<br></br></div><h3 id="idm139732187696336">Ключевые и зарезервированные слова
</h3><div style="text-align: justify" class="hsection3">   К ключевым словам относятся предопределенные идентификаторы, которые образуют ядро языка JavaScript. Эти слова имеют особый смысл и выполняют определенные функции. Ключевые слова не могут использоваться для пользовательских идентификаторов. В табл. 11.2 представлен список ключевых слов JavaScript.<br></br><h5 class="subtitle"><b>Таблица 11.2.</b> Ключевые слова JavaScript</h5><div style="text-align: center;"><img src="i_140.png" alt=""></img></div>   Зарезервированные слова не рекомендуется использовать в качестве пользовательских идентификаторов, так как в последующем планируется использовать их в качестве ключевых слов. Список зарезервированных слов приведен в табл. 11.3.<br></br><h5 class="subtitle"><b>Таблица 11.3.</b> Зарезервированные слова JavaScript</h5><div style="text-align: center;"><img src="i_141.png" alt=""></img></div><blockquote><div>   <b>Совет</b><br></br>
   Конечно, вы можете использовать зарезервированные слова для своих идентификаторов, но это не гарантирует работоспособности ваших сценариев в будущем, когда зарезервированные слова могут перейти в состав ключевых.<br></br>
</div></blockquote></div><h3 id="idm139732187700432">Литералы
</h3><div style="text-align: justify" class="hsection3">   Литералы – это числа или строки, которые применяются для представления значений в JavaScript. Поскольку информация может быть разнообразной, то значения могут быть различных видов. Простейшие типы данных в JavaScript называют основными типами данных: числа, строки и логические значения.<br></br><h5 class="subtitle">Числа</h5>   В языке JavaScript различают два типа чисел: целые числа и числа с плавающей точкой.<br></br>   Целочисленные величины могут быть положительными, например 1, 2, 3, и отрицательными, например -1, -2, -3. К целочисленным величинам также относится нуль – 0. Кроме того, целочисленные величины могут быть выражены в десятичной, восьмеричной или шестнадцатеричной системах счисления.<br></br>   Числа в десятичном формате могут включать любую последовательность цифр от 0 до 9, которая не начинается с нуля.<br></br>   Числа в восьмеричном формате могут включать любую последовательность цифр от 0 до 7, которая обязательно начинается с нуля.<br></br>   Числа в шестнадцатеричном формате могут включать любую последовательность цифр от 0 до 9 и буквы от a до f, которая обязательно начинается с 0x.<br></br>   В табл. 11.4 рассмотрены примеры представления целых чисел в различных форматах.<br></br><h5 class="subtitle"><b>Таблица 11.4.</b> Примеры целых чисел</h5><div style="text-align: center;"><img src="i_142.png" alt=""></img></div><blockquote><div>   <b>Совет</b><br></br>
   Будьте внимательны с использованием восьмеричного формата, так как обычно браузеры интерпретируют числа как десятичные, даже если они начинаются с нуля, если в их составе есть цифры 8 или 9. Например, число 076 – это 62, а 078 – это 78.<br></br>
</div></blockquote>   Числа с плавающей точкой определяют десятичные числа с дробной частью. Эти числа могут быть выражены в обычном или экспоненциальном виде. В последнем случае для представления порядка используется символ e или E. И десятичная мантисса, и порядок могут быть положительными или отрицательными. Ниже показаны примеры чисел с плавающей точкой:<br></br>   1,4142135623730950488016887242097<br></br>   –35.0<br></br>   4567.0002<br></br>   3.4e100<br></br>   –5.456e–3<br></br>   0.007<br></br><br></br><blockquote><div>   <b>Внимание!</b><br></br>
   Число, начинающееся с нескольких нулей и содержащее десятичную точку, например 000.45, расценивается некоторыми браузерами как ошибка.<br></br>
</div></blockquote><blockquote><div>   <b>Примечание</b><br></br>
   Числа с плавающей точкой могут быть очень большими и очень маленькими: от 10<sup>-323</sup> до 10<sup>308</sup>.<br></br>
</div></blockquote><h5 class="subtitle">Логические величины</h5>   В языке JavaScript есть поддержка логических типов данных, которые могут принимать лишь два значения: true (истина) и false (ложь). Логические (булевые) величины необходимы для работы с условиями, с которыми вы познакомитесь дальше в этой главе.<br></br><blockquote><div>   <b>Внимание!</b><br></br>
   Ключевые слова true и false обязательно должны вводиться буквами нижнего регистра.<br></br>
</div></blockquote><h5 class="subtitle">Строки</h5>   Наверное, наиболее часто используемым типом данных в JavaScript является строка. Строка – это набор символов, возможно пустой, заключенный в одинарные или двойные кавычки. Использование двух типов кавычек введено потому, что строка может содержать и кавычки какого-либо вида. Далее представлены примеры строковых литералов:<br></br><br></br>   «Строка текста»<br></br>   "Россия!"<br></br>   "4567"<br></br>   ""<br></br>   'Операционные системы'<br></br>   'Льюис Кэрролл "Алиса в стране чудес"'<br></br><h5 class="subtitle">Специальные символы</h5>   Иногда может возникнуть необходимость дать компьютеру команду на использование специальных символов, например табуляции или перевода строки. Чтобы ввести в строку любой Unicode-символ, нужно указать его код после \u в виде \uXXXX. В табл. 11.5 представлены наиболее часто используемые управляющие символы.<br></br><h5 class="subtitle"><b>Таблица 11.5.</b> Управляющие символы</h5><div style="text-align: center;"><img src="i_143.png" alt=""></img></div><br></br>   Часто управляющие символы используются для выравнивания данных (листинг 11.4).<br></br><h5 class="subtitle"><b>Листинг 11.4.</b> Выравнивание с помощью управляющих символов</h5>   &lt;html&gt;<br></br>   &lt;head&gt;<br></br>   &lt;title&gt; Выравнивание с помощью управляющих символов &lt;/title&gt;<br></br>   &lt;/head&gt;<br></br>   &lt;script&gt;<br></br>   alert("Имя:\t\tВася\nФамилия:\t\tПетров\nКомпания:\tВася&amp;K");<br></br>   &lt;/script&gt;<br></br>   &lt;body&gt;<br></br>   &lt;/body&gt;<br></br>   &lt;/html&gt;<br></br><br></br>   Поскольку окно, создаваемое методом alert(), зависит от браузера, то и выравнивание в различных браузерах происходит по-разному. На рис. 11.6 показан результат выполнения вышеприведенного кода, адаптированного к браузеру Internet Explorer.<br></br><div class="wrap_pict"><div style="text-align: center;"><img src="i_144.png" alt=""></img></div>   <b>Рис. 11.6.</b> Выравнивание с помощью управляющих символов<br></br></div><br></br><h5 class="subtitle">Специальные типы данных</h5>   Помимо чисел, строк и логических величин, существует еще два типа данных: функции и объекты. Функции могут быть встроенными, например alert(), а могут быть созданы разработчиком. Кроме того, функции могут принадлежать объекту, тогда они называются методами. Объекты также могут быть встроенными, например document, а могут быть созданы программистом. Считается, что значение null является объектом.<br></br>   Если браузер не может определить тип данных, то он присваивает им значение undefined (неопределяемый).<br></br></div><h3 id="idm139732187643088">Переменные
</h3><div style="text-align: justify" class="hsection3">   Переменная – это имя, присваиваемое ячейке памяти компьютера, которая хранит определенные данные во время работы сценария. Переменные есть в каждом языке программирования, даже в низкоуровневом языке Ассемблер. Они облегчают программисту работу по манипулированию с данными.<br></br>   Имя переменной является идентификатором, поэтому подчиняется тем же правилам.<br></br><h5 class="subtitle">Объявление переменных</h5>   Объявление переменной означает, что вы даете команду зарезервировать место для хранения данных, при этом указанный идентификатор будет использоваться в качестве имени переменной. Чтобы объявить переменную, надо после ключевого слова var указать ее идентификатор. Можно сразу объявить несколько переменных, задав их имена через запятую.<br></br>   Рассмотрим примеры объявлений переменных:<br></br>   var myData1;<br></br>   var x,y,z;<br></br>   var k, msg1, msg2, IM;<br></br>   В процессе объявления переменную можно проинициализировать, то есть установить для нее начальное значение:<br></br>   var myStr="Здравствуйте, ";<br></br>   var k=1000, x=12, y=-5;<br></br>   var s=1.34e–5, msg11="Error", Flag=false;<br></br>   Пока переменная не получит значение, она не определена – undefined. Чтобы определить тип переменной, можно использовать операцию typeof, которая возвращает строку с типом переменной (листинг 11.5).<br></br><h5 class="subtitle">Листинг 11.5. Типы данных</h5>   &lt;html&gt;<br></br>   &lt;head&gt;<br></br>   &lt;title&gt;Типы данных&lt;/title&gt;<br></br>   &lt;/head&gt;<br></br>   &lt;body&gt;<br></br>   &lt;h2&gt;Типы данных&lt;/h2&gt;<br></br>   &lt;pre&gt;<br></br>   &lt;script&gt;<br></br>   //Объявляем переменные<br></br>   var i=45.78, msg="Строка";<br></br>   var f=false, y;<br></br>   //Выводим типы переменных<br></br>   document.write("\n"+"Переменная i="+i+" – "+ typeof(i)+"\n");<br></br>   document.write("Переменная msg="+msg+" – "+ typeof(msg)+"\n");<br></br>   document.write("Переменная f="+f+" – "+ typeof(f)+"\n");<br></br>   document.write("Переменная y ="+y+" – "+ typeof(y)+"\n");<br></br>   //Инициализируем переменную y<br></br>   y=null;<br></br>   document.write("А теперь переменная y="+y+" – "+ typeof(y)+"\n");<br></br>   &lt;/script&gt;<br></br>   &lt;/pre&gt;<br></br>   &lt;/body&gt;<br></br>   &lt;/html&gt;<br></br>   В вышеприведенном коде для вывода информации используется метод document. write(), который позволяет дописывать строку текста прямо в страницу (рис. 11.7).<br></br><div class="wrap_pict"><div style="text-align: center;"><img src="i_145.png" alt=""></img></div>   <b>Рис. 11.7.</b> Типы данных<br></br></div><br></br>   Для вывода текста, значений переменных и их типа аргументом данного метода выступает довольно сложное выражение. Более подробно выражения будут рассмотрены далее в этой главе.<br></br><blockquote><div>   <b>Совет</b><br></br>
   Язык JavaScript относится к числу языков, слабо контролирующих типы данных, поэтому одна переменная может в ходе работы сценария принимать значения различных типов. Однако такого следует избегать, так как это может привести к трудноуловимым ошибкам и усложнить понимание кода.<br></br>
</div></blockquote><h5 class="subtitle">Область действия переменных</h5>   Переменные могут быть глобальными и локальными. Понятие области действия переменных тесно связано с функциями, которые являются отдельными блоками кода. Переменная, объявленная внутри функции, является локальной, и только эта функция имеет доступ к ее значению. Локальные переменные создаются и уничтожаются вместе с соответствующей функцией. Глобальные переменные должны объявляться вне функций. Такие переменные позволяют функциям обмениваться данными.<br></br></div><h3 id="idm139732187612624">Массивы
</h3><div style="text-align: justify" class="hsection3">   Массив – это особая переменная, позволяющая хранить сразу несколько значений. Обычно эти значения связаны между собой, например массив может содержать названия месяцев. Массивы могут существенно упростить код и при использовании циклов снизить трудоемкость разработки сценария.<br></br>   Рассмотрим пример объявления и задания значений элементов массива (листинг 11.6).<br></br><h5 class="subtitle"><b>Листинг 11.6.</b> Работа с массивом</h5>   &lt;html&gt;<br></br>   &lt;head&gt;<br></br>   &lt;title&gt;Работа с массивом&lt;/title&gt;<br></br>   &lt;script&gt;<br></br>   //Объявляем массив с 5 элементами<br></br>   var stars= new Array(5);<br></br>   //Задание значений элементам массива<br></br>   stars[0]='Сириус';<br></br>   stars[1]=' Канопус';<br></br>   stars[2]=' Арктур';<br></br>   stars[3]=' Капелла';<br></br>   stars[4]=' Вега';<br></br>   //Вывод первого элемента массива<br></br>   alert(stars[0]);<br></br>   //Вывод всех элементов массива<br></br>   alert(stars);<br></br>   &lt;/script&gt;<br></br>   &lt;/head&gt;<br></br>   &lt;body&gt;<br></br>   &lt;/body&gt;<br></br>   &lt;/html&gt;<br></br>   Обратите внимание, что при объявлении массива количество элементов указывается в круглых скобках, а при обращении к элементу его индекс указывается в квадратных скобках. Кроме того, в языке JavaScript нумерация элементов массива начинается с нуля, поэтому первый элемент массива – stars[0].<br></br>   Язык JavaScript позволяет не перечислять все элементы по одному, а сразу вывести все элементы массива. Для этого необходимо обратиться к самому массиву, в результате чего получится строка, в которой все элементы массива перечислены через запятую (рис. 11.8).<br></br><div class="wrap_pict"><div style="text-align: center;"><img src="i_146.png" alt=""></img></div>   <b>Рис. 11.8.</b> Вывод всех элементов массива<br></br></div><br></br>   Значения элементов массива можно задать при его объявлении, тогда не нужно указывать количество элементов в массиве (листинг 11.7).<br></br><h5 class="subtitle"><b>Листинг 11.7.</b> Инициализация массива</h5>   &lt;html&gt;<br></br>   &lt;head&gt;<br></br>   &lt;title&gt;Инициализация массива&lt;/title&gt;<br></br>   &lt;script&gt;<br></br>   //Объявляем массив и инициализируем значения элементов<br></br>   var stars= new Array('Сириус',' Канопус',' Арктур',' Капелла',' Вега');<br></br>   //Вывод первого элемента массива<br></br>   alert(stars[0]);<br></br>   //Вывод всех элементов массива<br></br>   alert(stars);<br></br>   &lt;/script&gt;<br></br>   &lt;/head&gt;<br></br>   &lt;body&gt;<br></br>   &lt;/body&gt;<br></br>   &lt;/html&gt;<br></br><br></br>   Размерность массива можно не указывать, так как язык JavaScript этого не требует. Таким образом, можно постепенно расширять массив по мере добавления данных. Более того, можно объявить элемент с индексом n, что увеличит длину массива до n+1. Узнать длину массива можно с помощью свойства length (листинг 11.8).<br></br><h5 class="subtitle"><b>Листинг 11.8.</b> Размер массива</h5>   &lt;html&gt;<br></br>   &lt;head&gt;<br></br>   &lt;title&gt;Размер массива&lt;/title&gt;<br></br>   &lt;script&gt;<br></br>   //Объявляем массив и инициализируем значения элементов<br></br>   var stars= new Array('Сириус',' Канопус',' Арктур',' Капелла',' Вега');<br></br>   stars[99]='Ригель';//Создаем 100-й элемент<br></br>   //Вывод размера массива<br></br>   alert(stars.length);<br></br>   &lt;/script&gt;<br></br>   &lt;/head&gt;<br></br>   &lt;body&gt;<br></br>   &lt;/body&gt;<br></br>   &lt;/html&gt;<br></br><br></br>   Несмотря на то что фактически элементов в массиве шесть, длина массива равна 100 (рис. 11.9).<br></br><div style="text-align: center;"><img src="i_147.png" alt=""></img></div>   <b>Рис. 11.9.</b> Размер массива<br></br></div></div><h2 id="idm139732187606736">11.3. Выражения
</h2><div style="text-align: justify" class="hsection2"><div style="text-align: justify" class="section3">   Выражения являются комбинациями операндов с помощью операций. Обычно в качестве операндов выступают значения и переменные, но могут выступать и другие выражения. Например, выражение 4 + 6 складывает два значения, в результате чего получается значение 10. А выражение q=5 присваивает переменной q значение 5. Если манипуляции производятся с одной величиной, то операция называется унарной, а если с двумя, то бинарной. Рассмотрим операции в JavaScript.<br></br>
</div><h3 id="idm139732187607888">Операции присвоения
</h3><div style="text-align: justify" class="hsection3">   Одной из часто используемых операций является операция присвоения. В простейшем случае эта операция присваивает значение переменной:<br></br>   a=7<br></br>   Она может одновременно использоваться для нескольких переменных:<br></br>   msg1=msg2="Привет"<br></br>   Остальные операции присваивания являются комбинацией операции присваивания и арифметической или поразрядной операции (табл. 11.6 и 11.7).<br></br><h5 class="subtitle"><b>Таблица 11.6.</b> Комбинация с арифметическими операциями</h5><div style="text-align: center;"><img src="i_148.png" alt=""></img></div><br></br><h5 class="subtitle"><b>Таблица 11.7.</b> Комбинация с поразрядными операциями</h5><div style="text-align: center;"><img src="i_149.png" alt=""></img></div></div><h3 id="idm139732187579984">Арифметические операции
</h3><div style="text-align: justify" class="hsection3">   Для работы с числами используют арифметические операции.<br></br>   • Сложение – знак плюс (+). Например, 5 + 7 = 12.<br></br>   • Вычитание – знак минус (-). Например, 67 – 43 = 24.<br></br>   • Умножение – звездочка (*). Например, 2 * 2 = 4.<br></br>   • Деление – косая черта (/). Например, 45 / 5 = 9.<br></br>   • Остаток от деления – процент (%). Например, 7 % 5 = 2.<br></br>   В программировании очень часто встречаются операции увеличения или уменьшения переменной на единицу, которые называются операциями инкремента и декремента. Для обозначения инкремента используется последовательность ++, а для обозначения декремента – последовательность —. Например, i++ является альтернативой выражению i=i + 1. Различают префиксную и постфиксную форму этих операций. В случае префиксной операции сначала выполняется инкремент или декремент, а затем вычисляется выражение:<br></br>   i = 4<br></br>   ++i * 2 = 10<br></br>   Если же используется постфиксная операция, то сначала вычисляется выражение, а затем производится увеличение или уменьшение переменной:<br></br>   i = 4<br></br>   i++ * 2 = 8<br></br>   Помимо инкремента и декремента, есть еще две унарные арифметические операции: унарный плюс и унарный минус. Унарный минус изменяет знак числа, а унарный плюс преобразует операнд в число.<br></br>   В листинге 11.9 демонстрируется работа с арифметическими операциями.<br></br><h5 class="subtitle"><b>Листинг 11.9.</b> Арифметические операции</h5>   &lt;html&gt;<br></br>   &lt;head&gt;<br></br>   &lt;title&gt;Арифметические операции&lt;/title&gt;<br></br>   &lt;/head&gt;<br></br>   &lt;body&gt;<br></br>   &lt;h2&gt;Арифметические операции &lt;/h2&gt;<br></br>   &lt;pre&gt;<br></br>   &lt;script&gt;<br></br>   var i=5, z<br></br>   document.write("\nПеременная i="+i+"\n");<br></br>   z=i+56*2;<br></br>   document.write("z=i+56*2="+z+"\n");<br></br>   z=6.7*2-i;<br></br>   document.write("z=6.7*2-i="+z+"\n");<br></br>   z=i++ +10;<br></br>   document.write("z=i++ +10="+z+"\n");<br></br>   document.write("Переменная i="+i+"\n");<br></br>   z=–i *4;<br></br>   document.write("z=–i *4="+z+"\n");<br></br>   document.write("Переменная i="+i+"\n");<br></br>   z=(5+11)%8;<br></br>   document.write("z=(5+11)%8="+z+"\n");<br></br>   &lt;/script&gt;<br></br>   &lt;/pre&gt;<br></br>   &lt;/body&gt;<br></br>   &lt;/html&gt;<br></br>   В этом примере можно заметить, что арифметические операции подчиняются математическим правилам. Например, умножение совершается до сложения (рис. 11.10). Это выполняется за счет приоритета операций, который можно изменить, используя скобки.<br></br><div style="text-align: center;"><img src="i_150.png" alt=""></img></div>   <b>Рис. 11.10.</b> Арифметические операции<br></br></div><h3 id="idm139732198035280">Операции сравнения
</h3><div style="text-align: justify" class="hsection3">   Операции сравнения используются для сопоставления операндов. В этих операциях операндами могут быть не только числа, но и строки, логические величины и объекты. В табл. 11.8 приведены все операции сравнения.<br></br><h5 class="subtitle"><b>Таблица 11.8.</b> Операции сравнения</h5><div style="text-align: center;"><img src="i_151.png" alt=""></img></div>   В листинге 11.10 показана работа с операциями сравнения.<br></br><h5 class="subtitle"><b>Листинг 11.10.</b> Операции сравнения</h5>   &lt;html&gt;<br></br>   &lt;head&gt;<br></br>   &lt;title&gt;Операции сравнения&lt;/title&gt;<br></br>   &lt;/head&gt;<br></br>   &lt;body&gt;<br></br>   &lt;h2&gt;Операции сравнения&lt;/h2&gt;<br></br>   &lt;pre&gt;<br></br>   &lt;script&gt;<br></br>   var i=5, m1="строка1";<br></br>   var m2;<br></br>   document.write("\nПеременная i="+i+"\n");<br></br>   document.write("i&gt;7 – ");<br></br>   //Результат сравнения<br></br>   document.write(i&gt;7);<br></br>   document.write("\n(3+i)&gt;=8 – ");<br></br>   //Результат сравнения<br></br>   document.write((3+i)&gt;=8);<br></br>   m2="строка1"<br></br>   document.write("\nПеременная m1="+m1);<br></br>   document.write(", переменная m2="+m2+"\n");<br></br>   document.write("m1!=m2 – ");<br></br>   document.write( m1!=m2);<br></br>   m2="строка2"<br></br>   document.write("\nПеременная m1="+m1+", переменная m2="+m2+"\n");<br></br>   document.write("m1&lt;=m2 – ");<br></br>   document.write(m1&lt;=m2);<br></br>   m2="5"<br></br>   document.write("\nПеременная i="+i+", переменная m2="+m2+"\n");<br></br>   document.write("i==m2 – ");<br></br>   document.write(i==m2);<br></br>   document.write("\ni===m2 – ");<br></br>   document.write( i===m2);<br></br>   document.write("\ni===5 – ");<br></br>   document.write(i===5);<br></br>   &lt;/script&gt;<br></br>   &lt;/pre&gt;<br></br>   &lt;/body&gt;<br></br>   &lt;/html&gt;<br></br><br></br>   В приведенном коде сравниваются переменные i = 5 и m2 = "5". Они считаются равными, но не идентичными (рис. 11.11).<br></br><div style="text-align: center;"><img src="i_152.png" alt=""></img></div>   <b>Рис. 11.11.</b> Операции сравнения<br></br></div><h3 id="idm139732198021200">Операции над строками
</h3><div style="text-align: justify" class="hsection3">   Как уже говорилось, строки можно сравнивать. Кроме того, строки можно объединять с помощью операции конкатенации (+), что мы уже не раз делали. Например:<br></br>   S1="Здравствуй";<br></br>   S2=",";<br></br>   S3="Мир!";<br></br>   S=S1+S2+" "+S3;<br></br>   В итоге переменная S будет содержать строку «Здравствуй, Мир!».<br></br>   Благодаря автоматическому приведению типов можно объединять числа и строки:<br></br>   «год „+1984=“год 1984»<br></br></div><h3 id="idm139732198025424">Логические операции
</h3><div style="text-align: justify" class="hsection3">   Логические операции позволяют комбинировать выражения, возвращающие логические величины. Язык JavaScript поддерживает три логические операции.<br></br>   Операция <i>логического И</i> (&amp;&amp;) возвращает true, если только оба операнда истинны. Например, (1&lt;7)&amp;&amp;(3&gt;2). При этом сначала вычисляется левый операнд. Если он ложен, то второй операнд не вычисляется, что надо учитывать. Так, в строке (3&lt;1)&amp;&amp;(i++&lt;7) операция инкремента переменной i не произойдет.<br></br>   Операция <i>логического ИЛИ</i> (||) возвращает true, если хотя бы один операнд истинен. Например, (2&lt;3) || (1&gt;2). При этом сначала вычисляется левый операнд. Если он истинен, то второй операнд не вычисляется.<br></br>   Операция <i>логического НЕ</i> (!) является унарной и изменяет значение логической величины на обратное.<br></br></div><h3 id="idm139732197995984">Условные операции
</h3><div style="text-align: justify" class="hsection3">   В JavaScript есть одна тернарная операция?:, которая позволяет присвоить значение переменной в зависимости от выполнения условия. Рассмотрим следующий пример:<br></br>   var sign = (a&gt;=0) ? «Положительное»: «Отрицательное»;<br></br>   В зависимости от результата выражения до вопросительного знака переменная принимает одно из значений: если значение истинно, то вычисляется выражение до двоеточия, если ложно, то выражение, стоящее после двоеточия. В данном случае, если переменная a больше или равна 0, переменная sign принимает значение «Положительное», иначе переменная sign принимает значение «Отрицательное».<br></br></div><h3 id="idm139732197998032">Поразрядные операции
</h3><div style="text-align: justify" class="hsection3">   Очень редко в сценариях JavaScript используются поразрядные операции, позволяющие манипулировать числами на уровне битов. Различают поразрядные логические операции и поразрядные операции сдвига. Для хранения целочисленных значений в JavaScript выделяется 32 бита. Для демонстрации работы поразрядных операций лучше использовать двоичную систему (табл. 11.9 и 11.10).<br></br><h5 class="subtitle"><b>Таблица 11.9.</b> Поразрядные логические операции</h5><div style="text-align: center;"><img src="i_153.png" alt=""></img></div><br></br><h5 class="subtitle"><b>Таблица 11.10.</b> Поразрядные операции сдвига</h5><div style="text-align: center;"><img src="i_154.png" alt=""></img></div></div><h3 id="idm139732198000848">Другие операции
</h3><div style="text-align: justify" class="hsection3">   Вы уже встречались с операцией typeof, которая возвращает строку с именем типа данных. В табл. 11.11 приведены результаты, возвращаемые этой операцией.<br></br><h5 class="subtitle"><b>Таблица 11.11.</b> Результаты работы операции typeof</h5><div class="wrap_pict"><div style="text-align: center;"><img src="i_155.png" alt=""></img></div>   Кроме того, существуют операции, позволяющие обратиться к элементу какой-то структуры данных. При работе с элементами массива используется операция индексирования массива [], позволяющая обратиться к элементу массива:<br></br></div><br></br>   myArray[5]=56<br></br><br></br>   Для доступа к элементу объекта используется точка (.):<br></br><br></br>   ИмяОбъекта.имяСвойства<br></br></div></div><h2 id="idm139732198004688">11.4. Условия и циклы
</h2><div style="text-align: justify" class="hsection2"><div style="text-align: justify" class="section3">   Редко какая-либо программа или сценарий имеют линейный алгоритм. Обычно в ходе работы часто проверяются различные условия и в зависимости от результата принимаются какие-то решения. Для автоматизации работы в коде также используются циклы, которые позволяют намного снизить трудоемкость разработки.<br></br>
</div><h3 id="idm139732198005840">Условные операторы
</h3><div style="text-align: justify" class="hsection3">   В процессе создания сценариев обычно требуется изменить порядок выполнения кода. В этом разделе рассматриваются механизмы ветвления, позволяющие выбирать одно из альтернативных действий в зависимости от условия.<br></br><h5 class="subtitle">Оператор if</h5>   Оператор if управляет последовательностью выполнения команд. Синтаксис этого оператора:<br></br>   if (логическое выражение)<br></br>   {<br></br>   операторы<br></br>   }<br></br>   Сначала вычисляется логическое выражение, затем, если оно равно true, выполняются операторы, если же оно равно false, то операторы пропускаются и продолжается выполнение сценария.<br></br>   Рассмотрим пример. Допустим, функция f(x) определяется следующим образом:<br></br><div style="text-align: center;"><img src="i_156.png" alt=""></img></div>   Для нахождения значения этой функции на определенной точке можно воспользоваться кодом, приведенным в листинге 11.11.<br></br><h5 class="subtitle"><b>Листинг 11.11.</b> Пример работы оператора if</h5>   &lt;html&gt;<br></br>   &lt;head&gt;<br></br>   &lt;title&gt;Пример работы оператора if&lt;/title&gt;<br></br>   &lt;script&gt;<br></br>   var x, y;<br></br>   //Запрашиваем значение x<br></br>   x=prompt ("Введите значение x","0");<br></br>   //Преобразуем введенную строку в число<br></br>   x=+x;<br></br>   //Определяем значение функции<br></br>   if (x&lt;0){<br></br>   y=x+10;<br></br>   }<br></br>   if ((x&gt;=0)&amp;&amp;(x&lt;=5)){<br></br>   y=x*x+4;<br></br>   }<br></br>   if (x&gt;5){<br></br>   y=5/x;<br></br>   }<br></br>   alert("Функция f("+x+")="+y);<br></br>   &lt;/script&gt;<br></br>   &lt;/head&gt;<br></br>   &lt;body&gt;<br></br>   &lt;/body&gt;<br></br>   &lt;/html&gt;<br></br><br></br>   С помощью этого кода можно легко найти значение данной функции в любой точке (рис. 11.12).<br></br><div class="wrap_pict"><div style="text-align: center;"><img src="i_157.png" alt=""></img></div>   <b>Рис. 11.12.</b> Определение значения функции с помощью оператора if<br></br></div><br></br><h5 class="subtitle">Оператор if..else</h5>   Часто удобно использовать полную форму условного оператора if..else. С его помощью можно задать действия, которые необходимо выполнить, если логическое выражение равно false:<br></br><br></br>   if (логическое выражение)<br></br>   {<br></br>   операторы1<br></br>   }<br></br>   else<br></br>   {<br></br>   операторы2<br></br>   }<br></br><br></br>   Более того, можно совместить else с другим оператором if. В этом случае можно рассмотреть несколько альтернативных вариантов и выполнить соответствующие операторы:<br></br><br></br>   if (логическое выражение1)<br></br>   {<br></br>   операторы1<br></br>   }<br></br>   else if (логическое выражение2)<br></br>   {<br></br>   операторы2<br></br>   }<br></br>   else<br></br>   {<br></br>   операторы3<br></br>   }<br></br><br></br>   Теперь перепишем предыдущий сценарий для определения функции с помощью оператора if..else (листинг 11.12).<br></br><h5 class="subtitle"><b>Листинг 11.12.</b> Пример работы оператора if..else</h5>   &lt;html&gt;<br></br>   &lt;head&gt;<br></br>   &lt;title&gt;Пример работы оператора if..else&lt;/title&gt;<br></br>   &lt;script&gt;<br></br>   var x, y;<br></br>   //Запрашиваем значение x<br></br>   x=prompt ("Введите значение x","0");<br></br>   //Преобразуем введенную строку в число<br></br>   x=+x;<br></br>   //Определяем значение функции<br></br>   if (x&lt;0) y=x+10; //при x&lt;0<br></br>   else if (x&gt;5) y=5/x; //при x&gt;5<br></br>   else y=x*x+4; //при 0&lt;=x&lt;=5<br></br>   alert("Функция f("+x+")="+y);<br></br>   &lt;/script&gt;<br></br>   &lt;/head&gt;<br></br>   &lt;body&gt;<br></br>   &lt;/body&gt;<br></br>   &lt;/html&gt;<br></br><br></br>   Как видно из данного кода, фигурные скобки необязательны, если выполняется только один оператор. Однако рекомендуется всегда использовать их для облегчения чтения кода. Обратите внимание, что в целях оптимизации второй проверкой проверяется условие x&gt;5.<br></br><h5 class="subtitle">Оператор switch</h5>   Оператор switch позволяет сравнить значение с множеством других. Этого же эффекта можно достичь с помощью нескольких операторов if, но оператор switch позволяет создавать наглядный и краткий код. Этот оператор дает возможность предусмотреть операторы по умолчанию, которые выполняются, если не найдено ни одно соответствие:<br></br><br></br>   switch (выражение)<br></br>   {<br></br>   case значение1:<br></br>   операторы<br></br>   case значение2:<br></br>   операторы<br></br>   ..<br></br>   default:<br></br>   операторы<br></br>   }<br></br><br></br>   Допустим, необходимо, чтобы сценарий переводил названия животных с английского языка на русский (листинг 11.13).<br></br><h5 class="subtitle"><b>Листинг 11.13.</b> Пример работы оператора switch</h5>   &lt;html&gt;<br></br>   &lt;head&gt;<br></br>   &lt;title&gt;Пример работы оператора switch&lt;/title&gt;<br></br>   &lt;script&gt;<br></br>   var trans;<br></br>   //Запрашиваем название животного<br></br>   var beast=prompt ("Введите название животного","dog");<br></br>   //Находим соответствующее название на русском языке<br></br>   switch (beast)<br></br>   {<br></br>   case "dog":<br></br>   trans="собака";<br></br>   break;<br></br>   case "cat":<br></br>   trans="кошка";<br></br>   break;<br></br>   case "cow":<br></br>   trans="корова";<br></br>   break;<br></br>   default:<br></br>   trans="неизвестное животное"<br></br>   }<br></br>   alert(beast+" – "+trans);<br></br>   &lt;/script&gt;<br></br>   &lt;/head&gt;<br></br>   &lt;body&gt;<br></br>   &lt;/body&gt;<br></br>   &lt;/html&gt;<br></br><br></br>   Этот код позволяет получить перевод названия одного из трех животных (рис. 11.13).<br></br><div class="wrap_pict"><div style="text-align: center;"><img src="i_158.png" alt=""></img></div>   <b>Рис. 11.13.</b> Пример работы оператора switch<br></br></div><br></br>   Обратите внимание на оператор break, который позволяет закончить работу оператора switch, так как иначе будет выполняться оставшийся код в операторе switch.<br></br></div><h3 id="idm139732197960528">Операторы цикла
</h3><div style="text-align: justify" class="hsection3">   Для многократного выполнения кода используют операторы цикла. Кроме того, циклы предоставляют удобные средства для манипулирования массивами.<br></br><h5 class="subtitle">Цикл for</h5>   Оператор for служит для создания цикла. Он имеет следующий синтаксис:<br></br>   for (выражение инициализации; выражение условия; выражение цикла)<br></br>   {<br></br>   операторы<br></br>   }<br></br>   Выражение инициализации обычно служит для задания начального значения счетчика цикла. Выражение условия позволяет прекратить выполнять цикл, когда условие перестанет выполняться, то есть примет значение false. Выражение цикла обычно осуществляет инкремент или декремент счетчика цикла. Любое из этих выражений может быть пропущено, но соответствующая точка с запятой должна стоять.<br></br>   В листинге 11.14 представлен код, позволяющий найти факториал числа – n!=1*2*3*..*n.<br></br><h5 class="subtitle"><b>Листинг 11.14.</b> Факториал с помощью оператора for</h5>   &lt;html&gt;<br></br>   &lt;head&gt;<br></br>   &lt;title&gt;Факториал с помощью оператора for&lt;/title&gt;<br></br>   &lt;script&gt;<br></br>   var f=1;<br></br>   var x=prompt ("Введите число","5");<br></br>   x=+x;<br></br>   for(var i=1;i&lt;=x;i++)<br></br>   {<br></br>   f=f*i;<br></br>   }<br></br>   alert(f);<br></br>   &lt;/script&gt;<br></br>   &lt;/head&gt;<br></br>   &lt;body&gt;<br></br>   &lt;/body&gt;<br></br>   &lt;/html&gt;<br></br>   В этом коде организуется цикл от 1 до x, при этом для простоты введенное значение не проверяется на допустимость, поэтому можно, например, получить значение Infinity (бесконечность) при большом значении x.<br></br><h5 class="subtitle">Цикл while</h5>   Оператор while сходен с оператором for, но он не производит инициализацию и инкремент счетчика в своем объявлении. Синтаксис этого оператора следующий:<br></br>   while (выражение условия)<br></br>   {<br></br>   операторы<br></br>   }<br></br>   Если выражение условия в цикле while сразу ложно, то операторы не выполнятся ни разу.<br></br>   В листинге 11.15 представлен код, позволяющий найти факториал с помощью цикла while.<br></br><h5 class="subtitle"><b>Листинг 11.15.</b> Факториал с помощью оператора while</h5>   &lt;html&gt;<br></br>   &lt;head&gt;<br></br>   &lt;title&gt;Факториал с помощью оператора while&lt;/title&gt;<br></br>   &lt;script&gt;<br></br>   var f=1;<br></br>   var x=prompt ("Введите число","5");<br></br>   x=+x;<br></br>   var i=1;<br></br>   while(i&lt;=x)<br></br>   {<br></br>   f=f*i;<br></br>   i++;<br></br>   }<br></br>   alert(f);<br></br>   &lt;/script&gt;<br></br>   &lt;/head&gt;<br></br>   &lt;body&gt;<br></br>   &lt;/body&gt;<br></br>   &lt;/html&gt;<br></br><h5 class="subtitle">Цикл do..while</h5>   Оператор do..while практически идентичен оператору while, но, поскольку в нем проверка условия осуществляется в конце, он гарантирует выполнение операторов по крайней мере один раз:<br></br>   do<br></br>   {<br></br>   операторы<br></br>   } while (выражение условия)<br></br>   В листинге 11.16 представлен код, позволяющий найти факториал с помощью цикла do..while.<br></br><h5 class="subtitle"><b>Листинг 11.16.</b> Факториал с помощью оператора do..while</h5>   &lt;html&gt;<br></br>   &lt;head&gt;<br></br>   &lt;title&gt;Факториал с помощью оператора do..while&lt;/title&gt;<br></br>   &lt;script&gt;<br></br>   var f=1;<br></br>   var x=prompt ("Введите число","5");<br></br>   x=+x;<br></br>   var i=1;<br></br>   do<br></br>   {<br></br>   f=f*i;<br></br>   i++;<br></br>   } while(i&lt;=x)<br></br>   alert(f);<br></br>   &lt;/script&gt;<br></br>   &lt;/head&gt;<br></br>   &lt;body&gt;<br></br>   &lt;/body&gt;<br></br>   &lt;/html&gt;<br></br><h5 class="subtitle">Цикл for..in</h5>   С помощью конструкции for..in можно выполнить операторы почти для каждого свойства объекта. Синтаксис этого оператора:<br></br>   for (свойство in объект)<br></br>   {<br></br>   операторы<br></br>   }<br></br>   Например, с помощью данного оператора можно произвести инкремент всех элементов массива (листинг 11.17).<br></br><h5 class="subtitle"><b>Листинг 11.17.</b> Пример использования оператора for..in</h5>   &lt;html&gt;<br></br>   &lt;head&gt;<br></br>   &lt;title&gt;Пример использования оператора for..in &lt;/title&gt;<br></br>   &lt;script&gt;<br></br>   var a= new Array (5,76,43,12,77,-5, 0);<br></br>   for (var i in a)<br></br>   {<br></br>   a[i]++;<br></br>   }<br></br>   alert(a);<br></br>   &lt;/script&gt;<br></br>   &lt;/head&gt;<br></br>   &lt;body&gt;<br></br>   &lt;/body&gt;<br></br>   &lt;/html&gt;<br></br>   В ходе выполнения этого кода все элементы массива a увеличат свое значение на единицу (рис. 11.14).<br></br><div class="wrap_pict"><div style="text-align: center;"><img src="i_159.png" alt=""></img></div>   <b>Рис. 11.14.</b> Инкремент элементов массива<br></br></div><br></br>   Обратите внимание, что в цикле for..in не определяется свойство массива length.<br></br><h5 class="subtitle">Операторы break и continue</h5>   Иногда в ходе выполнения цикла возникает необходимость прервать весь цикл или одну его итерацию. Для этой цели служат операторы break и continue. Оператор break полностью прекращает выполнение цикла и передает управление операторам, следующим за циклом. Оператор continue прерывает текущее выполнение цикла и переходит к выполнению следующего шага цикла. Различие в работе этих операторов продемонстрировано в листинге 11.18.<br></br><h5 class="subtitle"><b>Листинг 11.18.</b> Пример использования операторов выхода из цикла</h5>   &lt;html&gt;<br></br>   &lt;head&gt;<br></br>   &lt;title&gt;Пример использования операторов выхода из цикла&lt;/title&gt;<br></br>   &lt;script&gt;<br></br>   var a= new Array (5,0,2,0-3,0);<br></br>   var b= new Array();<br></br>   //Создаем бесконечный цикл<br></br>   while(true)<br></br>   {<br></br>   var x=prompt ("Введите число","0");<br></br>   //Преобразуем введенную строку в число<br></br>   x=+x;<br></br>   //Если введен ноль, то цикл прерывается<br></br>   //Это единственный выход из бесконечного цикла<br></br>   if (x==0) {break}<br></br>   //Вложенный цикл, просматривающий все элементы массива<br></br>   for (var i=0;i&lt;a.length;i++)<br></br>   {<br></br>   //Проверяем значение элемента массива a<br></br>   if (a[i]==0)<br></br>   {<br></br>   b[i]="-";<br></br>   //Прерываем текущую итерацию цикла for, чтобы избежать<br></br>   //деления на ноль<br></br>   continue;<br></br>   }<br></br>   //Находим частное<br></br>   b[i]=x/a[i];<br></br>   }//Конец цикла for<br></br>   alert(a+"\n"x+"\n"+b);<br></br>   }//Конец цикла while<br></br>   &lt;/script&gt;<br></br>   &lt;/head&gt;<br></br>   &lt;body&gt;<br></br>   &lt;/body&gt;<br></br>   &lt;/html&gt;<br></br><br></br>   Данный код позволяет определить частное от введенного пользователем числа и элементов массива a. При этом в числе элементов этого массива могут быть нули, тогда необходимо в элемент массива с результатом b ввести прочерк (—) (рис. 11.15).<br></br><div class="wrap_pict"><div style="text-align: center;"><img src="i_160.png" alt=""></img></div>   <b>Рис. 11.15.</b> Пример использования операторов выхода из цикла<br></br></div><br></br>   В вышеприведенном коде также демонстрируется возможность вложения одного цикла в другой. Из цикла while возможен выход, только если ввести нуль (значение по умолчанию). Цикл for во время исполнения иногда прерывается, если элемент массива a равен нулю, чтобы избежать деления на ноль.<br></br></div></div><h2 id="idm139732185193808">11.5. Функции и события
</h2><div style="text-align: justify" class="hsection2"><div style="text-align: justify" class="section3">   До сих пор сценарии представляли собой простой код, сразу полностью выполняющийся. Однако часто требуется исполнение кода в какой-то момент или многократное исполнение одного и того же кода. В этом помогут функции и события.<br></br>
</div><h3 id="idm139732185194960">Функции
</h3><div style="text-align: justify" class="hsection3">   Функция – это набор команд, объединенных под общим именем для выполнения некоторой задачи. Синтаксис функции имеет следующий вид:<br></br>   function ИмяФункции([аргумент1][,..аргументN])<br></br>   {<br></br>   операторы<br></br>   }<br></br>   Ключевое слово function объявляет функцию с именем ИмяФункции. Функции могут передаваться (но могут и не передаваться) аргументы, которые перечисляются через запятую в скобках рядом с именем функции. В качестве аргументов могут выступать переменные, значения и выражения.<br></br><h5 class="subtitle">Использование функций</h5>   Функции можно объявлять в любом месте внутри элемента SCRIPT. Можно даже объявить функцию внутри другой функции, однако в этом случае она будет локальной, то есть будет действовать только внутри родительской функции. Тем не менее рекомендуется объявлять функцию в блоке HEAD до начала выполнения основного кода, иначе она может быть недоступной в момент вызова. В листинге 11.19 представлен пример работы с функциями.<br></br><h5 class="subtitle"><b>Листинг 11.19.</b> Пример использования функций</h5>   &lt;html&gt;<br></br>   &lt;head&gt;<br></br>   &lt;title&gt;Пример использования функций&lt;/title&gt;<br></br>   &lt;script&gt;<br></br>   //Глобальный массив<br></br>   var a= new Array (1,2,4,8);<br></br>   function sum()<br></br>   {<br></br>   var s=0; //локальная переменная для хранения суммы<br></br>   //Цикл по всем элементам массива a<br></br>   for (var i in a)<br></br>   {<br></br>   s=s+a[i];<br></br>   }<br></br>   alert("Сумма элементов массива="+s);<br></br>   }<br></br>   function product()<br></br>   {<br></br>   var p=1; //локальная переменная для хранения произведения<br></br>   for (var i in a)<br></br>   {<br></br>   p=p*a[i];<br></br>   }<br></br>   alert("Произведение элементов массива="+p);<br></br>   }<br></br>   &lt;/script&gt;<br></br>   &lt;/head&gt;<br></br>   &lt;body&gt;<br></br>   &lt;script&gt;<br></br>   var x=prompt("Найти сумму или произведение (0 или 1)?","0");<br></br>   if (x=="0")<br></br>   {<br></br>   sum();<br></br>   }<br></br>   if (x=="1")<br></br>   {<br></br>   product();<br></br>   }<br></br>   &lt;/script&gt;<br></br>   &lt;/body&gt;<br></br>   &lt;/html&gt;<br></br>   При запуске этого кода отображается запрос, на который необходимо ввести 0 или 1. В зависимости от ответа запускается одна из функций: sum() или product(), которые находят сумму или произведение элементов глобального массива a соответственно.<br></br>   Функции могут возвращать значение. Для этого необходимо использовать оператор возврата return. Вообще этот оператор может встречаться несколько раз в теле функции. Таким образом, функции можно использовать в выражениях (листинг 11.20).<br></br><h5 class="subtitle"><b>Листинг 11.20.</b> Использование значения функции</h5>   &lt;html&gt;<br></br>   &lt;head&gt;<br></br>   &lt;title&gt;Использование значения функции&lt;/title&gt;<br></br>   &lt;script&gt;<br></br>   function sum(a,b)<br></br>   {<br></br>   return (a+b);<br></br>   }<br></br>   &lt;/script&gt;<br></br>   &lt;/head&gt;<br></br>   &lt;body&gt;<br></br>   &lt;script&gt;<br></br>   var x1=5, x2=6, x3=3, x4=3;<br></br>   //Отображаем (x1+x2)*(x3+x4)<br></br>   alert (sum(x1,x2)*sum(x3,x4));<br></br>   &lt;/script&gt;<br></br>   &lt;/body&gt;<br></br>   &lt;/html&gt;<br></br>   Функция может объявляться в выражении. Обычно в этом случае функция присваивается переменной, которая затем может использоваться в выражении:<br></br>   var cube=function(x){return x*x*x}<br></br>   alert(cube(2)+cube(3));<br></br>   В данном случае объявляется переменная-функция, вычисляющая куб числа.<br></br><h5 class="subtitle">Переменное количество аргументов</h5>   Иногда в процессе создания функции неизвестно, сколько ей передадут аргументов. В этом случае необходимо воспользоваться объектом arguments. Все аргументы, переданные функции, сохраняются в этом объекте и могут быть извлечены. Например, для доступа к первому аргументу можно использовать следующий код:<br></br>   var arg1=arguments[0];<br></br>   Таким образом, аргументы индексируются, начиная с нуля. Для определения общего количества аргументов, переданных функции, можно использовать свойство length объекта arguments.<br></br>   Листинг 11.21 демонстрирует возможность обработки переменного количества аргументов.<br></br><h5 class="subtitle"><b>Листинг 11.21.</b> Пример переменного количества аргументов в функции</h5>   &lt;html&gt;<br></br>   &lt;head&gt;<br></br>   &lt;title&gt;Пример переменного количества аргументов в функции&lt;/title&gt;<br></br>   &lt;script&gt;<br></br>   function sum(x1,x2) //Функция содержит не меньше двух аргументов<br></br>   {<br></br>   var s=0; //Начальное значение суммы<br></br>   //Цикл по всем аргументам<br></br>   for (var i=0;i&lt;arguments.length;i++)<br></br>   {<br></br>   s+=arguments[i];<br></br>   }<br></br>   return (s);<br></br>   }<br></br>   &lt;/script&gt;<br></br>   &lt;/head&gt;<br></br>   &lt;body&gt;<br></br>   &lt;script&gt;<br></br>   //Вызываем функцию<br></br>   alert (sum(1,2,3,4));<br></br>   alert (sum(1,-3,40,2,5,7));<br></br>   &lt;/script&gt;<br></br>   &lt;/body&gt;<br></br>   &lt;/html&gt;<br></br><h5 class="subtitle">Дополнительная информация о функциях</h5>   Аргументами функции могут выступать не только данные простого типа, но и объекты. Однако при передаче функции строки, числа или логической величины в функции создается копия переданного значения и оригинал не изменяется, то есть что бы ни делали с аргументом внутри функции, после завершения функции эта переменная уничтожается, а оригинальная переменная остается прежней. Иначе происходит при передаче объекта. В этом случае копия объекта не создается, а передается ссылка на данный объект. Если бы происходило иначе, то терялось бы много времени и памяти на создание дубликатов. Представьте, сколько потребовалось бы времени на передачу массива из 10 000 элементов, когда фактически можно обойтись передачей одного значения – ссылки на этот массив. Однако программист должен помнить, что работает в функции с оригинальным объектом.<br></br>   Функции могут быть рекурсивными, то есть прямо или косвенно вызывать сами себя. Если в теле функции явно используется вызов этой же функции, то имеет место прямая рекурсия. Если же функция содержит обращение к другой функции, содержащей прямой или косвенный вызов первой функции, то данная функция является косвенно рекурсивной. Классический пример – функция для вычисления факториала неотрицательного целого числа (листинг 11.22).<br></br><h5 class="subtitle"><b>Листинг 11.22.</b> Пример рекурсивной функции</h5>   &lt;html&gt;<br></br>   &lt;head&gt;<br></br>   &lt;title&gt;Пример рекурсивной функции &lt;/title&gt;<br></br>   &lt;script&gt;<br></br>   function fact(n)<br></br>   {<br></br>   if (n&lt;0) return(null); //Проверка на отрицательные числа<br></br>   if (n==0) return (1); //Проверка на 0<br></br>   return (n*fact(–n));//Рекурсивный вызов<br></br>   }<br></br>   &lt;/script&gt;<br></br>   &lt;/head&gt;<br></br>   &lt;body&gt;<br></br>   &lt;script&gt;<br></br>   var x=prompt("Введите число","5");<br></br>   x=+x;<br></br>   //Вызываем функцию<br></br>   alert (x+"!="+fact(x));<br></br>   &lt;/script&gt;<br></br>   &lt;/body&gt;<br></br>   &lt;/html&gt;<br></br>   Для отрицательного числа факториала не существует. В этом случае возвращается null. Для нулевого значения функция возвращает 1, так как 0!=1. В противном случае вызывается та же функция с декрементом параметра и результат умножается на текущее значение параметра. Вызов функции прерывается при вызове fact (0) (рис. 11.16).<br></br><div style="text-align: center;"><img src="i_161.png" alt=""></img></div>   <b>Рис. 11.16.</b> Пример рекурсивной функции<br></br></div><h3 id="idm139732185134032">Знакомство с событиями
</h3><div style="text-align: justify" class="hsection3">   Очень часто язык JavaScript применяется для реагирования на события, которые могут быть вызваны пользователем или браузером. К событиям относятся открытие новой страницы, перемещение указателя мыши, щелчок кнопкой мыши и т. д. Каждое событие имеет соответствующий обработчик, который автоматически реагирует на возникшее событие.<br></br>   Так, событие onLoad происходит после загрузки какого-либо элемента, например веб-страницы. Использование обработчика этого события позволяет выполнять JavaScript-код сразу после полной загрузки документа.<br></br>   Одним из часто используемых событий является щелчок кнопкой мыши на объекте. При его возникновении обработчик события onClick объекта выполняет код JavaScript (листинг 11.23).<br></br><h5 class="subtitle"><b>Листинг 11.23.</b> Пример обработчиков событий</h5>   &lt;html&gt;<br></br>   &lt;head&gt;<br></br>   &lt;title&gt;Пример обработчиков событий&lt;/title&gt;<br></br>   &lt;script&gt;<br></br>   function mes()<br></br>   {<br></br>   alert ("Замечательная ссылка");<br></br>   }<br></br>   &lt;/script&gt;<br></br>   &lt;/head&gt;<br></br>   &lt;body&gt;<br></br>   &lt;h2&gt;Пример обработчиков событий&lt;/h2&gt;<br></br>   &lt;a href=http://www.myserver.ru/page1.html onClick="mes()"&gt;Ссылка 1&lt;/a&gt;<br></br>   &lt;br&gt;<br></br>   &lt;a href=http://www.myserver.ru/page2.html<br></br>   onClick="alert('Еще одна ссылка')"&gt;Ссылка 1<br></br>   &lt;/a&gt;<br></br>   &lt;/body&gt;<br></br>   &lt;/html&gt;<br></br>   Из данного кода видно, что обработчик события может быть вызовом функции. Однако может и непосредственно указываться JavaScript-код. В данном случае оба обработчика вызывают метод alert() (рис. 11.17).<br></br><div style="text-align: center;"><img src="i_162.png" alt=""></img></div>   <b>Рис. 11.17.</b> Пример обработчиков событий<br></br></div></div><h2 id="idm139732185112528">11.6. Встроенные объекты JavaScript
</h2><div style="text-align: justify" class="hsection2"><div style="text-align: justify" class="section3">   Объекты JavaScript объединяют в себе переменные, именуемые свойствами, и функции, управляющие этими свойствами, именуемые методами. Кроме того, они могут реагировать на события. Пользователь может создавать свои объекты, но JavaScript содержит ряд базовых объектов.<br></br>
   • Global – набор высокоуровневых свойств и методов, у которых нет родительского объекта.<br></br>
   • String – позволяет форматировать и изменять текстовые строки.<br></br>
   • Number – дает возможность обрабатывать числа.<br></br>
   • Boolean – позволяет создавать логические величины.<br></br>
   • Array – дает возможность создавать и управлять массивами.<br></br>
   • Function – позволяет создать функцию.<br></br>
   • Date – дает возможность работать с временем и датой.<br></br>
   • Math – предоставляет некоторые математические функции и константы.<br></br>
   • RegExp – позволяет выполнять функции регулярных выражений для заданных строк.<br></br>
   • Object – является прототипом для всех объектов.<br></br>
</div><h3 id="idm139732185117776">Объект Global
</h3><div style="text-align: justify" class="hsection3">   Этот объект содержит несколько методов и свойств, которые не принадлежат ни одному объекту (табл. 11.12 и 11.13). Для удобства их объединили в объект Global.<br></br><h5 class="subtitle"><b>Таблица 11.12.</b> Свойства объекта Global</h5><div style="text-align: center;"><img src="i_163.png" alt=""></img></div><br></br><h5 class="subtitle"><b>Таблица 11.13.</b> Методы объекта Global</h5><div class="wrap_pict"><div style="text-align: center;"><img src="i_164.png" alt=""></img></div>   Для доступа к методам и функциям этого объекта родительский объект не указывается:<br></br></div><br></br>   flag=isFinite(x/y)<br></br></div><h3 id="idm139732185072208">Объект String
</h3><div style="text-align: justify" class="hsection3">   Объект String предоставляет средства для форматирования и выделения части строк. Для этой цели он содержит обширный перечень методов (табл. 11.14 и 11.15).<br></br><h5 class="subtitle"><b>Таблица 11.14.</b> Свойства объекта String</h5><div style="text-align: center;"><img src="i_165.png" alt=""></img></div><br></br><h5 class="subtitle"><b>Таблица 11.15.</b> Методы объекта String</h5><div class="wrap_pict"><div style="text-align: center;"><img src="i_166.png" alt=""></img></div>   Рассмотрим использование методов объекта String:<br></br></div><br></br>   MyText="Я люблю HTML";<br></br>   MyText=MyText.substring(0,8)+"JavaScript";<br></br><br></br>   В результате строка MyText примет значение «Я люблю JavaScript».<br></br></div><h3 id="idm139732185076688">Объект Number
</h3><div style="text-align: justify" class="hsection3">   Объект Number обычно применяется для доступа к некоторым постоянным значениям, например к отрицательной бесконечности. Свойства и методы этого объекта указаны в табл. 11.16 и 11.17.<br></br><h5 class="subtitle"><b>Таблица 11.16.</b> Свойства объекта Number</h5><div style="text-align: center;"><img src="i_167.png" alt=""></img></div><br></br><h5 class="subtitle"><b>Таблица 11.17.</b> Методы объекта Number</h5><div style="text-align: center;"><img src="i_168.png" alt=""></img></div></div><h3 id="idm139732185079376">Объект Boolean
</h3><div style="text-align: justify" class="hsection3">   Объект Boolean обычно используется для преобразования объекта в логическое значение. Этот объект имеет ограниченное количество методов и свойств (табл. 11.18).<br></br><h5 class="subtitle"><b>Таблица 11.18.</b> Методы и свойства объекта Boolean</h5><div style="text-align: center;"><img src="i_169.png" alt=""></img></div></div><h3 id="idm139732185081296">Объект Array
</h3><div style="text-align: justify" class="hsection3">   С массивами вы уже познакомились в данной главе, однако массивы – это объекты, которые имеют свои свойства и методы, облегчающие работу программисту (табл. 11.19 и 11.20).<br></br><h5 class="subtitle"><b>Таблица 11.19.</b> Свойства объекта Array</h5><div style="text-align: center;"><img src="i_170.png" alt=""></img></div><br></br><h5 class="subtitle"><b>Таблица 11.20.</b> Методы объекта Array</h5><div style="text-align: center;"><img src="i_171.png" alt=""></img></div></div><h3 id="idm139732185083984">Объект Function
</h3><div style="text-align: justify" class="hsection3">   С помощью объекта Function можно манипулировать функцией как объектом. Этот объект содержит ряд специфичных методов и свойств (табл. 11.21 и 11.22).<br></br><h5 class="subtitle"><b>Таблица 11.21.</b> Свойства объекта Function</h5><div style="text-align: center;"><img src="i_172.png" alt=""></img></div><br></br><h5 class="subtitle"><b>Таблица 11.22.</b> Методы объекта Function</h5><div class="wrap_pict"><div style="text-align: center;"><img src="i_173.png" alt=""></img></div>   Синтаксис определения объекта Function выглядит следующим образом:<br></br></div><br></br>   ИмяОбъектаФункции = new Function ([аргумент1, аргумент2,.. аргументN],<br></br>   телоФункции);<br></br><br></br>   Например,<br></br><br></br>   sumFunc = new Function ("a","b","return(a+b)");<br></br>   alert(sumFunc(5,4));<br></br></div><h3 id="idm139732185056720">Объект Date
</h3><div style="text-align: justify" class="hsection3">   Объект Date предоставляет значительное количество свойств и методов, связанных с датами и временем (табл. 11.23 и 11.24). В качестве базовой даты в JavaScript принято 1 января 1970 года. Язык JavaScript имеет доступ только к времени и дате на клиентской машине.<br></br><h5 class="subtitle"><b>Таблица 11.23.</b> Свойства объекта Date</h5><div style="text-align: center;"><img src="i_174.png" alt=""></img></div><br></br><h5 class="subtitle"><b>Таблица 11.24.</b> Методы объекта Date</h5><div style="text-align: center;"><img src="i_175.png" alt=""></img></div><br></br><div class="wrap_pict"><div style="text-align: center;"><img src="i_176.png" alt=""></img></div>   Конструктор этого объекта принимает значение даты в числовом или строковом формате:<br></br></div><br></br>   ИмяОбъектаДаты = new Date();<br></br>   ИмяОбъектаДаты = new Date(миллисекунды);<br></br>   ИмяОбъектаДаты = new Date("месяц дд, гггг чч:мм:сс");<br></br>   ИмяОбъектаДаты = new Date(год, месяц, день [, час, минуты, секунды, миллисекунды]);<br></br><br></br>   где значение определяется следующим образом:<br></br>   • миллисекунды – целое число, определяющее количество миллисекунд, прошедших с 0 часов 0 минут 0 секунд 1 января 1970 года по Гринвичу;<br></br>   • месяц, дд, гггг, чч, мм, сс – месяц, день, год, час, минуты и секунды соответственно;<br></br>   • год, месяц, день, час, минуты, секунды, миллисекунды – целые числа, определяющие соответствующие величины.<br></br>   Если параметры не указаны, то объект инициализируется текущей датой и временем.<br></br>   Например, чтобы узнать текущий день недели, можно воспользоваться следующим кодом:<br></br><br></br>   MyDate=new Date();<br></br>   alert(MyDate.getDay());<br></br><br></br>   Этот код отобразит число от 0 до 6, соответствующее дню недели. Например, 0 соответствует воскресенью.<br></br><br></br></div><h3 id="idm139732185065808">Объект Math
</h3><div style="text-align: justify" class="hsection3">   Для математических вычислений JavaScript поддерживает объект Math, который содержит ряд математических констант и функций (табл. 11.25 и 11.26).<br></br><h5 class="subtitle"><b>Таблица 11.25.</b> Свойства объекта Math</h5><div style="text-align: center;"><img src="i_177.png" alt=""></img></div><br></br><h5 class="subtitle"><b>Таблица 11.26.</b> Методы объекта Math</h5><div style="text-align: center;"><img src="i_178.png" alt=""></img></div><br></br><div style="text-align: center;"><img src="i_179.png" alt=""></img></div></div><h3 id="idm139732185068880">Объект RegExp
</h3><div style="text-align: justify" class="hsection3">   Регулярные выражения – это шаблоны для поиска определенных комбинаций символов в строках. В данной книге мы не будем рассматривать регулярные выражения, но список методов и свойств объекта RegExp, позволяющего создавать регулярные выражения, можно найти в табл. 11.27 и 11.28.<br></br><h5 class="subtitle"><b>Таблица 11.27.</b> Свойства объекта RegExp</h5><div style="text-align: center;"><img src="i_180.png" alt=""></img></div><br></br><h5 class="subtitle"><b>Таблица 11.28.</b> Методы объекта RegExp</h5><div style="text-align: center;"><img src="i_181.png" alt=""></img></div></div><h3 id="idm139732201979856">Объект Object
</h3><div style="text-align: justify" class="hsection3">   Все объекты в JavaScript – и встроенные, и пользовательские – наследуются от объекта Object, то есть его методы и свойства (табл. 11.29 и 11.30) присутствуют в каждом объекте, но, как правило, их переопределяют.<br></br><h5 class="subtitle"><b>Таблица 11.29.</b> Свойства объекта Object</h5><div style="text-align: center;"><img src="i_182.png" alt=""></img></div><br></br><h5 class="subtitle"><b>Таблица 11.30.</b> Методы объекта Object</h5><div style="text-align: center;"><img src="i_183.png" alt=""></img></div></div></div><h2 id="idm139732201982544">Резюме
</h2><div style="text-align: justify" class="hsection2">   В этой главе дано общее описание фундаментальных составляющих языка JavaScript: переменных, выражений, операций, объектов, функций и событий. Именно эти знания являются основополагающими, без них невозможно владение языком сценариев. Кроме того, в настоящей главе приведены данные о свойствах и методах всех встроенных объектов JavaScript. Эту информацию необязательно запоминать, но можно использовать как справочную, так как начинающему программисту она нужна в ограниченном объеме. Данная глава охватывает, возможно, слишком много понятий и может показаться вам сложной. Можете вернуться к ней позднее, чтобы закрепить новые знания.<br></br></div></div><h1 xmlns="http://www.w3.org/1999/xhtml" id="idm139732201983568" class="master">Глава 12<br></br>
Первый сценарий на JavaScript
</h1><div xmlns="http://www.w3.org/1999/xhtml" style="text-align: justify" class="hsection1"><div style="text-align: justify" class="section2">   12.1. Организация рабочего окружения<br></br>
   12.2. Внедрение сценариев в HTML-документ<br></br>
   12.3. Вводим первый сценарий<br></br>
   12.4. Разбор нашего сценария в среде FrontPage<br></br>
   12.5. Отладка сценария в Microsoft Script Editor<br></br>
   Вы познакомились с синтаксическими конструкциями и операторами языкаJavaScript, теперь перейдем непосредственно к созданию сценариев. В данной главе вы узнаете, что вам понадобится для создания сценариев. Кроме того, будут рассмотрены способы внедрения сценариев в HTML-документы. Потом для примера вы создадите простой сценарий, на котором и рассмотрите процесс создания сценариев JavaScript.<br></br>
</div><h2 id="idm139732201987152">12.1. Организация рабочего окружения
</h2><div style="text-align: justify" class="hsection2"><div style="text-align: justify" class="section3">   Для успешной работы в какой-либо области важно иметь под рукой необходимые инструменты, и будет лучше, если они будут удобными. В работе по созданию сценариев также необходимо хоть немного, но организовать свое рабочее место. В этом разделе мы как раз и займемся кратким освещением вопросов, связанных с организацией рабочего окружения.<br></br>
</div><h3 id="idm139732201988304">Текстовые редакторы
</h3><div style="text-align: justify" class="hsection3">   Для работы над сценариями подойдет практически любой текстовый редактор, позволяющий создавать обычные текстовые файлы и сохранять их в формате HTM или HTML. Например, в операционной системе Windows в числе стандартных есть два подходящих текстовых редактора – это Блокнот и WordPad. Отдельно стоит отметить редактор Microsoft Word из пакета Microsoft Office – он никак не подойдет для создания сценариев. По умолчанию данный редактор сохраняет свои файлы в двоичном виде, которые ничего общего с веб-страницами не имеют. Хотя можно сохранять его файлы и как веб-страницы, он не позволяет напрямую работать с кодом страниц, а значит, вы не сможете создавать в нем сценарии.<br></br>   Существуют редакторы, специально разработанные для создания веб-страниц, например Microsoft FrontPage или Adobe Dreamweaver (ранее известный как Macromedia Dreamweaver). Такие редакторы позволяют создавать веб-страницы с помощью визуальных инструментов, а затем уже переключаться в режим отображения кода и вносить какие-либо нестандартные изменения, например добавлять сценарии. Если же создавать с их помощью обычные веб-страницы сможет даже пользователь, не владеющий языком разметки HTML, то вносить изменения в режиме работы с кодом сможет только человек, хотя бы немного знакомый с этим языком. По этой причине пользователям, еще только начинающим разбираться с HTML, следует применять данные редакторы лишь в режиме работы с кодом, чтобы полностью контролировать ход создания веб-страниц. По сравнению с обычными текстовыми редакторами в Microsoft FrontPage или Adobe Dreamweaver синтаксис языков HTML и JavaScript подсвечивается. Таким образом, в них будет удобно работать над сценариями.<br></br>   Кроме того, в Интернете можно найти большое количество других текстовых редакторов, которые позволяют создавать веб-страницы и при этом могут подсвечивать синтаксис языков HTML и JavaScript, а также имеют много иных полезных возможностей, которые существенно упрощают процесс создания веб-страниц и разработки сценариев. Многие такие редакторы распространяются бесплатно или условно бесплатно, и, возможно, какой-нибудь из них придется вам по душе.<br></br></div><h3 id="idm139732201990096">Браузеры
</h3><div style="text-align: justify" class="hsection3">   Вы собираетесь создавать сценарии, управляющие веб-страницами, поэтому для проверки работоспособности этих документов вам понадобится какой-либо браузер. Как известно, полной совместимости среди браузеров нет, а значит, проверив работоспособность своего творения в одном браузере, нельзя быть уверенным в работоспособности в других. Следовательно, лучше использовать как можно большее количество различных браузеров для проверки своих веб-страниц.<br></br>   В основном веб-разработчикам приходится считаться с особенностями браузера Internet Explorer, который не слишком стремится к стандартам. Поэтому обязательно тестируйте свои веб-страницы на данном браузере, присутствующем в каждой версии операционной системы Windows. Большой популярностью также пользуются браузеры Mozilla Firefox и Opera, которые стремятся максимально соответствовать стандартам. Вообще можно встретить и другие браузеры, например Konqueror у пользователей операционной системы Linux или Safari у пользователей операционной системы Mac OS. Что касается браузеров от независимых производителей, то они стараются строго соответствовать стандартам, избегая фирменных возможностей браузеров компаний Microsoft и Netscape. Можно прийти к выводу, что для проверки работоспособности своих сценариев будет вполне достаточно трех браузеров: Internet Explorer, Mozilla Firefox и Opera. Причем первый из перечисленных браузеров есть у всех пользователей операционной системы Windows, а следующие два можно без проблем загрузить из Интернета. Браузер Mozilla Firefox можно загрузить с сайта <a href="http://www.mozilla.ru/">http://www.mozilla.ru/</a>, а Opera – с сайта <a href="http://www.opera.com/">http://www.opera.com/</a>. Кроме того, не все пользователи работают с последними версиями браузеров, поэтому для максимального охвата интернет-аудитории может потребоваться тестирование документов на младших версиях указанных браузеров.<br></br></div><h3 id="idm139732201992528">Отладчики сценариев JavaScript
</h3><div style="text-align: justify" class="hsection3">   Отладка представляет собой поиск и устранение ошибок. Часто процесс отладки может занимать большую часть времени разработки всей программы (или сценария). Ведь надежность и безошибочная работа программы зачастую даже важнее ее функциональности. Поэтому для облегчения и ускорения отладки созданы специальные программы, которые называются <i>отладчиками.</i> Типичный отладчик имеет такие возможности, как пошаговое выполнение программы с остановкой в каждой строке кода или в заранее отмеченных для этого точках остановки, а также возможность отслеживания и изменения значений каждой переменной прямо во время выполнения программы.<br></br>   Стоит отметить, что для программистов на таких языках, как, например, C++ или Java, отладчики стали таким же обычным и привычным инструментом, как, например, текстовый редактор. А вот для разработки сценариев на JavaScript отладчики применялись не всегда ввиду того, что сценарии, как правило, имели небольшой размер и малую сложность и поэтому могли быть проверены и вручную. Однако в настоящее время сценарии на JavaScript, особенно с использованием технологии AJAX, уже не уступают по объему кода и сложности программам, написанным на таких языках, как C++ или Java. Поэтому все чаще и чаще при разработке сценариев на JavaScript применяют отладчики. Кроме того, если вы в дальнейшем при разработке своих сценариев на JavaScript столкнетесь с какой-либо ошибкой или неправильной работой сценария, умение пользоваться отладчиком сэкономит вам немало времени и труда.<br></br>   Существует немало отладчиков для сценариев на JavaScript. Например, Microsoft Script Debugger, бесплатно распространяющийся отладчик от компании Microsoft, который можно загрузить по адресу <a href="http://msdn.microsoft.com/scripting/">http://msdn.microsoft.com/scripting/</a>, имеет все необходимое для успешной отладки сценариев на JavaScript. При отладке сценариев Microsoft Script Debugger применяется совместно с браузером Internet Explorer. Кроме того, данный отладчик распространяется вместе с редактором Microsoft FrontPage в рамках программы Microsoft Script Editor, которая практически не отличается от Microsoft Script Debugger.<br></br>   Существуют и другие отладчики (например, для браузера Mozilla Firefox), созданные в виде расширений. В частности, отладчик Firebug можно загрузить с сайта <a href="https://addons.mozilla.org/firefox/1843/">https://addons.mozilla.org/firefox/1843/</a>. Причем если перейти на данную страницу в браузере Mozilla Firefox, то отладчик сразу же будет установлен.<br></br></div></div><h2 id="idm139732201930576">12.2. Внедрение сценариев в HTML-документ
</h2><div style="text-align: justify" class="hsection2"><div style="text-align: justify" class="section3">   В данном разделе будут рассмотрены вопросы, касающиеся встраивания сценариев в веб-страницы, поэтому предполагается, что вы хотя бы немного знакомы с языком разметки HTML. Обычно сценарии внедряются в HTML-документ тремя стандартными способами:<br></br>
   • в виде гиперссылки;<br></br>
   • в виде обработчика события;<br></br>
   • в рамках элемента SCRIPT.<br></br>
   Разберем способы встраивания сценариев в веб-страницы по порядку. Начнем с разбора метода встраивания сценария под видом гиперссылки.<br></br>
</div><h3 id="idm139732201933264">Встраивание сценариев в гиперссылку
</h3><div style="text-align: justify" class="hsection3">   Как известно, для создания на веб-страницах гиперссылок применяется элемент A, у которого есть атрибут href для указания адреса страницы или файла, куда приведет гиперссылка. Однако вместо адреса данный атрибут может содержать и JavaScript-сценарий, если перед сценарием поставить слово javascript: (со знаком:). Рассмотрим пример такой гиперссылки:<br></br>   &lt;a href="javascript:alert('Привет, мир!');"&gt;Нажмите сюда&lt;/a&gt;<br></br>   Когда пользователь щелкает кнопкой мыши на гиперссылке, интерпретатор сценариев JavaScript получает следующий код:<br></br>   alert('Привет, мир!');<br></br>   Интерпретатор исполняет этот код, в результате чего на экране появляется окно (рис. 12.1).<br></br><div class="wrap_pict"><div style="text-align: center;"><img src="i_184.png" alt=""></img></div>   <b>Рис. 12.1.</b> После перехода по гиперссылке появляется окно<br></br></div><br></br>   Здесь сценарий состоит из вызова всего одной функции alert(), которая выводит на экран окно с текстом, полученным в качестве параметра. В принципе, объем кода может быть любой. Следует помнить, что, если браузер не поддерживает JavaScript или поддержка этого языка отключена, гиперссылка будет отображена, но работать не будет, что может вызвать недоумение у пользователей. Поэтому во избежание проблем это следует учесть.<br></br></div><h3 id="idm139732201937744">Встраивание сценариев для обработки событий
</h3><div style="text-align: justify" class="hsection3">   При работе с такой графической операционной системой, как Windows, вы могли заметить, что она всегда готова отреагировать на ваши действия: щелкнули кнопкой мыши на значке программы – программа запустилась, нажали клавишу в текстовом редакторе – появился соответствующий символ и т. д. Все это некие события, которые приходят от мыши, клавиатуры, таймера и многих других устройств. Аналогично и браузер может реагировать на различные события.<br></br>   Поведение каждого элемента зависит от событий, которые постоянно возникают в браузере. Например, пользователь щелкнул кнопкой мыши на тексте, переместил указатель мыши, загрузил HTML-документ. Браузер сам решает, как реагировать на каждое событие. Однако вы можете перехватывать отдельные события и задавать новое поведение при их наступлении. В языке HTML у многих элементов есть атрибуты, соответствующие различным событиям. Эти атрибуты могут содержать код языка JavaScript, выполняемый в ответ на событие. Например:<br></br>   &lt;p onclick="alert('Не нажимать!');"&gt;Это простой текст&lt;/p&gt;<br></br>   Элемент P просто объединяет текст в параграфы, однако мы возложили на него еще одну функцию. Определив атрибут onclick, наш текст будет реагировать на щелчок кнопкой мыши (рис. 12.2).<br></br><div class="wrap_pict"><div style="text-align: center;"><img src="i_185.png" alt=""></img></div>   <b>Рис. 12.2.</b> После щелчка кнопкой мыши на тексте появляется сообщение<br></br></div><br></br>   В языке HTML (начиная с версии 4.0) практически каждый элемент имеет атрибуты для обработки каких-либо событий. Для обработки событий данным атрибутам назначается код на языке JavaScript, который выполняется, когда произойдет событие. Благодаря возможности обработки событий вы можете создавать интерактивные страницы, отвечающие на действия пользователей.<br></br></div><h3 id="idm139732201941584">Встраивание сценариев в рамках элемента SCRIPT
</h3><div style="text-align: justify" class="hsection3">   Кроме возможности обработки событий, для внедрения сценариев в веб-страницы в языке разметки HTML есть специальный элемент SCRIPT. Браузер, встретив тег &lt;script&gt; в процессе разбора кода, интерпретирует текст, последующий до закрывающего тега &lt;/script&gt;, как сценарий на каком-либо языке. Для указания языка сценария используется атрибут type.<br></br>   Например, для указания языка JavaScript:<br></br>   &lt;script type="text/javascript"&gt;<br></br>   Здесь располагается код сценария<br></br>   &lt;/script&gt;<br></br>   При использовании сценариев JavaScript можно этот атрибут не указывать, так как значение «text/javascript» является значением по умолчанию.<br></br>   Кроме того, иногда для указания типа языка используют атрибут language. Так, для указания языка JavaScript 1.0 значение атрибута language должно быть «JavaScript», для JavaScript 1.1 – "JavaScript1. 1", для JavaScript 1.2 – "JavaScript1.2" и т. д. Однако данный атрибут не входит в стандарт, определяющий язык HTML, хотя и распознается большинством браузеров. По этой причине его не рекомендуется употреблять. Стоит заметить, что если значение атрибута language незнакомо браузеру, то содержимое элемента SCRIPT игнорируется.<br></br>   Если пользователь работает в старой версии браузера, которая не поддерживает JavaScript, то элемент SCRIPT может оказаться неизвестным программе и код сценария будет выведен на экран как обычный текст. Таким образом, необходимо обеспечить маскировку кода сценариев от старых браузеров. Для этого код сценария внутри элемента SCRIPT окружают комментариями языка HTML (&lt;!– и –&gt;):<br></br>   &lt;script type="text/javascript"&gt;<br></br>   &lt;!– Маскируем код<br></br>   Здесь располагается код сценария<br></br>   // Снимаем маскировку –&gt;<br></br>   &lt;/script&gt;<br></br>   Таким образом, браузер ранней версии, встретив элемент SCRIPT, проигнорирует его, а содержащийся внутри этого элемента код пропустит, посчитав комментарием.<br></br>   Здесь стоит обратить внимание, что перед закрывающим комментарием языка HTML (-&gt;) стоит еще и комментарий языка JavaScript (//), поскольку иначе при выполнении JavaScript-кода некоторые браузеры могут попытаться выполнить обработку этой строки, а набор символов – &gt; в JavaScript имеет совсем другое значение. Вообще, язык JavaScript богат на различные комбинации символов, обозначающие комментарии. Комментарии игнорируются интерпретатором JavaScript.<br></br>   Комментарии // и &lt;!– позволяют скрыть строку в коде сценария:<br></br>   &lt;script&gt;<br></br>   // Это первый комментарий<br></br>   // Второй комментарий, далее идет код<br></br>   Код сценария<br></br>   &lt;!– Еще один комментарий<br></br>   Продолжение кода<br></br>   // Комментарий<br></br>   &lt;/script&gt;<br></br>   Комментарии могут быть и многостроковыми, что облегчает отладку сценария и позволяет закомментировать проблемный участок кода. Для этой цели используются наборы символов /* и */.<br></br>   &lt;script&gt;<br></br>   /* Это<br></br>   тоже<br></br>   комментарий */<br></br>   Код сценария<br></br>   &lt;/script&gt;<br></br>   Что же делать с браузерами, которые не поддерживают сценарии или такая возможность в них просто отключена? В таких случаях необходимо либо предупредить пользователя, что для просмотра требуется поддержка сценариев, либо заменить код каким-либо вариантом без сценариев. Для этого в языке HTML есть элемент NOSCRIPT, чье содержимое будет использовано при отсутствии поддержки сценариев. Например:<br></br>   &lt;noscript&gt;<br></br>   &lt;p&gt;Ваш браузер не поддерживает сценариев JavaScript или их поддержка отключена&lt;/p&gt;<br></br>   &lt;/noscript&gt;<br></br>   Таким образом, можно, например, предупредить пользователя о том, что для просмотра страницы ему необходим браузер с поддержкой JavaScript. Или же можно предоставить пользователю ссылку на версию сайта, адаптированную для старых версий браузеров.<br></br>   Сценарии могут содержаться в самой веб-странице, как описано выше, а также в отдельном файле. Элемент SCRIPT имеет атрибут src, который должен иметь значение адреса файла со сценарием. Обычно файлы со сценариями JavaScript имеют расширения JS, например файл lib1.js. Таким образом, чтобы подключить к HTML-документу файл lib1.js, необходимо добавить в него следующую строку:<br></br>   &lt;script type="text/javascript" src="lib1.js"&gt;&lt;/src&gt;<br></br>   Использование отдельных файлов под код сценариев позволит вам создавать, например, собственные библиотеки функций и объектов, при необходимости просто подключив к веб-странице файл библиотеки, не создавая каждую функцию заново. Расположение часто используемых функций в одном файле упростит и отладку, и дальнейшее совершенствование сценариев.<br></br>   Стоит отметить, что обычно объявления всех глобальных переменных, функций, внешних файлов со сценариями помещают внутри элемента HEAD, то есть в заголовке страниц. Дело в том, что прежде чем использовать какие-либо переменные, функции или объекты, их необходимо объявить. Поскольку содержимое элемента HEAD читается первым, вы можете определять в нем то, на что будете ссылаться позже.<br></br>   Таким образом, код веб-страницы со сценариями может выглядеть примерно так, как в листинге 12.1. В нем показаны фрагменты кода веб-страницы, касающиеся встраивания сценариев в HTML-документ.<br></br><h5 class="subtitle"><b>Листинг 12.1.</b> Пример веб-страницы со сценариями</h5>   &lt;html&gt;<br></br>   &lt;head&gt;<br></br>   &lt;title&gt;Страница со сценариями&lt;/title&gt;<br></br>   &lt;!– Подключаем внешние файлы со сценариями –&gt;<br></br>   &lt;script type="text/javascript" src="lib1.js"&gt;&lt;/src&gt;<br></br>   &lt;!– Глобальные переменные, функции и объекты –&gt;<br></br>   &lt;script type="text/javascript"&gt;<br></br>   &lt;!– Маскировка сценария<br></br>   ... // Код на JavaScript<br></br>   // Конец маскировки сценария –&gt;<br></br>   &lt;/script&gt;<br></br>   &lt;/head&gt;<br></br>   &lt;body&gt;<br></br>   &lt;noscript&gt;<br></br>   &lt;p&gt;Ваш браузер не поддерживает сценарии или их поддержка отключена&lt;/p&gt;<br></br>   &lt;/noscript&gt;<br></br>   ... &lt;!– Элементы страницы –&gt;<br></br>   &lt;script type="text/javascript&gt;<br></br>   &lt;!–<br></br>   ... // Тоже код на веб-странице<br></br>   //–&gt;<br></br>   &lt;/script&gt;<br></br>   ... &lt;!– Элементы страницы –&gt;<br></br>   &lt;p onclick="..."&gt;Элемент страницы, события которого обрабатываются&lt;/p&gt;<br></br>   ... &lt;!– Элементы страницы –&gt;<br></br>   &lt;/body&gt;<br></br>   &lt;/html&gt;<br></br>   Таким образом, в HTML-документы внедряется код сценариев на JavaScript. Как видите, все довольно просто. Чтобы убедиться в этом, попробуйте создать свой первый сценарий.<br></br></div></div><h2 id="idm139732201889104">12.3. Вводим первый сценарий
</h2><div style="text-align: justify" class="hsection2">   Классическим примером в начале изучения любого языка программирования является программа, выводящая сообщение Привет, мир!!!. Вот и мы создадим на JavaScript сценарий, который будет выводить такое сообщение. Чтобы проиллюстрировать возможности отладчика Microsoft Script Debugger, немного усложним пример и выведем не одно сообщение Привет, мир!!! а несколько. Кроме того, в процессе разбора сценария вы увидите, что очень просто изменить количество сообщений, выводимых в документе. Для примера работы в отладчике вмешаемся в ход выполнения сценария, изменив значение переменной-счетчика.<br></br>   Теперь пора перейти к практике и создать, наконец, первый сценарий. Прежде стоит повторить, что язык JavaScript чувствителен к регистру символов. Это означает, что вам следует внимательно следить за тем, какими буквами вы набираете код сценария. Ведь, например, слова if и If в языке JavaScript – это абсолютно разные слова. Более подробно об этом вы узнаете в следующих главах, а пока достаточно правильно переписать сценарий из листинга 12.2.<br></br>   1. Запустите текстовый редактор, в котором вы собираетесь создавать свои вебстраницы.<br></br>   2. Создайте новый текстовый файл.<br></br>   3. Введите текст вашего первого сценария из листинга 12.2.<br></br><h5 class="subtitle"><b>Листинг 12.2.</b> Первый сценарий</h5>   &lt;html&gt;<br></br>   &lt;head&gt;<br></br>   &lt;meta http-equiv="Content-Type" content="text/html; charset=windows-1251"&gt;<br></br>   &lt;title&gt;Наш первый сценарий&lt;/title&gt;<br></br>   &lt;/head&gt;<br></br>   &lt;body&gt;<br></br>   &lt;script type="text/javascript"&gt;<br></br>   &lt;!–<br></br>   for (var i = 0; i &lt; 10; i++)<br></br>   {<br></br>   document.write("Привет, мир!!!");<br></br>   }<br></br>   //–&gt;<br></br>   &lt;/script&gt;<br></br>   &lt;/body&gt;<br></br>   &lt;/html&gt;<br></br>   4. Сохраните файл, например, с именем script1.html.<br></br>   Создав веб-страницу со сценарием, можно посмотреть, как она будет выглядеть в браузере. Чтобы убедиться, что сценарий работает как следует, проверьте его во всех установленных на вашем компьютере браузерах.<br></br>   Итак, если вы ввели все строки без ошибок, как в листинге 12.2, то на экране вашего браузера появится десять сообщений Привет, мир!!! (рис. 12.3).<br></br><div class="wrap_pict"><div style="text-align: center;"><img src="i_186.png" alt=""></img></div>   <b>Рис. 12.3.</b> Первый сценарий, открытый в браузере<br></br></div><br></br>   При разработке сценариев обычно одновременно открыт и текстовый редактор, в котором создается веб-страница, и несколько браузеров, в которых проверяется работоспособность создаваемой веб-страницы. Таким образом, после внесения и сохранения каких-либо изменений в сценарий достаточно перейти в окно браузера и нажать кнопку Обновить.<br></br>   Однако удобнее разрабатывать веб-страницы и сценарии в специально созданных для этого редакторах. Поэтому в качестве примера разберем работу первого сценария в среде редактора Microsoft FrontPage.<br></br></div><h2 id="idm139732201868752">12.4. Разбор нашего сценария в среде FrontPage
</h2><div style="text-align: justify" class="hsection2">   Созданный сценарий состоит всего из четырех строк кода, которые выводят в окне браузера десять сообщений Привет, мир!!!. Все остальное – это код страницы на языке HTML. Далее мы немного поэкспериментируем со сценарием.<br></br>   Для разработки сценариев в редакторе FrontPage необходимо переключиться в режим Код (рис. 12.4), который позволит не использовать визуальные инструменты, а работать с кодом страницы напрямую.<br></br><div class="wrap_pict"><div style="text-align: center;"><img src="i_187.png" alt=""></img></div>   <b>Рис. 12.4.</b> Разработка сценариев в среде FrontPage<br></br></div><br></br>   В редакторе FrontPage подсвечивается синтаксис языка, что отчетливо выделяет переменные, цифры и строки, ключевые слова языка. В общем, работать в специализированном редакторе гораздо удобнее, а вероятность сделать опечатку меньше. Кроме того, работая в редакторе FrontPage, нет необходимости постоянно держать запущенными браузеры. Ведь чтобы просмотреть, что получилось, достаточно из режима Код перейти в режим Просмотр.<br></br>   Возможно, вы уже догадались, что сообщение Привет, мир!!! выводит следующая строка:<br></br><br></br>   document.write(«Привет, мир!!!»);<br></br><br></br>   Как говорилось ранее, язык JavaScript является объектно-ориентированным, а значит, предполагается работа с объектами, в которых и реализованы почти все возможности языка. Поскольку нам необходимо вывести в документе приветствие, мы обратились к объекту document, в котором есть функция write() для вывода строк.<br></br>   Чтобы приветствие выводилось несколько раз, используется оператор цикла for языка JavaScript, который вызывает функцию write() объекта document до тех пор, пока значение переменной i меньше десяти. Причем с каждым новым повтором значение переменной i увеличивается на единицу.<br></br>   Таким образом, чтобы вывести, например, приветствие 20 раз, достаточно изменить всего одну цифру в следующей строке:<br></br><br></br>   for (var i = 0; i &lt; 10; i++)<br></br><br></br>   В итоге получится строка:<br></br><br></br>   for (var i = 0; i &lt; 20; i++)<br></br><br></br>   Теперь посмотрим, что получилось, просто перейдя в редакторе FrontPage в режим Просмотр (рис. 12.5).<br></br><div style="text-align: center;"><img src="i_188.png" alt=""></img></div>   <b>Рис. 12.5.</b> Просмотр работы сценария в среде FrontPage<br></br></div><h2 id="idm139732201876688">12.5. Отладка сценария в Microsoft Script Editor
</h2><div style="text-align: justify" class="hsection2">   Отладчик Microsoft Script Editor распространяется с редактором Microsoft FrontPage, хотя может быть свободно загружен из Интернета. Данный отладчик применяется совместно с браузером Internet Explorer, а значит в браузере необходимо разрешить отладку.<br></br>   1. Выберите команду меню Сервис &#8594; Свойства обозревателя. Появится окно Свойства обозревателя.<br></br>   2. Выберите вкладку Дополнительно. Вы увидите список Параметры.<br></br>   3. В этом списке снимите, если установлены, флажки Отключить отладку сценариев (Internet Explorer) и Отключить отладку сценариев (Другие).<br></br>   4. Нажмите кнопку OK, чтобы сохранить изменения.<br></br>   5. Перезапустите браузер.<br></br>   Таким образом, в меню Вид должно появиться подменю Отладчик сценариев с двумя командами: Открыть и Прервать на следующей инструкции. Теперь приступим к отладке сценария.<br></br>   1. Откройте в браузере страницу с первым сценарием (см. листинг 12.2).<br></br>   2. Выберите команду меню Вид &#8594; Отладчик сценариев &#8594; Прервать на следующей инструкции.<br></br>   3. Нажмите кнопку Обновить. Возможно, при этом откроется окно выбора одного из отладчиков Microsoft Script Editor и Microsoft Script Debugger. В этом случае выберите Microsoft Script Editor. Откроется главное окно отладчика Microsoft Script Editor (рис. 12.6).<br></br><div class="wrap_pict"><div style="text-align: center;"><img src="i_189.png" alt=""></img></div>   <b>Рис. 12.6.</b> Окно отладчика<br></br></div><br></br>   Обратите внимание, что интерпретирование страницы в браузере приостановилось на первой строке кода сценария, которая отмечена стрелкой. Таким образом, вы можете приступить к пошаговому выполнению сценария. Чтобы знать, на каком вы шаге, нужно контролировать значение переменной i.<br></br>   1. Выберите команду меню Debug &#8594; QuickWatch (Отладка &#8594; Быстрый просмотр). Появится окно QuickWatch (Быстрый просмотр) (рис. 12.7).<br></br><div class="wrap_pict"><div style="text-align: center;"><img src="i_190.png" alt=""></img></div>   <b>Рис. 12.7.</b> Окно QuickWatch (Быстрый просмотр)<br></br></div><br></br>   2. Введите в поле Expression (Выражение) имя необходимой переменной, то есть i.<br></br>   3. Нажмите кнопку Add Watch (Добавить просмотр). В окне отладчика появится панель Watch (Просмотр) со значениями переменной i (рис. 12.8).<br></br><div class="wrap_pict"><div style="text-align: center;"><img src="i_191.png" alt=""></img></div>   <b>Рис. 12.8.</b> Переменная под контролем<br></br></div><br></br>   4. Закройте окно QuickWatch (Быстрый просмотр).<br></br><br></br>   Таким образом, вы можете узнать, какое это по счету повторение. Вы также можете изменить значение переменной.<br></br>   1. Щелкните кнопкой мыши на значении переменной i на панели Watch (Просмотр).<br></br>   2. Введите необходимое значение (в данном случае не больше 19, например 18).<br></br>   Вот так просто вы уже на предпоследнем повторе цикла. Сделайте несколько шагов и увидите, что у вас получилось в браузере.<br></br>   1. Выберите команду меню Debug &#8594; Step into (Отладка &#8594; Сделать шаг).<br></br>   2. Повторяйте первый шаг до тех пор, пока не появится окно браузера (рис. 12.9).<br></br><div class="wrap_pict"><div style="text-align: center;"><img src="i_192.png" alt=""></img></div>   <b>Рис. 12.9.</b> Результат после изменения хода выполнения сценария<br></br></div><br></br>   Как видите, количество приветствий уже другое. Все потому, что вы поменяли значение переменной i. Кроме того, отладчики позволяют выполнить произвольную строку кода сценария или пропустить несколько строк.<br></br></div><h2 id="idm139732201857232">Резюме
</h2><div style="text-align: justify" class="hsection2">   В данной главе мы рассмотрели, как организовать рабочее окружение. Теперь у вас есть все необходимое, в подтверждение чего вы создали первый сценарий. Кроме того, вы даже вмешались в ход выполнения сценария с помощью отладчика. Конечно, пока еще многое вам непонятно, но уже вскоре вы научитесь создавать свои собственные сценарии.<br></br>   Стоит сказать, что сейчас в большинстве веб-страниц применяются сценарии на JavaScript. Вы всегда можете посмотреть исходный код страниц и увидеть, как сценарии внедрены в HTML-документ и что вообще они из себя представляют. Кроме того, в Интернете существует немало сайтов, посвященных созданию сценариев. На них вы сможете узнать массу полезной информации, а также получить уже готовые сценарии, которые сразу же сможете применять на своих веб-страницах. Много ссылок на сайты, посвященные JavaScript, можно найти в таких каталогах, как «Яндекс» (<a href="http://www.yandex.ru/">http://www.yandex.ru</a>) или «Апорт» (<a href="http://www.aport.ru/">http://www.aport.ru</a>), в разделах, посвященных языкам программирования. Язык JavaScript очень популярен, и с поиском необходимой информации проблем не возникнет.<br></br></div></div><h1 xmlns="http://www.w3.org/1999/xhtml" id="idm139732201859664" class="master">Глава 13<br></br>
Язык XHTML
</h1><div xmlns="http://www.w3.org/1999/xhtml" style="text-align: justify" class="hsection1"><div style="text-align: justify" class="section2">   13.1. Структура XHTML-документов<br></br>
   13.2. Отличие XHTML от HTML<br></br>
   13.3. Проблемы использования XHTML<br></br>
   Итак, в предыдущих главах книги вы изучили возможности HTML 4.01 и теперь готовы разрабатывать веб-страницы, основанные на этом языке гипертекстовой разметки. Язык HTML версии 4.01 в основном поддерживается популярными браузерами Интернета, так что разработанные вами страницы будут корректно отображаться на экранах компьютеров большинства пользователей. Это большое достоинство HTML, появившееся в процессе эволюции версий языка и взглядов разработчиков браузеров на важность стандартизованного способа представления информации, размещаемой в Сети. Однако ничего не стоит на месте, и сейчас стали очевидными и недостатки HTML. С помощью этого языка вы не сможете адекватно воспроизвести химические или математические формулы, нотную запись, иероглифы. Он не позволит вам корректно отобразить информацию на таких портативных устройствах, как карманные компьютеры, смартфоны, устройства чтения электронных книг. Таким образом, развитие средств коммуникации и расширение типов информации, которую требуется по ним передать для анализа, воспроизведения и обработки, потребовали развития языка HTML. Именно эта задача и была решена с появлением языка XHTML.<br></br>
   Казалось бы, что могло быть проще? Нужно было просто создать еще один язык, который удовлетворял бы новым требованиям, включить в текущую версию HTML 4.01 новые элементы, новые языковые конструкции, и все встанет на свои места. Однако никто не мог бы гарантировать всеобъемлющей полноты этого языка, что может привести к появлению множества нестандартных, плохо согласованных версий HTML. Иными словами, такой путь развития языка мог привести к повторению первых этапов формирования HTML, когда мало кто заботился о соответствии своих версий языка HTML стандартной версии, поддерживаемой W3C. При таком подходе браузеры различных производителей могли неадекватно отображать (и отображали!) содержимое «чужих» HTML-документов, поскольку просто не понимали использованные в них языковые конструкции. В те времена разработчикам веб-страниц приходилось нелегко, поскольку их основная задача состояла (и состоит) в обеспечении максимально широкого доступа к своим сайтам.<br></br>
   В результате специалисты W3C избрали другой путь, более продуктивный и перспективный. Вместо создания новой версии языка HTML они предложили средство, с помощью которого разработчики могли бы определять и описывать собственные языки гипертекстовой разметки. Этим средством является <i>метаязык </i>XML (eXtensible Markup Language – расширяемый язык разметки), то есть специальный язык, служащий для определения и задания других языков гипертекстовой разметки. Термин «мета» как раз и означает его функцию: метаязыки – это языки, служащие для описания и определения новых языков.<br></br>
   Использование метаязыков в определении языков гипертекстовой разметки отнюдь не инновация W3C. Своим появлением на свет язык HTML обязан метаязыку SGML (Standard Generalized Markup Language – стандартный обобщенный язык разметки). В приложении D «HTML 4.01 DTD» на сайте W3C (<a href="http://www.w3.org/">www.w3.org</a>) все конструкции языка HTML 4.01 описаны с помощью <i>набора определений типа документа</i> (DTD – Document Type Definition). Это набор специальных конструкций метаязыка SGML, описывающих язык HTML 4.01. На следующем этапе развития языка гипертекстовой разметки специалисты W3C создали метаязык XML и с помощью набора XML DTD – язык XHTML, наследующий возможности HTML 4.01, но с некоторыми уточнениями и усовершенствованиями. Язык XHTML обеспечивает поддержку всех средств HTML 4.01, применяя более жесткие правила XML DTD.<br></br>
   Почему же специалисты W3C разработали новый метаязык XML вместо использования SGML? Причина состоит в сложности SGML: насколько он универсален и всемогущ, настолько и сложен в понимании. Поэтому он непригоден для широкого использования разработчиками специализированных версий языков гипертекстовой разметки. Язык XML для определения новых языков использует отдельные (но не все) элементы SGML, кроме того, в нем присутствуют упрощенные элементы SGML, более подходящие для широкого применения.<br></br>
   В настоящий момент имеется три типа DTD, используемых для определения языка XHTML.<br></br>
   1. Первый тип соответствует <i>строгому</i> применению правил XHTML DTD в данном документе. При этом запрещается использование всех тегов и атрибутов HTML, признанных устаревшими по разным причинам, например запрещены все атрибуты форматирования текста по причине их замены таблицами CSS. К числу последних относятся тег &lt;font&gt; и атрибут выравнивания align. Однако такое ограничение для многих просто неприемлемо, поскольку использование элементов этого типа стало для разработчиков привычкой, выработанной годами работы над HTML-документами.<br></br>
   2. Второй тип XHTML DTD называется <i>переходным</i> и включает в себя все нежелательные элементы HTML, чтобы разработчики веб-страниц могли постепенно перейти от старого к новому. Такой подход соответствует тенденциям в развитии браузеров, которые не спешат расставаться со старыми добрыми средствами создания веб-страниц с помощью пусть и устаревших, но привычных и надежных тегов HTML.<br></br>
   3. Третий тип DTD определяет работу с фреймами, в остальном он соответствует переходным XHTML DTD.<br></br>
   В настоящее время актуальна версия 1.0 языка XHTML, но уже на подходе версия 1.1.<br></br>
   В основном создание документа XHTML 1.0 не отличается от создания документа HTML. Однако в синтаксисе и структуре документа имеются определенные отличия, которые обязательно должны быть учтены, если вы хотите добиться соответствия своей веб-страницы требованиям XHTML. Обсудим устройство документов XHTML 1.0 и их отличие от документов, подготовленных на основе языка HTML 4.01.<br></br>
</div><h2 id="idm139732188982352">13.1. Структура XHTML-документов
</h2><div style="text-align: justify" class="hsection2">   Чтобы XHTML-документ полностью отвечал требованиям строгих правил XHTML DTD, ему нужно указать, какой набор XML DTD был использован при его создании, версию применяемого языка XML, а также <i>пространство имен документа. </i>Вся эта информация помещается в начало документа в виде объявлений. Рассмотрим эти три компонента по порядку.<br></br>   В настоящее время существует две версии языка XML: 1.0 и 1.1. Их отличия в основном сводятся к более строгим требованиям к используемым в документах кодировкам символов, предъявляемым языком XML 1.1, что расширяет сферу применения соответствующих документов, например на мейнфреймах. Более широко применяется версия XML 1.0, поэтому использовать будем именно ее. Для объявления того, что вы используете в данном XHTML-документе язык XML версии 1.0, следует поместить в первой строке документа следующую строку:<br></br>   &lt;?xml version="1.0" encoding="UTF-8" ?&gt;<br></br>   В ней браузеру сообщается, что вы используете XML версии 1.0 и представление символов в кодировке Unicode с разрядностью 8.<br></br>   Теперь объявим набор DTD языка разметки XHTML:<br></br>   &lt;!DOCTYPE html PUBLIC « //W3C//DTD XHTML 1.0 Strict//EN» «http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd»&gt;<br></br>   В вышеприведенной конструкции объявлено, что в данном документе корневым элементом является html, а для его разработки использован набор XHTML DTD с публичным именем «//W3C//DTD XHTML 1.0 Strict//EN». Если браузер сумеет найти эти DTD по публичному имени, он будет использовать их, иначе он может применить набор XML DTD, хранимый в файле, который указан в URL вслед за публичным именем. В данном случае это документ по адресу <a href="http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd</a>. Слово «strict» в названии файла означает «строгий», так что в данном документе использован строгий тип XHTML DTD. Указанный в адресе файл xhtml1-strict.dtd хранит все правила DTD, написанные на языке XML. Описание языка XML выходит за рамки этой книги, ограничимся только замечанием, что для всех разработчиков, которые хотят работать с XHTML на профессиональном уровне, знание языка XML является обязательным.<br></br>   Если же вы намерены использовать переходной тип XHTML-документов, добавьте такое объявление:<br></br>   &lt;!DOCTYPE html PUBLIC «//W3C//DTD XHTML 1.0 Transitional//EN» «http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd»&gt;<br></br>   Для фреймовой версии XHTML DTD объявление таково:<br></br>   &lt;!DOCTYPE html PUBLIC «//W3C//DTD XHTML 1.0 Frameset//EN» «http://www.w3.org/TR/xhtml1/DTD/xhtml1-frameset.dtd»&gt;<br></br>   Итак, мы объявили версию XML и набор XHTML DTD для создаваемого XHTML-документа. Теперь зададимся вопросом: а что если мы используем переходные правила XHTML DTD, но нам требуется включить в свой документ некий фрагмент, содержащий разметку по правилам специально определенного набора DTD, например для воспроизведения нотной записи? Для этих целей в документах XHTML используется так называемое <i>пространство имен.</i><br></br>   Пространство имен – это список имен всех тегов и атрибутов, которые применяются в XHTML-документе, подчиняющемся определенному набору правил XML DTD. С этой целью в правилах XML DTD всегда задается пространство имен, уникальное для каждого конкретного набора DTD. Соответственно, в XHTML DTD также определено стандартное пространство имен, которое должно быть хотя бы раз явно объявлено в документе XHTML. Обычно это делается с помощью атрибута xmlns тега &lt;html&gt;:<br></br>   &lt;html xmlns="http://www.w3.org/TR/xhtml1"&gt;<br></br>   Здесь задано пространство имен, хранимое в документе по адресу <a href="http://www.w3.org/TR/xhtml1">http://www.w3.org/TR/xhtml1</a>, где находится официальная спецификация языка XHTML. Для использования в XHTML-документах нескольких DTD предусмотрена возможность прямого указания пространства имен, к которому принадлежит данный тег или атрибут разметки. Это делается с помощью атрибута xmlns, который можно поместить в открывающий тег любого элемента в документе, например, так:<br></br>   &lt;div xmlns="http://www.w3.org/1998/Math/MathML&gt;у4/z&lt;/div"&gt;<br></br>   В этом случае XHTML-совместимый браузер, обрабатывая документ, получит указание, что при воспроизведении содержимого данного тега &lt;div&gt; следует воспользоваться набором математических правил DTD, взяв их по указанному адресу http:// <a href="http://www.w3.org/1998/Math/MathML">www.w3.org/1998/Math/MathML</a>. Здесь хранится спецификация языка математической разметки MathML (Mathematical Markup Language). При этом запись y4/z будет воспроизведена браузером как математическое выражение деления двух переменных y4 и z, а не как содержимое тега &lt;div&gt;, определенного в общих XHTML DTD.<br></br>   Как видите, ссылки на пространства имен достаточно объемны. Чтобы сократить их размер и упростить себе работу по составлению документа, можно использовать так называемые <i>метки,</i> вставляя их в определения пространства имен в начале документа:<br></br>   &lt;html xmlns="http://www.w3.org/TR/xhtml1" xmlns:math="http://www.w3.org/1998/Math/MathML"&gt;<br></br>   После этого можно будет обращаться к данному пространству имен во всех тегах документа так:<br></br>   &lt;math:div&gt;y4/z&lt;/div&gt;<br></br>   Здесь приведена сокращенная версия тега &lt;div&gt; из предыдущего примера.<br></br>   Итак, сведем все воедино, запишем весь созданный XHTML-документ целиком (листинг 13.1).<br></br><h5 class="subtitle"><b>Листинг 13.1.</b> Образец XHTML-документа</h5>   &lt;?xml version="1.0" encoding="UTF-8"?&gt;<br></br>   &lt;!DOCTYPE html PUBLIC "//W3C//DTD XHTML 1.0 Transitional//EN"<br></br>   "http://www.w3.org/TR/xhtml1/DTD/xhtml1 transitional.dtd"&gt;<br></br>   &lt;html xmlns="http://www.w3.org/TR/xhtml1" xml:lang="en" lang="en"&gt;<br></br>   &lt;head&gt;<br></br>   &lt;title&gt;Это наш первый XHTML-документ&lt;/title&gt;<br></br>   &lt;/head&gt;<br></br>   &lt;body&gt;<br></br>   ...Здесь находится содержимое документа...<br></br>   &lt;/body&gt;<br></br>   &lt;/html&gt;<br></br>   Все компоненты этого документа должны быть вам знакомы. В начале стоят объявления об использовании в документе языка XML 1.0 и переходных правил XHTML 1.0 DTD. В декларативной части внутри элемента head содержится элемент title заголовка документа, который в языке XHTML обязателен. В элементе html с помощью атрибута xmlns объявлено, что по умолчанию пространством имен документа будет XHTML 1.0. С помощью атрибута lang указано, что в документе XHTML применяется английский язык.<br></br>   Однако что теперь мы можем ввести в тело XHTML-документа? Поскольку мы объявили использование для него переходных правил DTD XHTML 1.0, допустимы практически любые элементы, теги и атрибуты языка HTML 4.01, однако при их использовании мы должны учитывать определенные ограничения. Эти ограничения еще более жестки в готовящейся версии языка XHTML 1.1, причем настолько, что практически исключают какие-либо вольности в составлении XHTML-документов. Мы же ограничимся более либеральной версией 1.0.<br></br></div><h2 id="idm139732188953424">13.2. Отличие XHTML от HTML
</h2><div style="text-align: justify" class="hsection2"><div style="text-align: justify" class="section3">   Основным отличием документа XHTML от HTML 4.01 является жесткое требование к корректности документа с точки зрения стандартов языка XML. На протяжении истории развития языка HTML сложился подход, при котором допускались многочисленные вольности и отступления от стандартов языка, объявленных W3C, а браузеры различных производителей пытались компенсировать эти вольности, угадывая и корректируя HTML-код с целью его адекватного воспроизведения. Все это отменяется в языке XHTML, если следовать строгим наборам XHTML DTD, а переходные наборы XHTML DTD служат лишь на период перехода от старого к новому: от HTML к XHTML.<br></br>
</div><h3 id="idm139732188954576">Значения атрибутов должны быть в кавычках
</h3><div style="text-align: justify" class="hsection3">   В языке HTML значения атрибутов должны быть заключены в кавычки, только если в значение входят пробелы или специальные символы. Но в языке XHTML это недопустимо: все значения должны заключаться в кавычки. Например, в теге &lt;td&gt;, входящем в документ HTML, допустимо написать следующее:<br></br>   &lt;td width=123 height=90&gt;<br></br>   Однако в языке XHTML это считается ошибкой. Следует писать так:<br></br>   &lt;td width="123" height="90"&gt;<br></br>   Хотя это и кажется избыточным, но выполнение такого правила обязательно.<br></br></div><h3 id="idm139732188957648">Необходимо наличие закрывающего тега
</h3><div style="text-align: justify" class="hsection3">   В стандарте языка HTML 4.01 допускается пропуск закрывающего тега, если программа, которая будет обрабатывать соответствующий документ, сможет «догадаться» о его наличии. Поэтому вполне допустимо опускать закрывающие теги &lt;/p&gt; между соседними абзацами или &lt;/td&gt; для ячеек в таблицах. Но в XHTML наличие закрывающих тегов обязательно, например два смежных абзаца должны записываться так:<br></br>   &lt;p&gt;<br></br>   Это первый абзац<br></br>   &lt;/p&gt;<br></br>   &lt;p&gt;<br></br>   &lt;Это второй абзац&gt;<br></br>   &lt;/p&gt;<br></br>   Конечно, такое требование сильно загромождает код, однако устраняет какие-либо двусмысленности в разметке документа, поскольку позволяет точно идентифицировать любой элемент кода.<br></br>   То же самое касается и пустых элементов. Каждый тег такого элемента должен иметь как открывающий, так и закрывающий тег, например тег обрыва строки теперь должен писаться так: &lt;br&gt;&lt;/br&gt;, иначе строка разорвана не будет. К счастью, в этом случае допускается запись &lt;br/&gt;, то есть перед завершающей угловой скобкой следует поместить наклонную черту. Если же у тега есть атрибуты, то угловая черта пишется после них, например &lt;img src="mypicture.jpg"/&gt;.<br></br></div><h3 id="idm139732188912848">Необходимо корректно вкладывать элементы друг в друга
</h3><div style="text-align: justify" class="hsection3">   Это требование стандарта XHTML не отличается от требований HTML. Каждый элемент, вложенный в другой элемент, должен быть закрыт завершающим тегом, лежащим внутри содержащего его элемента. Например, в данном примере элемент для задания курсивного текста включает тег полужирного начертания:<br></br>   &lt;i&gt;&lt;b&gt;<br></br>   …форматируемый текст…<br></br>   &lt;/b&gt; &lt;/i&gt;<br></br>   Этот пример корректен. Однако если мы напишем так:<br></br>   &lt;i&gt;&lt;b&gt;<br></br>   …форматируемый текст…<br></br>   &lt;/i&gt; &lt;/b&gt;<br></br>   то нарушим требования HTML. Тем не менее эти и им подобные требования не всегда выполнялись разработчиками, и «добрые» браузеры обычно корректировали такие нарушения кода. Однако стандарт XHTML запрещает подобные нарушения. Кроме того, XHTML запрещает следующие вложения:<br></br>   • тег &lt;form&gt; не может содержать теги &lt;form&gt;;<br></br>   • тег &lt;button&gt; не может содержать теги &lt;textarea&gt;, &lt;select&gt;, &lt;input&gt;, &lt;iframe&gt;, &lt;label&gt;, &lt;button&gt;, &lt;form&gt;, &lt;isindex&gt;, &lt;fildset&gt;;<br></br>   • тег &lt;a&gt; не может содержать другой тег &lt;a&gt;;<br></br>   • тег &lt;label&gt; не может содержать другие теги &lt;label&gt;;<br></br>   • тег &lt;pre&gt; не может содержать теги &lt;img&gt;, &lt;sup&gt;, &lt;object&gt;, &lt;small&gt;, &lt;sub&gt;, &lt;big&gt;.<br></br>   При этом глубина вложения не имеет значения. Допустим, если в тег &lt;a&gt; вложены другие теги, они не могут включать в себя тег &lt;a&gt;. Браузер, строго поддерживающий XHTML, не сможет адекватно воспроизвести документы с такими нарушениями.<br></br></div><h3 id="idm139732188919760">Назначение имен тегов и атрибутов зависит от регистра
</h3><div style="text-align: justify" class="hsection3">   В документах HTML имена тегов и атрибутов не зависят от регистра символов, так что, например, запись &lt;TABLE&gt;, &lt;TaBle&gt; или &lt;table&gt; означает один и тот же тег таблицы. Однако в XHTML это разные теги. То же самое касается имен атрибутов: записи типа width или WiDtZ в XHTML уже не означают имя атрибута, задающего ширину, например, ячейки таблицы или рисунка.<br></br>   В XHTML все имена тегов и атрибутов, которые были заимствованы из HTML, должны быть записаны строчными буквами. Если же при написании тегов и атрибутов были использованы прописные буквы, обрабатывающая их программа, строго поддерживающая стандарт XHTML, не сможет их корректно обработать.<br></br></div><h3 id="idm139732188921168">Требуется явно задавать значения атрибутов
</h3><div style="text-align: justify" class="hsection3">   В документах XHTML всем атрибутам следует присваивать значения, даже если по стандарту HTML это не требуется. Например, в тегах списков &lt;ol&gt;, &lt;ul&gt; часто используется атрибут compact, приводящий к уменьшению расстояния между буквами в тексте списков. Если этот атрибут включен в тег, например &lt;ul compact&gt;, то текст в списке будет отображаться более компактно. Однако в XHTML такая запись запрещена и вам придется написать так: &lt;ul compact="compact"&gt;. В табл. 13.1 приведены атрибуты, которым в языке XHTML следует задавать значения, совпадающие с их названием.<br></br><h5 class="subtitle"><b>Таблица 13.1.</b> Значения атрибутов XHTML, для которых HTML не требовал значений</h5><div style="text-align: center;"><img src="i_193.png" alt=""></img></div></div><h3 id="idm139732188922960">Включение сценариев и специальных символов в документы XHTML
</h3><div style="text-align: justify" class="hsection3">   В документы HTML сценарии встраиваются с помощью комментариев, то есть коды сценариев помещаются внутрь объявлений комментария:<br></br>   &lt;!<br></br>   …Код сценария JavaScript или таблицы CSS….<br></br>   &gt;<br></br>   В них же помещают объявления таблиц CSS, что позволяет избежать конфликтов, если браузер не поддерживает эти средства. Однако браузеры XML не воспринимают содержимое комментариев и требуют использования таких конструкций, содержащих тег CDATA языка XML:<br></br>   &lt;script language="JavaScript"&gt;<br></br>   &lt;![CDATA[<br></br>   …код сценария JavaScript...<br></br>   ]]&gt;<br></br>   &lt;/script&gt;<br></br>   Вместе с тем это может привести к проблемам при воспроизведении такого документа браузерами HTML, которые не понимают XML-тег CDATA. Оптимальным решением будет помещение сценариев во внешние файлы и включение в документы ссылок на эти файлы.<br></br>   Все специальные символы в документы XHTML следует записывать с помощью ссылок, то есть вместо записи &lt;img src="logo.gif" alt="Логотип фирмы Бублики &amp; Баранки"&gt; следует написать &lt;img src="logo.gif" alt="Логотип фирмы Бублики &amp;amp Баранки" &gt;<br></br></div></div><h2 id="idm139732188879568">13.3. Проблемы использования XHTML
</h2><div style="text-align: justify" class="hsection2">   Прочитав эту главу, вы, вероятно, поняли, что перед разработчиками веб-страниц встала серьезная проблема: переход на новый язык XHTML значительно меняет сложившиеся подходы к их разработке.<br></br>   Во-первых, уже нельзя позволить себе многие вольности и ошибки в коде гипертекстовой разметки страницы, которую допускал если не сам язык HTML, то сложившаяся практика его использования. Разработчики писали свои коды в расчете, что браузеры сумеют сами заметить некоторые ошибки и отступления от стандарта и адекватно воспроизвести HTML-документ. Однако с появлением XHTML эти вольности отменяются, строгое следование правилам XHTML 1.0 исключает любые ошибки в коде разметки документа XHTML.<br></br>   Во-вторых, появляется проблема «старых» веб-страниц, в которых применены устаревшие и нежелательные элементы и атрибуты языка HTML. Этих документов за многие годы применения HTML накопилось великое множество, миллионы и миллионы сайтов разработаны на языке HTML, и их изменение под новый стандарт XHTML совершенно разорительно.<br></br>   Так стоит ли использовать XHTML? И если да, то как избежать возможных осложнений и потерь? Ответ таков: если вы хотите долгой и безбедной жизни своего сайта, то его следует создавать по новым стандартам XHTML. Конечно, еще несколько лет все браузеры и прочие программы, работающие со старыми HTML-документами, будут поддерживать работу с ними, поскольку объем накопившихся в Сети ресурсов, не соответствующих канонам XHTML, чрезвычайно велик. Но ничто не вечно, и лет через 5–6 сайт с устаревшими HTML-страницами, в которых использованы теги форматирования текста вместо конструкций CSS или элементы и атрибуты кода разметки написаны без учета ограничений XHTML, будет неадекватно воспроизводиться новыми браузерами, поддерживающими XHTML.<br></br>   Что же делать? Во-первых, новые веб-документы следует готовить по правилам языка XHTML. Поскольку написание кода разметки на языке XHTML стало более сложным занятием, наилучшим решением будет применение автоматических средств подготовки XHTML-документов. Иными словами, при выборе редактора веб-страниц лучше обращать внимание на те, которые поддерживают стандарты XHTML. Во-вторых, для обновления устаревших HTML-документов под стандарт XHTML можно использовать автоматические средства, например программу Tidy, бесплатно распространяемую организацией W3C по адресу http:// tidy.sourceforge.net/.<br></br>   Рассмотрим, что умеет делать эта программа.<br></br>   • Добавляет отсутствующий или исправляет некорректный завершающий тег. Например, такой код:<br></br>   &lt;h1&gt;Заголовок<br></br>   &lt;h2&gt;Подзаголовок&lt;/h3&gt;<br></br>   будет преобразован в:<br></br>   &lt;h1&gt;Заголовок&lt;/h1&gt;<br></br>   &lt;h2&gt;Подзаголовок&lt;/h2&gt;<br></br>   • Изменяет некорректный порядок завершающих тегов. Например, следующий код:<br></br>   &lt;p&gt;Этот текст должен быть &lt;b&gt;Полужирным&lt;i&gt; Полужирным курсивом&lt;/b&gt; Полужирным&lt;/i&gt; Нормальным<br></br>   преобразуется в:<br></br>   &lt;p&gt;Этот текст должен быть &lt;b&gt;Полужирным&lt;i&gt; Полужирным курсивом&lt;/i&gt; Полужирным&lt;/b&gt; Нормальным<br></br>   Вы сами можете проверить эффект этого преобразования.<br></br>   • Добавляет пропущенный слэш в завершающем теге. Такой код:<br></br>   &lt;a href="#refs"&gt;Текст ссылки&lt;a&gt;<br></br>   превращается в:<br></br>   &lt;a href="#refs"&gt;Текст ссылки&lt;/a&gt;<br></br>   • Корректирует списки, внося пропущенные завершающие теги. Например, следующий код:<br></br>   &lt;body&gt;<br></br>   &lt;li&gt;1-й пункт списка<br></br>   &lt;li&gt;2-й пункт списка<br></br>   превращается в:<br></br>   &lt;body&gt;<br></br>   &lt;ul&gt;<br></br>   &lt;li&gt;1-й пункт списка&lt;/li&gt;<br></br>   &lt;li&gt;2-й пункт списка&lt;/li&gt;<br></br>   &lt;/ul&gt;<br></br>   • Заключает в кавычки значения атрибутов.<br></br>   • Анализирует документ и автоматически вставляет элемент &lt;!doctype&gt;.<br></br>   • Подсвечивает некорректные, не распознанные программой атрибуты HTML 4.0 в документе.<br></br>   Применив программу Tidy, можно очистить HTML-документы от многих недостатков и ошибок, что позволит использовать их в качестве корректных XHTML-документов и значительно упростит работу по переходу на новые стандарты языка.<br></br></div><h2 id="idm139732188813776">Резюме
</h2><div style="text-align: justify" class="hsection2">   Итак, в этой главе мы обсудили возможности языка XHTML, идущего на смену HTML 4.01, получили представление о концепции W3C, лежащей в основе развития языка гипертекстовой разметки, – предложении использовать метаязык XML. Вы узнали об основных отличиях XHTML-документов от HTML-документов: это требования к более точному и корректному написанию элементов и тегов, обязательное наличие объявлений версии языка XML, набора правил XHTML DTD и пространства имен. Наконец, были описаны возможности программы Tidy по очистке документов на языке HTML 4.0 с целью адаптации к языку XHTML.<br></br>   Знание этого позволит вам настроиться на перспективу развития средств, предлагаемых для разработки сайтов. Язык XHTML – это еще одна попытка сделать ресурсы Сети доступными как можно большему количеству пользователей. Все разработчики должны следовать требованиям языка XHTML, что станет залогом долгого и успешного существования их сайтов.<br></br></div></div>
</body>
</html>
